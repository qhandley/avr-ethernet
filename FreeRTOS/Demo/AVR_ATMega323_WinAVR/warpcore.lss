
warpcore.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007c  00800100  0000556a  000055fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000556a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006b2  0080017c  0080017c  0000567a  2**0
                  ALLOC
  3 .stab         0000eed4  00000000  00000000  0000567c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000063ca  00000000  00000000  00014550  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0001a91a  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0001a92c  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0001a96c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0001af60  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0001b502  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0001b51c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__ctors_end>
       4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      10:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      14:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      18:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      1c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      20:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      24:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      28:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      2c:	0c 94 b3 14 	jmp	0x2966	; 0x2966 <__vector_11>
      30:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      34:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      38:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      3c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      40:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      44:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      48:	0c 94 8d 01 	jmp	0x31a	; 0x31a <__vector_18>
      4c:	0c 94 cd 01 	jmp	0x39a	; 0x39a <__vector_19>
      50:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      54:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      58:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      5c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      60:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      64:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      68:	57 1f       	adc	r21, r23
      6a:	7e 1f       	adc	r23, r30
      6c:	89 1f       	adc	r24, r25
      6e:	9b 1f       	adc	r25, r27
      70:	a2 1f       	adc	r26, r18
      72:	ac 1f       	adc	r26, r28
      74:	b3 1f       	adc	r27, r19
      76:	c3 1f       	adc	r28, r19
      78:	fd 1f       	adc	r31, r29
      7a:	00 20       	and	r0, r0
      7c:	03 20       	and	r0, r3
      7e:	12 20       	and	r1, r2
      80:	1d 20       	and	r1, r13
      82:	2c 20       	and	r2, r12
      84:	69 20       	and	r6, r9
      86:	a9 20       	and	r10, r9
      88:	bb 20       	and	r11, r11
      8a:	c2 20       	and	r12, r2
      8c:	cf 20       	and	r12, r15
      8e:	e4 20       	and	r14, r4
      90:	f3 20       	and	r15, r3
      92:	7e 21       	and	r23, r14
      94:	17 21       	and	r17, r7
      96:	37 21       	and	r19, r7
      98:	54 21       	and	r21, r4
      9a:	3b 21       	and	r19, r11
      9c:	42 21       	and	r20, r2
      9e:	63 21       	and	r22, r3
      a0:	2e 24       	eor	r2, r14
      a2:	31 24       	eor	r3, r1
      a4:	43 24       	eor	r4, r3
      a6:	3e 24       	eor	r3, r14
      a8:	46 24       	eor	r4, r6
      aa:	4c 24       	eor	r4, r12
      ac:	51 24       	eor	r5, r1
      ae:	60 24       	eor	r6, r0
      b0:	76 24       	eor	r7, r6
      b2:	87 24       	eor	r8, r7
      b4:	8a 24       	eor	r8, r10
      b6:	8e 24       	eor	r8, r14
      b8:	4a 24       	eor	r4, r10
      ba:	92 24       	eor	r9, r2
      bc:	98 24       	eor	r9, r8
      be:	9b 24       	eor	r9, r11

000000c0 <__ctors_end>:
      c0:	11 24       	eor	r1, r1
      c2:	1f be       	out	0x3f, r1	; 63
      c4:	cf ef       	ldi	r28, 0xFF	; 255
      c6:	d8 e0       	ldi	r29, 0x08	; 8
      c8:	de bf       	out	0x3e, r29	; 62
      ca:	cd bf       	out	0x3d, r28	; 61

000000cc <__do_copy_data>:
      cc:	11 e0       	ldi	r17, 0x01	; 1
      ce:	a0 e0       	ldi	r26, 0x00	; 0
      d0:	b1 e0       	ldi	r27, 0x01	; 1
      d2:	ea e6       	ldi	r30, 0x6A	; 106
      d4:	f5 e5       	ldi	r31, 0x55	; 85
      d6:	02 c0       	rjmp	.+4      	; 0xdc <__do_copy_data+0x10>
      d8:	05 90       	lpm	r0, Z+
      da:	0d 92       	st	X+, r0
      dc:	ac 37       	cpi	r26, 0x7C	; 124
      de:	b1 07       	cpc	r27, r17
      e0:	d9 f7       	brne	.-10     	; 0xd8 <__do_copy_data+0xc>

000000e2 <__do_clear_bss>:
      e2:	28 e0       	ldi	r18, 0x08	; 8
      e4:	ac e7       	ldi	r26, 0x7C	; 124
      e6:	b1 e0       	ldi	r27, 0x01	; 1
      e8:	01 c0       	rjmp	.+2      	; 0xec <.do_clear_bss_start>

000000ea <.do_clear_bss_loop>:
      ea:	1d 92       	st	X+, r1

000000ec <.do_clear_bss_start>:
      ec:	ae 32       	cpi	r26, 0x2E	; 46
      ee:	b2 07       	cpc	r27, r18
      f0:	e1 f7       	brne	.-8      	; 0xea <.do_clear_bss_loop>
      f2:	0e 94 9e 29 	call	0x533c	; 0x533c <main>
      f6:	0c 94 b3 2a 	jmp	0x5566	; 0x5566 <_exit>

000000fa <__bad_interrupt>:
      fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fe <vBlinkyFunction>:
	return 0;
}
/*-----------------------------------------------------------*/

static void vBlinkyFunction( void *pvParameters )
{
      fe:	cf 93       	push	r28
     100:	df 93       	push	r29
     102:	cd b7       	in	r28, 0x3d	; 61
     104:	de b7       	in	r29, 0x3e	; 62
     106:	2a 97       	sbiw	r28, 0x0a	; 10
     108:	0f b6       	in	r0, 0x3f	; 63
     10a:	f8 94       	cli
     10c:	de bf       	out	0x3e, r29	; 62
     10e:	0f be       	out	0x3f, r0	; 63
     110:	cd bf       	out	0x3d, r28	; 61

    for( ;; )
    {
        for(uint8_t r=0; r<2; r++)
        {
            PORTB ^= 0x20;
     112:	10 e2       	ldi	r17, 0x20	; 32
     114:	85 b1       	in	r24, 0x05	; 5
     116:	81 27       	eor	r24, r17
     118:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     11a:	2f ef       	ldi	r18, 0xFF	; 255
     11c:	83 ed       	ldi	r24, 0xD3	; 211
     11e:	90 e3       	ldi	r25, 0x30	; 48
     120:	21 50       	subi	r18, 0x01	; 1
     122:	80 40       	sbci	r24, 0x00	; 0
     124:	90 40       	sbci	r25, 0x00	; 0
     126:	e1 f7       	brne	.-8      	; 0x120 <vBlinkyFunction+0x22>
     128:	00 c0       	rjmp	.+0      	; 0x12a <vBlinkyFunction+0x2c>
     12a:	00 00       	nop
     12c:	85 b1       	in	r24, 0x05	; 5
     12e:	81 27       	eor	r24, r17
     130:	85 b9       	out	0x05, r24	; 5
     132:	2f ef       	ldi	r18, 0xFF	; 255
     134:	83 ed       	ldi	r24, 0xD3	; 211
     136:	90 e3       	ldi	r25, 0x30	; 48
     138:	21 50       	subi	r18, 0x01	; 1
     13a:	80 40       	sbci	r24, 0x00	; 0
     13c:	90 40       	sbci	r25, 0x00	; 0
     13e:	e1 f7       	brne	.-8      	; 0x138 <vBlinkyFunction+0x3a>
     140:	00 c0       	rjmp	.+0      	; 0x142 <vBlinkyFunction+0x44>
     142:	00 00       	nop
            _delay_ms(1000);
        }

        uint8_t temp[10];

        loopback_tcps( 0, temp, 8080 );
     144:	40 e9       	ldi	r20, 0x90	; 144
     146:	5f e1       	ldi	r21, 0x1F	; 31
     148:	be 01       	movw	r22, r28
     14a:	6f 5f       	subi	r22, 0xFF	; 255
     14c:	7f 4f       	sbci	r23, 0xFF	; 255
     14e:	80 e0       	ldi	r24, 0x00	; 0
     150:	0e 94 7e 03 	call	0x6fc	; 0x6fc <loopback_tcps>

        vTaskDelay( xDelay );
     154:	84 e6       	ldi	r24, 0x64	; 100
     156:	90 e0       	ldi	r25, 0x00	; 0
     158:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskDelay>
     15c:	db cf       	rjmp	.-74     	; 0x114 <vBlinkyFunction+0x16>

0000015e <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	//vCoRoutineSchedule();
    PORTB ^= 0x20;
     15e:	95 b1       	in	r25, 0x05	; 5
     160:	80 e2       	ldi	r24, 0x20	; 32
     162:	89 27       	eor	r24, r25
     164:	85 b9       	out	0x05, r24	; 5
     166:	2f ef       	ldi	r18, 0xFF	; 255
     168:	83 ec       	ldi	r24, 0xC3	; 195
     16a:	99 e0       	ldi	r25, 0x09	; 9
     16c:	21 50       	subi	r18, 0x01	; 1
     16e:	80 40       	sbci	r24, 0x00	; 0
     170:	90 40       	sbci	r25, 0x00	; 0
     172:	e1 f7       	brne	.-8      	; 0x16c <vApplicationIdleHook+0xe>
     174:	00 c0       	rjmp	.+0      	; 0x176 <vApplicationIdleHook+0x18>
     176:	00 00       	nop
     178:	08 95       	ret

0000017a <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     17a:	8f ef       	ldi	r24, 0xFF	; 255
     17c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     180:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     182:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     186:	85 b9       	out	0x05, r24	; 5
     188:	08 95       	ret

0000018a <vParTestSetLED>:
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     18a:	1f 93       	push	r17
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     190:	88 30       	cpi	r24, 0x08	; 8
     192:	d8 f4       	brcc	.+54     	; 0x1ca <vParTestSetLED+0x40>
     194:	16 2f       	mov	r17, r22
	{
		ucBit <<= uxLED;	
     196:	c1 e0       	ldi	r28, 0x01	; 1
     198:	d0 e0       	ldi	r29, 0x00	; 0
     19a:	01 c0       	rjmp	.+2      	; 0x19e <vParTestSetLED+0x14>
     19c:	cc 0f       	add	r28, r28
     19e:	8a 95       	dec	r24
     1a0:	ea f7       	brpl	.-6      	; 0x19c <vParTestSetLED+0x12>

		vTaskSuspendAll();
     1a2:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     1a6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
	{
		ucBit <<= uxLED;	

		vTaskSuspendAll();
		{
			if( xValue == pdTRUE )
     1aa:	11 30       	cpi	r17, 0x01	; 1
     1ac:	19 f4       	brne	.+6      	; 0x1b4 <vParTestSetLED+0x2a>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     1ae:	c0 95       	com	r28
     1b0:	c8 23       	and	r28, r24
     1b2:	01 c0       	rjmp	.+2      	; 0x1b6 <vParTestSetLED+0x2c>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     1b4:	c8 2b       	or	r28, r24
     1b6:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
			}

			PORTB = ucCurrentOutputValue;
     1ba:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     1be:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
	}
}
     1c0:	df 91       	pop	r29
     1c2:	cf 91       	pop	r28
     1c4:	1f 91       	pop	r17
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
     1c6:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <xTaskResumeAll>
	}
}
     1ca:	df 91       	pop	r29
     1cc:	cf 91       	pop	r28
     1ce:	1f 91       	pop	r17
     1d0:	08 95       	ret

000001d2 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     1d2:	cf 93       	push	r28
     1d4:	df 93       	push	r29
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     1d6:	88 30       	cpi	r24, 0x08	; 8
     1d8:	e8 f4       	brcc	.+58     	; 0x214 <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     1da:	c1 e0       	ldi	r28, 0x01	; 1
     1dc:	d0 e0       	ldi	r29, 0x00	; 0
     1de:	01 c0       	rjmp	.+2      	; 0x1e2 <vParTestToggleLED+0x10>
     1e0:	cc 0f       	add	r28, r28
     1e2:	8a 95       	dec	r24
     1e4:	ea f7       	brpl	.-6      	; 0x1e0 <vParTestToggleLED+0xe>

		vTaskSuspendAll();
     1e6:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     1ea:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     1ee:	8c 23       	and	r24, r28
     1f0:	29 f0       	breq	.+10     	; 0x1fc <vParTestToggleLED+0x2a>
			{
				ucCurrentOutputValue &= ~ucBit;
     1f2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     1f6:	c0 95       	com	r28
     1f8:	c8 23       	and	r28, r24
     1fa:	03 c0       	rjmp	.+6      	; 0x202 <vParTestToggleLED+0x30>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     1fc:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     200:	c8 2b       	or	r28, r24
     202:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__data_start>
			}

			PORTB = ucCurrentOutputValue;
     206:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     20a:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
	}
}
     20c:	df 91       	pop	r29
     20e:	cf 91       	pop	r28
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();			
     210:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <xTaskResumeAll>
	}
}
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	08 95       	ret

0000021a <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     21a:	cf 92       	push	r12
     21c:	df 92       	push	r13
     21e:	ef 92       	push	r14
     220:	ff 92       	push	r15
     222:	cf 93       	push	r28
     224:	6b 01       	movw	r12, r22
     226:	7c 01       	movw	r14, r24
     228:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     22a:	0f b6       	in	r0, 0x3f	; 63
     22c:	f8 94       	cli
     22e:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     230:	40 e0       	ldi	r20, 0x00	; 0
     232:	61 e0       	ldi	r22, 0x01	; 1
     234:	8c 2f       	mov	r24, r28
     236:	0e 94 be 0c 	call	0x197c	; 0x197c <xQueueGenericCreate>
     23a:	90 93 7f 01 	sts	0x017F, r25	; 0x80017f <xRxedChars+0x1>
     23e:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <xRxedChars>
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     242:	40 e0       	ldi	r20, 0x00	; 0
     244:	61 e0       	ldi	r22, 0x01	; 1
     246:	8c 2f       	mov	r24, r28
     248:	0e 94 be 0c 	call	0x197c	; 0x197c <xQueueGenericCreate>
     24c:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <__data_end+0x1>
     250:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <__data_end>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     254:	a7 01       	movw	r20, r14
     256:	96 01       	movw	r18, r12
     258:	84 e0       	ldi	r24, 0x04	; 4
     25a:	22 0f       	add	r18, r18
     25c:	33 1f       	adc	r19, r19
     25e:	44 1f       	adc	r20, r20
     260:	55 1f       	adc	r21, r21
     262:	8a 95       	dec	r24
     264:	d1 f7       	brne	.-12     	; 0x25a <xSerialPortInitMinimal+0x40>
     266:	60 e0       	ldi	r22, 0x00	; 0
     268:	74 e2       	ldi	r23, 0x24	; 36
     26a:	84 ef       	ldi	r24, 0xF4	; 244
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <__udivmodsi4>
     272:	da 01       	movw	r26, r20
     274:	c9 01       	movw	r24, r18
     276:	01 97       	sbiw	r24, 0x01	; 1
     278:	a1 09       	sbc	r26, r1
     27a:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     27c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     280:	89 2f       	mov	r24, r25
     282:	9a 2f       	mov	r25, r26
     284:	ab 2f       	mov	r26, r27
     286:	bb 27       	eor	r27, r27
		UBRR0H = ucByte;
     288:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     28c:	88 e9       	ldi	r24, 0x98	; 152
     28e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     292:	86 e8       	ldi	r24, 0x86	; 134
     294:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	}
	portEXIT_CRITICAL();
     298:	0f 90       	pop	r0
     29a:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     29c:	80 e0       	ldi	r24, 0x00	; 0
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	cf 91       	pop	r28
     2a2:	ff 90       	pop	r15
     2a4:	ef 90       	pop	r14
     2a6:	df 90       	pop	r13
     2a8:	cf 90       	pop	r12
     2aa:	08 95       	ret

000002ac <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     2ac:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <xRxedChars>
     2b0:	90 91 7f 01 	lds	r25, 0x017F	; 0x80017f <xRxedChars+0x1>
     2b4:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <xQueueReceive>
     2b8:	91 e0       	ldi	r25, 0x01	; 1
     2ba:	81 11       	cpse	r24, r1
     2bc:	01 c0       	rjmp	.+2      	; 0x2c0 <xSerialGetChar+0x14>
     2be:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return pdFALSE;
	}
}
     2c0:	89 2f       	mov	r24, r25
     2c2:	08 95       	ret

000002c4 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	1f 92       	push	r1
     2ca:	cd b7       	in	r28, 0x3d	; 61
     2cc:	de b7       	in	r29, 0x3e	; 62
     2ce:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     2d0:	20 e0       	ldi	r18, 0x00	; 0
     2d2:	be 01       	movw	r22, r28
     2d4:	6f 5f       	subi	r22, 0xFF	; 255
     2d6:	7f 4f       	sbci	r23, 0xFF	; 255
     2d8:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <__data_end>
     2dc:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <__data_end+0x1>
     2e0:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xQueueGenericSend>
     2e4:	81 30       	cpi	r24, 0x01	; 1
     2e6:	31 f4       	brne	.+12     	; 0x2f4 <xSerialPutChar+0x30>
	{
		return pdFAIL;
	}

	vInterruptOn();
     2e8:	90 91 c1 00 	lds	r25, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     2ec:	90 62       	ori	r25, 0x20	; 32
     2ee:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

	return pdPASS;
     2f2:	01 c0       	rjmp	.+2      	; 0x2f6 <xSerialPutChar+0x32>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
     2f4:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
     2f6:	0f 90       	pop	r0
     2f8:	df 91       	pop	r29
     2fa:	cf 91       	pop	r28
     2fc:	08 95       	ret

000002fe <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     2fe:	0f b6       	in	r0, 0x3f	; 63
     300:	f8 94       	cli
     302:	0f 92       	push	r0
	{
		vInterruptOff();
     304:	e1 ec       	ldi	r30, 0xC1	; 193
     306:	f0 e0       	ldi	r31, 0x00	; 0
     308:	80 81       	ld	r24, Z
     30a:	8f 7d       	andi	r24, 0xDF	; 223
     30c:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     30e:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     310:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     312:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     314:	0f 90       	pop	r0
     316:	0f be       	out	0x3f, r0	; 63
     318:	08 95       	ret

0000031a <__vector_18>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
SIGNAL( USART_RX_vect )
{
     31a:	1f 92       	push	r1
     31c:	0f 92       	push	r0
     31e:	0f b6       	in	r0, 0x3f	; 63
     320:	0f 92       	push	r0
     322:	11 24       	eor	r1, r1
     324:	2f 93       	push	r18
     326:	3f 93       	push	r19
     328:	4f 93       	push	r20
     32a:	5f 93       	push	r21
     32c:	6f 93       	push	r22
     32e:	7f 93       	push	r23
     330:	8f 93       	push	r24
     332:	9f 93       	push	r25
     334:	af 93       	push	r26
     336:	bf 93       	push	r27
     338:	ef 93       	push	r30
     33a:	ff 93       	push	r31
     33c:	cf 93       	push	r28
     33e:	df 93       	push	r29
     340:	00 d0       	rcall	.+0      	; 0x342 <__vector_18+0x28>
     342:	cd b7       	in	r28, 0x3d	; 61
     344:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     346:	19 82       	std	Y+1, r1	; 0x01

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     348:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     34c:	8a 83       	std	Y+2, r24	; 0x02

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     34e:	20 e0       	ldi	r18, 0x00	; 0
     350:	ae 01       	movw	r20, r28
     352:	4f 5f       	subi	r20, 0xFF	; 255
     354:	5f 4f       	sbci	r21, 0xFF	; 255
     356:	be 01       	movw	r22, r28
     358:	6e 5f       	subi	r22, 0xFE	; 254
     35a:	7f 4f       	sbci	r23, 0xFF	; 255
     35c:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <xRxedChars>
     360:	90 91 7f 01 	lds	r25, 0x017F	; 0x80017f <xRxedChars+0x1>
     364:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     368:	89 81       	ldd	r24, Y+1	; 0x01
     36a:	81 11       	cpse	r24, r1
	{
		taskYIELD();
     36c:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
	}
}
     370:	0f 90       	pop	r0
     372:	0f 90       	pop	r0
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	ff 91       	pop	r31
     37a:	ef 91       	pop	r30
     37c:	bf 91       	pop	r27
     37e:	af 91       	pop	r26
     380:	9f 91       	pop	r25
     382:	8f 91       	pop	r24
     384:	7f 91       	pop	r23
     386:	6f 91       	pop	r22
     388:	5f 91       	pop	r21
     38a:	4f 91       	pop	r20
     38c:	3f 91       	pop	r19
     38e:	2f 91       	pop	r18
     390:	0f 90       	pop	r0
     392:	0f be       	out	0x3f, r0	; 63
     394:	0f 90       	pop	r0
     396:	1f 90       	pop	r1
     398:	18 95       	reti

0000039a <__vector_19>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
SIGNAL( USART_UDRE_vect )
{
     39a:	1f 92       	push	r1
     39c:	0f 92       	push	r0
     39e:	0f b6       	in	r0, 0x3f	; 63
     3a0:	0f 92       	push	r0
     3a2:	11 24       	eor	r1, r1
     3a4:	2f 93       	push	r18
     3a6:	3f 93       	push	r19
     3a8:	4f 93       	push	r20
     3aa:	5f 93       	push	r21
     3ac:	6f 93       	push	r22
     3ae:	7f 93       	push	r23
     3b0:	8f 93       	push	r24
     3b2:	9f 93       	push	r25
     3b4:	af 93       	push	r26
     3b6:	bf 93       	push	r27
     3b8:	ef 93       	push	r30
     3ba:	ff 93       	push	r31
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	00 d0       	rcall	.+0      	; 0x3c2 <__vector_19+0x28>
     3c2:	cd b7       	in	r28, 0x3d	; 61
     3c4:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     3c6:	ae 01       	movw	r20, r28
     3c8:	4f 5f       	subi	r20, 0xFF	; 255
     3ca:	5f 4f       	sbci	r21, 0xFF	; 255
     3cc:	be 01       	movw	r22, r28
     3ce:	6e 5f       	subi	r22, 0xFE	; 254
     3d0:	7f 4f       	sbci	r23, 0xFF	; 255
     3d2:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <__data_end>
     3d6:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <__data_end+0x1>
     3da:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <xQueueReceiveFromISR>
     3de:	81 30       	cpi	r24, 0x01	; 1
     3e0:	21 f4       	brne	.+8      	; 0x3ea <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     3e2:	8a 81       	ldd	r24, Y+2	; 0x02
     3e4:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     3e8:	05 c0       	rjmp	.+10     	; 0x3f4 <__vector_19+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     3ea:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     3ee:	8f 7d       	andi	r24, 0xDF	; 223
     3f0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	}
}
     3f4:	0f 90       	pop	r0
     3f6:	0f 90       	pop	r0
     3f8:	df 91       	pop	r29
     3fa:	cf 91       	pop	r28
     3fc:	ff 91       	pop	r31
     3fe:	ef 91       	pop	r30
     400:	bf 91       	pop	r27
     402:	af 91       	pop	r26
     404:	9f 91       	pop	r25
     406:	8f 91       	pop	r24
     408:	7f 91       	pop	r23
     40a:	6f 91       	pop	r22
     40c:	5f 91       	pop	r21
     40e:	4f 91       	pop	r20
     410:	3f 91       	pop	r19
     412:	2f 91       	pop	r18
     414:	0f 90       	pop	r0
     416:	0f be       	out	0x3f, r0	; 63
     418:	0f 90       	pop	r0
     41a:	1f 90       	pop	r1
     41c:	18 95       	reti

0000041e <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     41e:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     420:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     422:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     424:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     426:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     428:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     42a:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     42c:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     42e:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     430:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     432:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     434:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     436:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     438:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     43a:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     43c:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     43e:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     440:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     442:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     444:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     446:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     448:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     44a:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     44c:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     44e:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     450:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     452:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     454:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     456:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     458:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     45a:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     45c:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     45e:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     460:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     462:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     464:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     466:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     468:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     46a:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     46c:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     46e:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     470:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     472:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     474:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     476:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     478:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     47a:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     47c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     480:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     482:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     484:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     488:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     48a:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     48c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     490:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     492:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     494:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     498:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     49a:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     49c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     4a0:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     4a2:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     4a4:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     4a8:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     4aa:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     4ac:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     4b0:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     4b2:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     4b4:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     4b8:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     4ba:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     4bc:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     4c0:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     4c2:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     4c4:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     4c8:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     4ca:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     4cc:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     4d0:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     4d2:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     4d4:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     4d8:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     4da:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     4dc:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     4e0:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     4e2:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     4e4:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     4e8:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     4ea:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     4ec:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     4f0:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     4f2:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     4f4:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     4f8:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     4fa:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     4fc:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     500:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     502:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     504:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     508:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     50a:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     50c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     510:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     512:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     514:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     518:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     51a:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     51c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     520:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     522:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     524:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     528:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     52a:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     52c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     530:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     532:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     534:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     538:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     53a:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     53c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	30"			);
     540:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     542:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     544:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	31"			);
     548:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     54a:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     54c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	32"			);
     550:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     552:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     554:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	33"			);
     558:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     55a:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     55c:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
     560:	5e cf       	rjmp	.-324    	; 0x41e <prvRegisterCheck1>

00000562 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     562:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     564:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     566:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     568:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     56a:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     56c:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     56e:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     570:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     572:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     574:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     576:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     578:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     57a:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     57c:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     57e:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     580:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     582:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     584:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     586:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     588:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     58a:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     58c:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     58e:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     590:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     592:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     594:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     596:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     598:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     59a:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     59c:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     59e:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     5a0:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     5a2:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     5a4:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     5a6:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     5a8:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     5aa:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     5ac:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     5ae:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     5b0:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     5b2:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     5b4:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     5b6:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     5b8:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     5ba:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     5bc:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     5be:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     5c0:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	2"			);
     5c4:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     5c6:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     5c8:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	3"			);
     5cc:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     5ce:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     5d0:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	4"			);
     5d4:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     5d6:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     5d8:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	5"			);
     5dc:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     5de:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     5e0:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     5e4:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     5e6:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     5e8:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     5ec:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     5ee:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     5f0:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     5f6:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     5f8:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     5fc:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     5fe:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     600:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     604:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     606:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     608:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     60c:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     60e:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     610:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     614:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     616:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     618:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     61c:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     61e:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     620:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     624:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     626:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     628:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     62c:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     62e:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     630:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     634:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     636:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     638:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     63c:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     63e:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     640:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     644:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     646:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     648:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     64c:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     64e:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     650:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     654:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     656:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     658:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     65c:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     65e:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     660:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     664:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     666:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     668:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     66c:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     66e:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     670:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     674:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     676:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     678:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     67c:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     67e:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     680:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     684:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     686:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     688:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     68c:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     68e:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     690:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     694:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     696:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     698:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     69c:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     69e:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     6a0:	00 92 80 01 	sts	0x0180, r0	; 0x800180 <xRegTestError>
     6a4:	5e cf       	rjmp	.-324    	; 0x562 <prvRegisterCheck2>

000006a6 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     6a6:	ef 92       	push	r14
     6a8:	ff 92       	push	r15
     6aa:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     6ac:	e1 2c       	mov	r14, r1
     6ae:	f1 2c       	mov	r15, r1
     6b0:	00 e0       	ldi	r16, 0x00	; 0
     6b2:	20 e0       	ldi	r18, 0x00	; 0
     6b4:	30 e0       	ldi	r19, 0x00	; 0
     6b6:	45 e5       	ldi	r20, 0x55	; 85
     6b8:	50 e0       	ldi	r21, 0x00	; 0
     6ba:	63 e3       	ldi	r22, 0x33	; 51
     6bc:	71 e0       	ldi	r23, 0x01	; 1
     6be:	8f e0       	ldi	r24, 0x0F	; 15
     6c0:	92 e0       	ldi	r25, 0x02	; 2
     6c2:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     6c6:	20 e0       	ldi	r18, 0x00	; 0
     6c8:	30 e0       	ldi	r19, 0x00	; 0
     6ca:	45 e5       	ldi	r20, 0x55	; 85
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	68 e3       	ldi	r22, 0x38	; 56
     6d0:	71 e0       	ldi	r23, 0x01	; 1
     6d2:	81 eb       	ldi	r24, 0xB1	; 177
     6d4:	92 e0       	ldi	r25, 0x02	; 2
     6d6:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
}
     6da:	0f 91       	pop	r16
     6dc:	ff 90       	pop	r15
     6de:	ef 90       	pop	r14
     6e0:	08 95       	ret

000006e2 <xAreRegTestTasksStillRunning>:
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	90 91 80 01 	lds	r25, 0x0180	; 0x800180 <xRegTestError>
     6e8:	91 11       	cpse	r25, r1
     6ea:	80 e0       	ldi	r24, 0x00	; 0
}
     6ec:	08 95       	ret

000006ee <initSPI>:

void initSPI( void );

void initSPI( void )
{
    DDRB |= (1 << PB5) | (1 << PB3) | (1 << PB2); //sck, mosi, ss outputs
     6ee:	84 b1       	in	r24, 0x04	; 4
     6f0:	8c 62       	ori	r24, 0x2C	; 44
     6f2:	84 b9       	out	0x04, r24	; 4
    SPCR |= (1 << SPE) | (1 << MSTR);
     6f4:	8c b5       	in	r24, 0x2c	; 44
     6f6:	80 65       	ori	r24, 0x50	; 80
     6f8:	8c bd       	out	0x2c, r24	; 44
     6fa:	08 95       	ret

000006fc <loopback_tcps>:
}

int32_t loopback_tcps(uint8_t sn, uint8_t* buf, uint16_t port)
{
     6fc:	8f 92       	push	r8
     6fe:	9f 92       	push	r9
     700:	af 92       	push	r10
     702:	bf 92       	push	r11
     704:	cf 92       	push	r12
     706:	df 92       	push	r13
     708:	ef 92       	push	r14
     70a:	ff 92       	push	r15
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	18 2f       	mov	r17, r24
     714:	eb 01       	movw	r28, r22
     716:	7a 01       	movw	r14, r20
    int32_t ret;
    uint16_t size = 0, sentsize = 0;

    switch(getSn_SR(sn))
     718:	84 e0       	ldi	r24, 0x04	; 4
     71a:	18 9f       	mul	r17, r24
     71c:	60 01       	movw	r12, r0
     71e:	11 24       	eor	r1, r1
     720:	8f ef       	ldi	r24, 0xFF	; 255
     722:	c8 1a       	sub	r12, r24
     724:	d8 0a       	sbc	r13, r24
     726:	83 e0       	ldi	r24, 0x03	; 3
     728:	cc 0c       	add	r12, r12
     72a:	dd 1c       	adc	r13, r13
     72c:	8a 95       	dec	r24
     72e:	e1 f7       	brne	.-8      	; 0x728 <loopback_tcps+0x2c>
     730:	b6 01       	movw	r22, r12
     732:	7d 5f       	subi	r23, 0xFD	; 253
     734:	07 2e       	mov	r0, r23
     736:	00 0c       	add	r0, r0
     738:	88 0b       	sbc	r24, r24
     73a:	99 0b       	sbc	r25, r25
     73c:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
     740:	83 31       	cpi	r24, 0x13	; 19
     742:	09 f4       	brne	.+2      	; 0x746 <loopback_tcps+0x4a>
     744:	58 c0       	rjmp	.+176    	; 0x7f6 <loopback_tcps+0xfa>
     746:	20 f4       	brcc	.+8      	; 0x750 <loopback_tcps+0x54>
     748:	88 23       	and	r24, r24
     74a:	09 f4       	brne	.+2      	; 0x74e <loopback_tcps+0x52>
     74c:	5d c0       	rjmp	.+186    	; 0x808 <loopback_tcps+0x10c>
     74e:	73 c0       	rjmp	.+230    	; 0x836 <loopback_tcps+0x13a>
     750:	87 31       	cpi	r24, 0x17	; 23
     752:	39 f0       	breq	.+14     	; 0x762 <loopback_tcps+0x66>
     754:	8c 31       	cpi	r24, 0x1C	; 28
     756:	09 f0       	breq	.+2      	; 0x75a <loopback_tcps+0x5e>
     758:	6e c0       	rjmp	.+220    	; 0x836 <loopback_tcps+0x13a>
                    sentsize += ret; // Don't care SOCKERR_BUSY, because it is zero.
                }
            }
            break;
        case SOCK_CLOSE_WAIT :
            if( (ret = disconnect(sn)) != SOCK_OK) return ret;
     75a:	81 2f       	mov	r24, r17
     75c:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <disconnect>
     760:	4d c0       	rjmp	.+154    	; 0x7fc <loopback_tcps+0x100>
    uint16_t size = 0, sentsize = 0;

    switch(getSn_SR(sn))
    {
        case SOCK_ESTABLISHED:
            if(getSn_IR(sn) & Sn_IR_CON)
     762:	8e ef       	ldi	r24, 0xFE	; 254
     764:	d8 1a       	sub	r13, r24
     766:	0d 2c       	mov	r0, r13
     768:	00 0c       	add	r0, r0
     76a:	ee 08       	sbc	r14, r14
     76c:	ff 08       	sbc	r15, r15
     76e:	c7 01       	movw	r24, r14
     770:	b6 01       	movw	r22, r12
     772:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
     776:	80 ff       	sbrs	r24, 0
     778:	05 c0       	rjmp	.+10     	; 0x784 <loopback_tcps+0x88>
            {
                setSn_IR(sn,Sn_IR_CON);
     77a:	41 e0       	ldi	r20, 0x01	; 1
     77c:	c7 01       	movw	r24, r14
     77e:	b6 01       	movw	r22, r12
     780:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
            }
            if((size = getSn_RX_RSR(sn)) > 0) // Don't need to check SOCKERR_BUSY because it doesn't not occur.
     784:	81 2f       	mov	r24, r17
     786:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <getSn_RX_RSR>
     78a:	00 97       	sbiw	r24, 0x00	; 0
     78c:	09 f4       	brne	.+2      	; 0x790 <loopback_tcps+0x94>
     78e:	53 c0       	rjmp	.+166    	; 0x836 <loopback_tcps+0x13a>
            {
                if(size > DATA_BUF_SIZE) size = DATA_BUF_SIZE; // clips size if larger that data buffer
                ret = recv(sn, buf, size);
     790:	ac 01       	movw	r20, r24
     792:	41 30       	cpi	r20, 0x01	; 1
     794:	84 e0       	ldi	r24, 0x04	; 4
     796:	58 07       	cpc	r21, r24
     798:	10 f0       	brcs	.+4      	; 0x79e <loopback_tcps+0xa2>
     79a:	40 e0       	ldi	r20, 0x00	; 0
     79c:	54 e0       	ldi	r21, 0x04	; 4
     79e:	be 01       	movw	r22, r28
     7a0:	81 2f       	mov	r24, r17
     7a2:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <recv>

                if(ret <= 0) return ret;      // check SOCKERR_BUSY & SOCKERR_XXX. For showing the occurrence of SOCKERR_BUSY.
     7a6:	16 16       	cp	r1, r22
     7a8:	17 06       	cpc	r1, r23
     7aa:	18 06       	cpc	r1, r24
     7ac:	19 06       	cpc	r1, r25
     7ae:	0c f0       	brlt	.+2      	; 0x7b2 <loopback_tcps+0xb6>
     7b0:	46 c0       	rjmp	.+140    	; 0x83e <loopback_tcps+0x142>
                size = (uint16_t) ret;
     7b2:	5b 01       	movw	r10, r22
                sentsize = 0;
     7b4:	81 2c       	mov	r8, r1
     7b6:	91 2c       	mov	r9, r1

                while(size != sentsize)
     7b8:	8a 14       	cp	r8, r10
     7ba:	9b 04       	cpc	r9, r11
     7bc:	e1 f1       	breq	.+120    	; 0x836 <loopback_tcps+0x13a>
                {
                    writeNumChar("First char received: ", *buf, 10);
     7be:	4a e0       	ldi	r20, 0x0A	; 10
     7c0:	68 81       	ld	r22, Y
     7c2:	8d e3       	ldi	r24, 0x3D	; 61
     7c4:	91 e0       	ldi	r25, 0x01	; 1
     7c6:	0e 94 58 04 	call	0x8b0	; 0x8b0 <writeNumChar>
                    ret = send(sn, buf+sentsize, size-sentsize);
     7ca:	a5 01       	movw	r20, r10
     7cc:	48 19       	sub	r20, r8
     7ce:	59 09       	sbc	r21, r9
     7d0:	be 01       	movw	r22, r28
     7d2:	68 0d       	add	r22, r8
     7d4:	79 1d       	adc	r23, r9
     7d6:	81 2f       	mov	r24, r17
     7d8:	0e 94 5a 1a 	call	0x34b4	; 0x34b4 <send>
     7dc:	6b 01       	movw	r12, r22
     7de:	7c 01       	movw	r14, r24
                    if(ret < 0)
     7e0:	97 ff       	sbrs	r25, 7
     7e2:	06 c0       	rjmp	.+12     	; 0x7f0 <loopback_tcps+0xf4>
                    {
                        close(sn);
     7e4:	81 2f       	mov	r24, r17
     7e6:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
                sentsize = 0;

                while(size != sentsize)
                {
                    writeNumChar("First char received: ", *buf, 10);
                    ret = send(sn, buf+sentsize, size-sentsize);
     7ea:	c7 01       	movw	r24, r14
     7ec:	b6 01       	movw	r22, r12
                    if(ret < 0)
                    {
                        close(sn);
                        return ret;
     7ee:	27 c0       	rjmp	.+78     	; 0x83e <loopback_tcps+0x142>
                    }
                    sentsize += ret; // Don't care SOCKERR_BUSY, because it is zero.
     7f0:	86 0e       	add	r8, r22
     7f2:	97 1e       	adc	r9, r23
     7f4:	e1 cf       	rjmp	.-62     	; 0x7b8 <loopback_tcps+0xbc>
            break;
        case SOCK_CLOSE_WAIT :
            if( (ret = disconnect(sn)) != SOCK_OK) return ret;
            break;
        case SOCK_INIT :
            if( (ret = listen(sn)) != SOCK_OK) return ret;
     7f6:	81 2f       	mov	r24, r17
     7f8:	0e 94 9f 18 	call	0x313e	; 0x313e <listen>
     7fc:	68 2f       	mov	r22, r24
     7fe:	88 0f       	add	r24, r24
     800:	77 0b       	sbc	r23, r23
     802:	88 0b       	sbc	r24, r24
     804:	99 0b       	sbc	r25, r25
     806:	1b c0       	rjmp	.+54     	; 0x83e <loopback_tcps+0x142>
            break;
        case SOCK_CLOSED:
            if( (ret = socket(sn, Sn_MR_TCP, port, 0x00)) != sn) return ret;
     808:	20 e0       	ldi	r18, 0x00	; 0
     80a:	a7 01       	movw	r20, r14
     80c:	61 e0       	ldi	r22, 0x01	; 1
     80e:	81 2f       	mov	r24, r17
     810:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <socket>
     814:	08 2e       	mov	r0, r24
     816:	00 0c       	add	r0, r0
     818:	99 0b       	sbc	r25, r25
     81a:	aa 0b       	sbc	r26, r26
     81c:	bb 0b       	sbc	r27, r27
     81e:	c1 2e       	mov	r12, r17
     820:	d1 2c       	mov	r13, r1
     822:	e1 2c       	mov	r14, r1
     824:	f1 2c       	mov	r15, r1
     826:	8c 15       	cp	r24, r12
     828:	9d 05       	cpc	r25, r13
     82a:	ae 05       	cpc	r26, r14
     82c:	bf 05       	cpc	r27, r15
     82e:	19 f0       	breq	.+6      	; 0x836 <loopback_tcps+0x13a>
     830:	bc 01       	movw	r22, r24
     832:	cd 01       	movw	r24, r26
     834:	04 c0       	rjmp	.+8      	; 0x83e <loopback_tcps+0x142>
        default:
            break;
    }
    return 1;
     836:	61 e0       	ldi	r22, 0x01	; 1
     838:	70 e0       	ldi	r23, 0x00	; 0
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	90 e0       	ldi	r25, 0x00	; 0
}
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	ff 90       	pop	r15
     846:	ef 90       	pop	r14
     848:	df 90       	pop	r13
     84a:	cf 90       	pop	r12
     84c:	bf 90       	pop	r11
     84e:	af 90       	pop	r10
     850:	9f 90       	pop	r9
     852:	8f 90       	pop	r8
     854:	08 95       	ret

00000856 <initUART>:

/*! \brief Configures baud rate (refer datasheet) */
void initUART(void)
{
    // Not necessary; initialize anyway
    DDRD |= _BV(PD1);
     856:	51 9a       	sbi	0x0a, 1	; 10
    DDRD &= ~_BV(PD0);
     858:	50 98       	cbi	0x0a, 0	; 10

    // Set baud rate; lower byte and top nibble
    UBRR0H = ((_UBRR) & 0xF00);
     85a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    UBRR0L = (uint8_t) ((_UBRR) & 0xFF);
     85e:	87 e6       	ldi	r24, 0x67	; 103
     860:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

    TX_START();
     864:	e1 ec       	ldi	r30, 0xC1	; 193
     866:	f0 e0       	ldi	r31, 0x00	; 0
     868:	80 81       	ld	r24, Z
     86a:	88 60       	ori	r24, 0x08	; 8
     86c:	80 83       	st	Z, r24
    RX_START();
     86e:	80 81       	ld	r24, Z
     870:	80 61       	ori	r24, 0x10	; 16
     872:	80 83       	st	Z, r24

    // Set frame format = 8-N-1
    UCSR0C = (_DATA << UCSZ00);
     874:	86 e0       	ldi	r24, 0x06	; 6
     876:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     87a:	08 95       	ret

0000087c <getByte>:
 * 	Returns 0 on empty buffer
 */
uint8_t getByte(void)
{
    // Check to see if something was received
    while (!(UCSR0A & _BV(RXC0)));
     87c:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     880:	87 ff       	sbrs	r24, 7
     882:	fc cf       	rjmp	.-8      	; 0x87c <getByte>
    return (uint8_t) UDR0;
     884:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
     888:	08 95       	ret

0000088a <putByte>:
 * 	Blocks the serial port while TX completes
 */
void putByte(unsigned char data)
{
    // Stay here until data buffer is empty
    while (!(UCSR0A & _BV(UDRE0)));
     88a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     88e:	95 ff       	sbrs	r25, 5
     890:	fc cf       	rjmp	.-8      	; 0x88a <putByte>
    UDR0 = (unsigned char) data;
     892:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     896:	08 95       	ret

00000898 <writeString>:
}

/*! \brief Writes an ASCII string to the TX buffer */
void writeString(char *str)
{
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	ec 01       	movw	r28, r24
    while (*str != '\0')
     89e:	89 91       	ld	r24, Y+
     8a0:	88 23       	and	r24, r24
     8a2:	19 f0       	breq	.+6      	; 0x8aa <writeString+0x12>
    {
        putByte(*str);
     8a4:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
     8a8:	fa cf       	rjmp	.-12     	; 0x89e <writeString+0x6>
        ++str;
    }
}
     8aa:	df 91       	pop	r29
     8ac:	cf 91       	pop	r28
     8ae:	08 95       	ret

000008b0 <writeNumChar>:

//Convert unsigned 8-bit num to str with given base
void writeNumChar(char* id, uint8_t num, uint8_t base)
{
     8b0:	0f 93       	push	r16
     8b2:	1f 93       	push	r17
     8b4:	cf 93       	push	r28
     8b6:	df 93       	push	r29
     8b8:	cd b7       	in	r28, 0x3d	; 61
     8ba:	de b7       	in	r29, 0x3e	; 62
     8bc:	2a 97       	sbiw	r28, 0x0a	; 10
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	f8 94       	cli
     8c2:	de bf       	out	0x3e, r29	; 62
     8c4:	0f be       	out	0x3f, r0	; 63
     8c6:	cd bf       	out	0x3d, r28	; 61
     8c8:	8c 01       	movw	r16, r24
     8ca:	86 2f       	mov	r24, r22
extern __inline__ __ATTR_GNU_INLINE__
char *itoa (int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__itoa (int, char *, int);
	return __itoa (__val, __s, __radix);
     8cc:	50 e0       	ldi	r21, 0x00	; 0
     8ce:	be 01       	movw	r22, r28
     8d0:	6f 5f       	subi	r22, 0xFF	; 255
     8d2:	7f 4f       	sbci	r23, 0xFF	; 255
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	0e 94 55 2a 	call	0x54aa	; 0x54aa <itoa>
    uint8_t i = 0;
    char str[10];
    itoa(num, str, base);

    if(id)
     8da:	01 15       	cp	r16, r1
     8dc:	11 05       	cpc	r17, r1
     8de:	19 f0       	breq	.+6      	; 0x8e6 <writeNumChar+0x36>
    {
        writeString(id);
     8e0:	c8 01       	movw	r24, r16
     8e2:	0e 94 4c 04 	call	0x898	; 0x898 <writeString>
    }
}

//Convert unsigned 8-bit num to str with given base
void writeNumChar(char* id, uint8_t num, uint8_t base)
{
     8e6:	10 e0       	ldi	r17, 0x00	; 0
    if(id)
    {
        writeString(id);
    }

    while (str[i] != '\0')
     8e8:	e1 e0       	ldi	r30, 0x01	; 1
     8ea:	f0 e0       	ldi	r31, 0x00	; 0
     8ec:	ec 0f       	add	r30, r28
     8ee:	fd 1f       	adc	r31, r29
     8f0:	e1 0f       	add	r30, r17
     8f2:	f1 1d       	adc	r31, r1
     8f4:	80 81       	ld	r24, Z
     8f6:	88 23       	and	r24, r24
     8f8:	21 f0       	breq	.+8      	; 0x902 <__stack+0x3>
    {
        putByte(str[i]);
     8fa:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
        ++i;
     8fe:	1f 5f       	subi	r17, 0xFF	; 255
     900:	f3 cf       	rjmp	.-26     	; 0x8e8 <writeNumChar+0x38>
    }
    putByte('\r');
     902:	8d e0       	ldi	r24, 0x0D	; 13
     904:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
    putByte('\n');
     908:	8a e0       	ldi	r24, 0x0A	; 10
     90a:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
}
     90e:	2a 96       	adiw	r28, 0x0a	; 10
     910:	0f b6       	in	r0, 0x3f	; 63
     912:	f8 94       	cli
     914:	de bf       	out	0x3e, r29	; 62
     916:	0f be       	out	0x3f, r0	; 63
     918:	cd bf       	out	0x3d, r28	; 61
     91a:	df 91       	pop	r29
     91c:	cf 91       	pop	r28
     91e:	1f 91       	pop	r17
     920:	0f 91       	pop	r16
     922:	08 95       	ret

00000924 <writeNumShort>:

//Convert unsigned 16-bit num to str with given base
void writeNumShort(char* id, uint16_t num, uint8_t base)
{
     924:	0f 93       	push	r16
     926:	1f 93       	push	r17
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	cd b7       	in	r28, 0x3d	; 61
     92e:	de b7       	in	r29, 0x3e	; 62
     930:	2a 97       	sbiw	r28, 0x0a	; 10
     932:	0f b6       	in	r0, 0x3f	; 63
     934:	f8 94       	cli
     936:	de bf       	out	0x3e, r29	; 62
     938:	0f be       	out	0x3f, r0	; 63
     93a:	cd bf       	out	0x3d, r28	; 61
     93c:	8c 01       	movw	r16, r24
     93e:	cb 01       	movw	r24, r22
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	be 01       	movw	r22, r28
     944:	6f 5f       	subi	r22, 0xFF	; 255
     946:	7f 4f       	sbci	r23, 0xFF	; 255
     948:	0e 94 55 2a 	call	0x54aa	; 0x54aa <itoa>
    uint8_t i = 0;
    char str[10];
    itoa(num, str, base);

    if(id)
     94c:	01 15       	cp	r16, r1
     94e:	11 05       	cpc	r17, r1
     950:	19 f0       	breq	.+6      	; 0x958 <writeNumShort+0x34>
    {
        writeString(id);
     952:	c8 01       	movw	r24, r16
     954:	0e 94 4c 04 	call	0x898	; 0x898 <writeString>
    putByte('\n');
}

//Convert unsigned 16-bit num to str with given base
void writeNumShort(char* id, uint16_t num, uint8_t base)
{
     958:	10 e0       	ldi	r17, 0x00	; 0
    if(id)
    {
        writeString(id);
    }

    while (str[i] != '\0')
     95a:	e1 e0       	ldi	r30, 0x01	; 1
     95c:	f0 e0       	ldi	r31, 0x00	; 0
     95e:	ec 0f       	add	r30, r28
     960:	fd 1f       	adc	r31, r29
     962:	e1 0f       	add	r30, r17
     964:	f1 1d       	adc	r31, r1
     966:	80 81       	ld	r24, Z
     968:	88 23       	and	r24, r24
     96a:	21 f0       	breq	.+8      	; 0x974 <writeNumShort+0x50>
    {
        putByte(str[i]);
     96c:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
        ++i;
     970:	1f 5f       	subi	r17, 0xFF	; 255
     972:	f3 cf       	rjmp	.-26     	; 0x95a <writeNumShort+0x36>
    }
    putByte('\r');
     974:	8d e0       	ldi	r24, 0x0D	; 13
     976:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
    putByte('\n');
     97a:	8a e0       	ldi	r24, 0x0A	; 10
     97c:	0e 94 45 04 	call	0x88a	; 0x88a <putByte>
}
     980:	2a 96       	adiw	r28, 0x0a	; 10
     982:	0f b6       	in	r0, 0x3f	; 63
     984:	f8 94       	cli
     986:	de bf       	out	0x3e, r29	; 62
     988:	0f be       	out	0x3f, r0	; 63
     98a:	cd bf       	out	0x3d, r28	; 61
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	1f 91       	pop	r17
     992:	0f 91       	pop	r16
     994:	08 95       	ret

00000996 <readString>:

const char* readString(void)
{
     996:	cf 93       	push	r28
     998:	df 93       	push	r29
    static char rxstr[RX_BUFF];
    static char* temp;
    temp = rxstr;
     99a:	81 e8       	ldi	r24, 0x81	; 129
     99c:	91 e0       	ldi	r25, 0x01	; 1
     99e:	90 93 8c 01 	sts	0x018C, r25	; 0x80018c <temp.1823+0x1>
     9a2:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <temp.1823>

    while((*temp = getByte()) != '\n')
     9a6:	c0 91 8b 01 	lds	r28, 0x018B	; 0x80018b <temp.1823>
     9aa:	d0 91 8c 01 	lds	r29, 0x018C	; 0x80018c <temp.1823+0x1>
     9ae:	0e 94 3e 04 	call	0x87c	; 0x87c <getByte>
     9b2:	88 83       	st	Y, r24
     9b4:	8a 30       	cpi	r24, 0x0A	; 10
     9b6:	31 f0       	breq	.+12     	; 0x9c4 <readString+0x2e>
    {
        ++temp;
     9b8:	21 96       	adiw	r28, 0x01	; 1
     9ba:	d0 93 8c 01 	sts	0x018C, r29	; 0x80018c <temp.1823+0x1>
     9be:	c0 93 8b 01 	sts	0x018B, r28	; 0x80018b <temp.1823>
     9c2:	f1 cf       	rjmp	.-30     	; 0x9a6 <readString+0x10>
    }

    return rxstr;
}
     9c4:	81 e8       	ldi	r24, 0x81	; 129
     9c6:	91 e0       	ldi	r25, 0x01	; 1
     9c8:	df 91       	pop	r29
     9ca:	cf 91       	pop	r28
     9cc:	08 95       	ret

000009ce <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     9ce:	e0 91 b2 01 	lds	r30, 0x01B2	; 0x8001b2 <pxDelayedTaskList>
     9d2:	f0 91 b3 01 	lds	r31, 0x01B3	; 0x8001b3 <pxDelayedTaskList+0x1>
     9d6:	80 81       	ld	r24, Z
     9d8:	81 11       	cpse	r24, r1
     9da:	03 c0       	rjmp	.+6      	; 0x9e2 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	9f ef       	ldi	r25, 0xFF	; 255
     9e0:	0c c0       	rjmp	.+24     	; 0x9fa <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     9e2:	e0 91 b2 01 	lds	r30, 0x01B2	; 0x8001b2 <pxDelayedTaskList>
     9e6:	f0 91 b3 01 	lds	r31, 0x01B3	; 0x8001b3 <pxDelayedTaskList+0x1>
     9ea:	05 80       	ldd	r0, Z+5	; 0x05
     9ec:	f6 81       	ldd	r31, Z+6	; 0x06
     9ee:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     9f0:	06 80       	ldd	r0, Z+6	; 0x06
     9f2:	f7 81       	ldd	r31, Z+7	; 0x07
     9f4:	e0 2d       	mov	r30, r0
     9f6:	82 81       	ldd	r24, Z+2	; 0x02
     9f8:	93 81       	ldd	r25, Z+3	; 0x03
     9fa:	90 93 93 01 	sts	0x0193, r25	; 0x800193 <xNextTaskUnblockTime+0x1>
     9fe:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <xNextTaskUnblockTime>
     a02:	08 95       	ret

00000a04 <prvAddCurrentTaskToDelayedList.isra.2>:
		return xIdleTaskHandle->ulRunTimeCounter;
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
     a04:	0f 93       	push	r16
     a06:	1f 93       	push	r17
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
     a0c:	ec 01       	movw	r28, r24
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     a0e:	00 91 9a 01 	lds	r16, 0x019A	; 0x80019a <xTickCount>
     a12:	10 91 9b 01 	lds	r17, 0x019B	; 0x80019b <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     a16:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     a1a:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     a1e:	02 96       	adiw	r24, 0x02	; 2
     a20:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     a24:	c0 0f       	add	r28, r16
     a26:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     a28:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     a2c:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     a30:	d3 83       	std	Z+3, r29	; 0x03
     a32:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a34:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
     a38:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
		xTimeToWake = xConstTickCount + xTicksToWait;

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
     a3c:	c0 17       	cp	r28, r16
     a3e:	d1 07       	cpc	r29, r17
     a40:	60 f4       	brcc	.+24     	; 0xa5a <prvAddCurrentTaskToDelayedList.isra.2+0x56>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a42:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <pxOverflowDelayedTaskList>
     a46:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <pxOverflowDelayedTaskList+0x1>
     a4a:	6e 5f       	subi	r22, 0xFE	; 254
     a4c:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	1f 91       	pop	r17
     a54:	0f 91       	pop	r16
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a56:	0c 94 f3 10 	jmp	0x21e6	; 0x21e6 <vListInsert>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a5a:	80 91 b2 01 	lds	r24, 0x01B2	; 0x8001b2 <pxDelayedTaskList>
     a5e:	90 91 b3 01 	lds	r25, 0x01B3	; 0x8001b3 <pxDelayedTaskList+0x1>
     a62:	6e 5f       	subi	r22, 0xFE	; 254
     a64:	7f 4f       	sbci	r23, 0xFF	; 255
     a66:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     a6a:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <xNextTaskUnblockTime>
     a6e:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <xNextTaskUnblockTime+0x1>
     a72:	c8 17       	cp	r28, r24
     a74:	d9 07       	cpc	r29, r25
     a76:	20 f4       	brcc	.+8      	; 0xa80 <prvAddCurrentTaskToDelayedList.isra.2+0x7c>
			{
				xNextTaskUnblockTime = xTimeToWake;
     a78:	d0 93 93 01 	sts	0x0193, r29	; 0x800193 <xNextTaskUnblockTime+0x1>
     a7c:	c0 93 92 01 	sts	0x0192, r28	; 0x800192 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     a80:	df 91       	pop	r29
     a82:	cf 91       	pop	r28
     a84:	1f 91       	pop	r17
     a86:	0f 91       	pop	r16
     a88:	08 95       	ret

00000a8a <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     a8a:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <uxDeletedTasksWaitingCleanUp>
     a8e:	88 23       	and	r24, r24
     a90:	09 f1       	breq	.+66     	; 0xad4 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     a92:	0f b6       	in	r0, 0x3f	; 63
     a94:	f8 94       	cli
     a96:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a98:	e0 91 a3 01 	lds	r30, 0x01A3	; 0x8001a3 <xTasksWaitingTermination+0x5>
     a9c:	f0 91 a4 01 	lds	r31, 0x01A4	; 0x8001a4 <xTasksWaitingTermination+0x6>
     aa0:	c6 81       	ldd	r28, Z+6	; 0x06
     aa2:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     aa4:	ce 01       	movw	r24, r28
     aa6:	02 96       	adiw	r24, 0x02	; 2
     aa8:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
				--uxCurrentNumberOfTasks;
     aac:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxCurrentNumberOfTasks>
     ab0:	81 50       	subi	r24, 0x01	; 1
     ab2:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     ab6:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <uxDeletedTasksWaitingCleanUp>
     aba:	81 50       	subi	r24, 0x01	; 1
     abc:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     ac0:	0f 90       	pop	r0
     ac2:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     ac4:	8f 89       	ldd	r24, Y+23	; 0x17
     ac6:	98 8d       	ldd	r25, Y+24	; 0x18
     ac8:	0e 94 47 13 	call	0x268e	; 0x268e <vPortFree>
			vPortFree( pxTCB );
     acc:	ce 01       	movw	r24, r28
     ace:	0e 94 47 13 	call	0x268e	; 0x268e <vPortFree>
     ad2:	db cf       	rjmp	.-74     	; 0xa8a <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     ad4:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <pxReadyTasksLists>
     ad8:	82 30       	cpi	r24, 0x02	; 2
     ada:	10 f0       	brcs	.+4      	; 0xae0 <prvIdleTask+0x56>
			{
				taskYIELD();
     adc:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     ae0:	0e 94 af 00 	call	0x15e	; 0x15e <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     ae4:	d2 cf       	rjmp	.-92     	; 0xa8a <prvIdleTask>

00000ae6 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     ae6:	4f 92       	push	r4
     ae8:	5f 92       	push	r5
     aea:	6f 92       	push	r6
     aec:	7f 92       	push	r7
     aee:	8f 92       	push	r8
     af0:	9f 92       	push	r9
     af2:	af 92       	push	r10
     af4:	bf 92       	push	r11
     af6:	cf 92       	push	r12
     af8:	df 92       	push	r13
     afa:	ef 92       	push	r14
     afc:	ff 92       	push	r15
     afe:	0f 93       	push	r16
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
     b04:	4c 01       	movw	r8, r24
     b06:	6b 01       	movw	r12, r22
     b08:	5a 01       	movw	r10, r20
     b0a:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     b0c:	ca 01       	movw	r24, r20
     b0e:	0e 94 15 13 	call	0x262a	; 0x262a <pvPortMalloc>
     b12:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
     b14:	89 2b       	or	r24, r25
     b16:	09 f4       	brne	.+2      	; 0xb1a <xTaskCreate+0x34>
     b18:	d0 c0       	rjmp	.+416    	; 0xcba <xTaskCreate+0x1d4>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     b1a:	86 e2       	ldi	r24, 0x26	; 38
     b1c:	90 e0       	ldi	r25, 0x00	; 0
     b1e:	0e 94 15 13 	call	0x262a	; 0x262a <pvPortMalloc>
     b22:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     b24:	00 97       	sbiw	r24, 0x00	; 0
     b26:	89 f0       	breq	.+34     	; 0xb4a <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     b28:	78 8e       	std	Y+24, r7	; 0x18
     b2a:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     b2c:	21 e0       	ldi	r18, 0x01	; 1
     b2e:	a2 1a       	sub	r10, r18
     b30:	b1 08       	sbc	r11, r1
     b32:	a6 0c       	add	r10, r6
     b34:	b7 1c       	adc	r11, r7
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
     b36:	c1 14       	cp	r12, r1
     b38:	d1 04       	cpc	r13, r1
     b3a:	c9 f0       	breq	.+50     	; 0xb6e <xTaskCreate+0x88>
     b3c:	bc 01       	movw	r22, r24
     b3e:	67 5e       	subi	r22, 0xE7	; 231
     b40:	7f 4f       	sbci	r23, 0xFF	; 255
     b42:	f6 01       	movw	r30, r12
     b44:	c6 01       	movw	r24, r12
     b46:	08 96       	adiw	r24, 0x08	; 8
     b48:	07 c0       	rjmp	.+14     	; 0xb58 <xTaskCreate+0x72>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     b4a:	c3 01       	movw	r24, r6
     b4c:	0e 94 47 13 	call	0x268e	; 0x268e <vPortFree>
     b50:	b4 c0       	rjmp	.+360    	; 0xcba <xTaskCreate+0x1d4>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     b52:	e8 17       	cp	r30, r24
     b54:	f9 07       	cpc	r31, r25
     b56:	49 f0       	breq	.+18     	; 0xb6a <xTaskCreate+0x84>
     b58:	9f 01       	movw	r18, r30
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     b5a:	41 91       	ld	r20, Z+
     b5c:	db 01       	movw	r26, r22
     b5e:	4d 93       	st	X+, r20
     b60:	bd 01       	movw	r22, r26

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
     b62:	d9 01       	movw	r26, r18
     b64:	2c 91       	ld	r18, X
     b66:	21 11       	cpse	r18, r1
     b68:	f4 cf       	rjmp	.-24     	; 0xb52 <xTaskCreate+0x6c>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     b6a:	18 a2       	std	Y+32, r1	; 0x20
     b6c:	01 c0       	rjmp	.+2      	; 0xb70 <xTaskCreate+0x8a>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
     b6e:	19 8e       	std	Y+25, r1	; 0x19
     b70:	04 30       	cpi	r16, 0x04	; 4
     b72:	08 f0       	brcs	.+2      	; 0xb76 <xTaskCreate+0x90>
     b74:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     b76:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     b78:	6e 01       	movw	r12, r28
     b7a:	b2 e0       	ldi	r27, 0x02	; 2
     b7c:	cb 0e       	add	r12, r27
     b7e:	d1 1c       	adc	r13, r1
     b80:	c6 01       	movw	r24, r12
     b82:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     b86:	ce 01       	movw	r24, r28
     b88:	0c 96       	adiw	r24, 0x0c	; 12
     b8a:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     b8e:	d9 87       	std	Y+9, r29	; 0x09
     b90:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b92:	84 e0       	ldi	r24, 0x04	; 4
     b94:	90 e0       	ldi	r25, 0x00	; 0
     b96:	80 1b       	sub	r24, r16
     b98:	91 09       	sbc	r25, r1
     b9a:	9d 87       	std	Y+13, r25	; 0x0d
     b9c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     b9e:	db 8b       	std	Y+19, r29	; 0x13
     ba0:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     ba2:	19 a2       	std	Y+33, r1	; 0x21
     ba4:	1a a2       	std	Y+34, r1	; 0x22
     ba6:	1b a2       	std	Y+35, r1	; 0x23
     ba8:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     baa:	1d a2       	std	Y+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     bac:	a2 01       	movw	r20, r4
     bae:	b4 01       	movw	r22, r8
     bb0:	c5 01       	movw	r24, r10
     bb2:	0e 94 56 13 	call	0x26ac	; 0x26ac <pxPortInitialiseStack>
     bb6:	99 83       	std	Y+1, r25	; 0x01
     bb8:	88 83       	st	Y, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     bba:	e1 14       	cp	r14, r1
     bbc:	f1 04       	cpc	r15, r1
     bbe:	19 f0       	breq	.+6      	; 0xbc6 <xTaskCreate+0xe0>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     bc0:	f7 01       	movw	r30, r14
     bc2:	d1 83       	std	Z+1, r29	; 0x01
     bc4:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     bcc:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxCurrentNumberOfTasks>
     bd0:	8f 5f       	subi	r24, 0xFF	; 255
     bd2:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     bd6:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     bda:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     bde:	89 2b       	or	r24, r25
     be0:	a9 f5       	brne	.+106    	; 0xc4c <xTaskCreate+0x166>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     be2:	d0 93 8e 01 	sts	0x018E, r29	; 0x80018e <pxCurrentTCB+0x1>
     be6:	c0 93 8d 01 	sts	0x018D, r28	; 0x80018d <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     bea:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxCurrentNumberOfTasks>
     bee:	81 30       	cpi	r24, 0x01	; 1
     bf0:	e9 f5       	brne	.+122    	; 0xc6c <xTaskCreate+0x186>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     bf2:	86 ec       	ldi	r24, 0xC6	; 198
     bf4:	91 e0       	ldi	r25, 0x01	; 1
     bf6:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
     bfa:	8f ec       	ldi	r24, 0xCF	; 207
     bfc:	91 e0       	ldi	r25, 0x01	; 1
     bfe:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
     c02:	88 ed       	ldi	r24, 0xD8	; 216
     c04:	91 e0       	ldi	r25, 0x01	; 1
     c06:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
     c0a:	81 ee       	ldi	r24, 0xE1	; 225
     c0c:	91 e0       	ldi	r25, 0x01	; 1
     c0e:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     c12:	8d eb       	ldi	r24, 0xBD	; 189
     c14:	91 e0       	ldi	r25, 0x01	; 1
     c16:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     c1a:	84 eb       	ldi	r24, 0xB4	; 180
     c1c:	91 e0       	ldi	r25, 0x01	; 1
     c1e:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     c22:	87 ea       	ldi	r24, 0xA7	; 167
     c24:	91 e0       	ldi	r25, 0x01	; 1
     c26:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     c2a:	8e e9       	ldi	r24, 0x9E	; 158
     c2c:	91 e0       	ldi	r25, 0x01	; 1
     c2e:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     c32:	8d eb       	ldi	r24, 0xBD	; 189
     c34:	91 e0       	ldi	r25, 0x01	; 1
     c36:	90 93 b3 01 	sts	0x01B3, r25	; 0x8001b3 <pxDelayedTaskList+0x1>
     c3a:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     c3e:	84 eb       	ldi	r24, 0xB4	; 180
     c40:	91 e0       	ldi	r25, 0x01	; 1
     c42:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <pxOverflowDelayedTaskList+0x1>
     c46:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <pxOverflowDelayedTaskList>
     c4a:	10 c0       	rjmp	.+32     	; 0xc6c <xTaskCreate+0x186>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     c4c:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <xSchedulerRunning>
     c50:	81 11       	cpse	r24, r1
     c52:	0c c0       	rjmp	.+24     	; 0xc6c <xTaskCreate+0x186>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     c54:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     c58:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     c5c:	96 89       	ldd	r25, Z+22	; 0x16
     c5e:	8e 89       	ldd	r24, Y+22	; 0x16
     c60:	89 17       	cp	r24, r25
     c62:	20 f0       	brcs	.+8      	; 0xc6c <xTaskCreate+0x186>
				{
					pxCurrentTCB = pxNewTCB;
     c64:	d0 93 8e 01 	sts	0x018E, r29	; 0x80018e <pxCurrentTCB+0x1>
     c68:	c0 93 8d 01 	sts	0x018D, r28	; 0x80018d <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     c6c:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <uxTaskNumber>
     c70:	8f 5f       	subi	r24, 0xFF	; 255
     c72:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     c76:	8e 89       	ldd	r24, Y+22	; 0x16
     c78:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
     c7c:	98 17       	cp	r25, r24
     c7e:	10 f4       	brcc	.+4      	; 0xc84 <xTaskCreate+0x19e>
     c80:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
     c84:	f9 e0       	ldi	r31, 0x09	; 9
     c86:	8f 9f       	mul	r24, r31
     c88:	c0 01       	movw	r24, r0
     c8a:	11 24       	eor	r1, r1
     c8c:	b6 01       	movw	r22, r12
     c8e:	8a 53       	subi	r24, 0x3A	; 58
     c90:	9e 4f       	sbci	r25, 0xFE	; 254
     c92:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     c96:	0f 90       	pop	r0
     c98:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     c9a:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <xSchedulerRunning>
     c9e:	88 23       	and	r24, r24
     ca0:	51 f0       	breq	.+20     	; 0xcb6 <xTaskCreate+0x1d0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     ca2:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     ca6:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     caa:	96 89       	ldd	r25, Z+22	; 0x16
     cac:	8e 89       	ldd	r24, Y+22	; 0x16
     cae:	98 17       	cp	r25, r24
     cb0:	10 f4       	brcc	.+4      	; 0xcb6 <xTaskCreate+0x1d0>
		{
			taskYIELD_IF_USING_PREEMPTION();
     cb2:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	01 c0       	rjmp	.+2      	; 0xcbc <xTaskCreate+0x1d6>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     cba:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	0f 91       	pop	r16
     cc2:	ff 90       	pop	r15
     cc4:	ef 90       	pop	r14
     cc6:	df 90       	pop	r13
     cc8:	cf 90       	pop	r12
     cca:	bf 90       	pop	r11
     ccc:	af 90       	pop	r10
     cce:	9f 90       	pop	r9
     cd0:	8f 90       	pop	r8
     cd2:	7f 90       	pop	r7
     cd4:	6f 90       	pop	r6
     cd6:	5f 90       	pop	r5
     cd8:	4f 90       	pop	r4
     cda:	08 95       	ret

00000cdc <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     cdc:	0f 93       	push	r16
     cde:	1f 93       	push	r17
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
     ce4:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     ce6:	0f b6       	in	r0, 0x3f	; 63
     ce8:	f8 94       	cli
     cea:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     cec:	89 2b       	or	r24, r25
     cee:	21 f4       	brne	.+8      	; 0xcf8 <vTaskDelete+0x1c>
     cf0:	c0 91 8d 01 	lds	r28, 0x018D	; 0x80018d <pxCurrentTCB>
     cf4:	d0 91 8e 01 	lds	r29, 0x018E	; 0x80018e <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     cf8:	8e 01       	movw	r16, r28
     cfa:	0e 5f       	subi	r16, 0xFE	; 254
     cfc:	1f 4f       	sbci	r17, 0xFF	; 255
     cfe:	c8 01       	movw	r24, r16
     d00:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     d04:	8c 89       	ldd	r24, Y+20	; 0x14
     d06:	9d 89       	ldd	r25, Y+21	; 0x15
     d08:	89 2b       	or	r24, r25
     d0a:	21 f0       	breq	.+8      	; 0xd14 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     d0c:	ce 01       	movw	r24, r28
     d0e:	0c 96       	adiw	r24, 0x0c	; 12
     d10:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     d14:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <uxTaskNumber>
     d18:	8f 5f       	subi	r24, 0xFF	; 255
     d1a:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     d1e:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     d22:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d26:	c8 17       	cp	r28, r24
     d28:	d9 07       	cpc	r29, r25
     d2a:	59 f4       	brne	.+22     	; 0xd42 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     d2c:	b8 01       	movw	r22, r16
     d2e:	8e e9       	ldi	r24, 0x9E	; 158
     d30:	91 e0       	ldi	r25, 0x01	; 1
     d32:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     d36:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <uxDeletedTasksWaitingCleanUp>
     d3a:	8f 5f       	subi	r24, 0xFF	; 255
     d3c:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <uxDeletedTasksWaitingCleanUp>
     d40:	0e c0       	rjmp	.+28     	; 0xd5e <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     d42:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxCurrentNumberOfTasks>
     d46:	81 50       	subi	r24, 0x01	; 1
     d48:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     d4c:	8f 89       	ldd	r24, Y+23	; 0x17
     d4e:	98 8d       	ldd	r25, Y+24	; 0x18
     d50:	0e 94 47 13 	call	0x268e	; 0x268e <vPortFree>
			vPortFree( pxTCB );
     d54:	ce 01       	movw	r24, r28
     d56:	0e 94 47 13 	call	0x268e	; 0x268e <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     d5a:	0e 94 e7 04 	call	0x9ce	; 0x9ce <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     d5e:	0f 90       	pop	r0
     d60:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     d62:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <xSchedulerRunning>
     d66:	88 23       	and	r24, r24
     d68:	49 f0       	breq	.+18     	; 0xd7c <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     d6a:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     d6e:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d72:	c8 17       	cp	r28, r24
     d74:	d9 07       	cpc	r29, r25
     d76:	11 f4       	brne	.+4      	; 0xd7c <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     d78:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	08 95       	ret

00000d86 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     d86:	ef 92       	push	r14
     d88:	ff 92       	push	r15
     d8a:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     d8c:	80 e9       	ldi	r24, 0x90	; 144
     d8e:	e8 2e       	mov	r14, r24
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	f8 2e       	mov	r15, r24
     d94:	00 e0       	ldi	r16, 0x00	; 0
     d96:	20 e0       	ldi	r18, 0x00	; 0
     d98:	30 e0       	ldi	r19, 0x00	; 0
     d9a:	45 e5       	ldi	r20, 0x55	; 85
     d9c:	50 e0       	ldi	r21, 0x00	; 0
     d9e:	63 e5       	ldi	r22, 0x53	; 83
     da0:	71 e0       	ldi	r23, 0x01	; 1
     da2:	85 e4       	ldi	r24, 0x45	; 69
     da4:	95 e0       	ldi	r25, 0x05	; 5
     da6:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     daa:	81 30       	cpi	r24, 0x01	; 1
     dac:	91 f4       	brne	.+36     	; 0xdd2 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     dae:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     db0:	2f ef       	ldi	r18, 0xFF	; 255
     db2:	3f ef       	ldi	r19, 0xFF	; 255
     db4:	30 93 93 01 	sts	0x0193, r19	; 0x800193 <xNextTaskUnblockTime+0x1>
     db8:	20 93 92 01 	sts	0x0192, r18	; 0x800192 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     dbc:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     dc0:	10 92 9b 01 	sts	0x019B, r1	; 0x80019b <xTickCount+0x1>
     dc4:	10 92 9a 01 	sts	0x019A, r1	; 0x80019a <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     dc8:	0f 91       	pop	r16
     dca:	ff 90       	pop	r15
     dcc:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     dce:	0c 94 c2 13 	jmp	0x2784	; 0x2784 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     dd2:	0f 91       	pop	r16
     dd4:	ff 90       	pop	r15
     dd6:	ef 90       	pop	r14
     dd8:	08 95       	ret

00000dda <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     dda:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     ddc:	10 92 98 01 	sts	0x0198, r1	; 0x800198 <xSchedulerRunning>
	vPortEndScheduler();
     de0:	0c 94 fd 13 	jmp	0x27fa	; 0x27fa <vPortEndScheduler>

00000de4 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     de4:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
     de8:	8f 5f       	subi	r24, 0xFF	; 255
     dea:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <uxSchedulerSuspended>
     dee:	08 95       	ret

00000df0 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     df0:	0f b6       	in	r0, 0x3f	; 63
     df2:	f8 94       	cli
     df4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     df6:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xTickCount>
     dfa:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     dfe:	0f 90       	pop	r0
     e00:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     e02:	08 95       	ret

00000e04 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     e04:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <xTickCount>
     e08:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e0c:	08 95       	ret

00000e0e <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     e0e:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxCurrentNumberOfTasks>
}
     e12:	08 95       	ret

00000e14 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     e14:	00 97       	sbiw	r24, 0x00	; 0
     e16:	21 f4       	brne	.+8      	; 0xe20 <pcTaskGetName+0xc>
     e18:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     e1c:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     e20:	49 96       	adiw	r24, 0x19	; 25
     e22:	08 95       	ret

00000e24 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     e24:	cf 92       	push	r12
     e26:	df 92       	push	r13
     e28:	ef 92       	push	r14
     e2a:	ff 92       	push	r15
     e2c:	0f 93       	push	r16
     e2e:	1f 93       	push	r17
     e30:	cf 93       	push	r28
     e32:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e34:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
     e38:	81 11       	cpse	r24, r1
     e3a:	8c c0       	rjmp	.+280    	; 0xf54 <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     e3c:	00 91 9a 01 	lds	r16, 0x019A	; 0x80019a <xTickCount>
     e40:	10 91 9b 01 	lds	r17, 0x019B	; 0x80019b <xTickCount+0x1>
     e44:	0f 5f       	subi	r16, 0xFF	; 255
     e46:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     e48:	10 93 9b 01 	sts	0x019B, r17	; 0x80019b <xTickCount+0x1>
     e4c:	00 93 9a 01 	sts	0x019A, r16	; 0x80019a <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     e50:	01 15       	cp	r16, r1
     e52:	11 05       	cpc	r17, r1
     e54:	b9 f4       	brne	.+46     	; 0xe84 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     e56:	80 91 b2 01 	lds	r24, 0x01B2	; 0x8001b2 <pxDelayedTaskList>
     e5a:	90 91 b3 01 	lds	r25, 0x01B3	; 0x8001b3 <pxDelayedTaskList+0x1>
     e5e:	20 91 b0 01 	lds	r18, 0x01B0	; 0x8001b0 <pxOverflowDelayedTaskList>
     e62:	30 91 b1 01 	lds	r19, 0x01B1	; 0x8001b1 <pxOverflowDelayedTaskList+0x1>
     e66:	30 93 b3 01 	sts	0x01B3, r19	; 0x8001b3 <pxDelayedTaskList+0x1>
     e6a:	20 93 b2 01 	sts	0x01B2, r18	; 0x8001b2 <pxDelayedTaskList>
     e6e:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <pxOverflowDelayedTaskList+0x1>
     e72:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <pxOverflowDelayedTaskList>
     e76:	80 91 95 01 	lds	r24, 0x0195	; 0x800195 <xNumOfOverflows>
     e7a:	8f 5f       	subi	r24, 0xFF	; 255
     e7c:	80 93 95 01 	sts	0x0195, r24	; 0x800195 <xNumOfOverflows>
     e80:	0e 94 e7 04 	call	0x9ce	; 0x9ce <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     e84:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <xNextTaskUnblockTime>
     e88:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <xNextTaskUnblockTime+0x1>
     e8c:	c0 e0       	ldi	r28, 0x00	; 0
     e8e:	08 17       	cp	r16, r24
     e90:	19 07       	cpc	r17, r25
     e92:	08 f4       	brcc	.+2      	; 0xe96 <xTaskIncrementTick+0x72>
     e94:	4f c0       	rjmp	.+158    	; 0xf34 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     e96:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     e98:	e0 91 b2 01 	lds	r30, 0x01B2	; 0x8001b2 <pxDelayedTaskList>
     e9c:	f0 91 b3 01 	lds	r31, 0x01B3	; 0x8001b3 <pxDelayedTaskList+0x1>
     ea0:	80 81       	ld	r24, Z
     ea2:	81 11       	cpse	r24, r1
     ea4:	03 c0       	rjmp	.+6      	; 0xeac <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ea6:	8f ef       	ldi	r24, 0xFF	; 255
     ea8:	9f ef       	ldi	r25, 0xFF	; 255
     eaa:	11 c0       	rjmp	.+34     	; 0xece <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     eac:	e0 91 b2 01 	lds	r30, 0x01B2	; 0x8001b2 <pxDelayedTaskList>
     eb0:	f0 91 b3 01 	lds	r31, 0x01B3	; 0x8001b3 <pxDelayedTaskList+0x1>
     eb4:	05 80       	ldd	r0, Z+5	; 0x05
     eb6:	f6 81       	ldd	r31, Z+6	; 0x06
     eb8:	e0 2d       	mov	r30, r0
     eba:	e6 80       	ldd	r14, Z+6	; 0x06
     ebc:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     ebe:	d7 01       	movw	r26, r14
     ec0:	12 96       	adiw	r26, 0x02	; 2
     ec2:	8d 91       	ld	r24, X+
     ec4:	9c 91       	ld	r25, X
     ec6:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     ec8:	08 17       	cp	r16, r24
     eca:	19 07       	cpc	r17, r25
     ecc:	28 f4       	brcc	.+10     	; 0xed8 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     ece:	90 93 93 01 	sts	0x0193, r25	; 0x800193 <xNextTaskUnblockTime+0x1>
     ed2:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     ed6:	2e c0       	rjmp	.+92     	; 0xf34 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     ed8:	67 01       	movw	r12, r14
     eda:	b2 e0       	ldi	r27, 0x02	; 2
     edc:	cb 0e       	add	r12, r27
     ede:	d1 1c       	adc	r13, r1
     ee0:	c6 01       	movw	r24, r12
     ee2:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     ee6:	f7 01       	movw	r30, r14
     ee8:	84 89       	ldd	r24, Z+20	; 0x14
     eea:	95 89       	ldd	r25, Z+21	; 0x15
     eec:	89 2b       	or	r24, r25
     eee:	21 f0       	breq	.+8      	; 0xef8 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ef0:	c7 01       	movw	r24, r14
     ef2:	0c 96       	adiw	r24, 0x0c	; 12
     ef4:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     ef8:	d7 01       	movw	r26, r14
     efa:	56 96       	adiw	r26, 0x16	; 22
     efc:	8c 91       	ld	r24, X
     efe:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
     f02:	98 17       	cp	r25, r24
     f04:	10 f4       	brcc	.+4      	; 0xf0a <xTaskIncrementTick+0xe6>
     f06:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
     f0a:	d8 9f       	mul	r29, r24
     f0c:	c0 01       	movw	r24, r0
     f0e:	11 24       	eor	r1, r1
     f10:	b6 01       	movw	r22, r12
     f12:	8a 53       	subi	r24, 0x3A	; 58
     f14:	9e 4f       	sbci	r25, 0xFE	; 254
     f16:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     f1a:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     f1e:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     f22:	d7 01       	movw	r26, r14
     f24:	56 96       	adiw	r26, 0x16	; 22
     f26:	9c 91       	ld	r25, X
     f28:	86 89       	ldd	r24, Z+22	; 0x16
     f2a:	98 17       	cp	r25, r24
     f2c:	08 f4       	brcc	.+2      	; 0xf30 <xTaskIncrementTick+0x10c>
     f2e:	b4 cf       	rjmp	.-152    	; 0xe98 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     f30:	c1 e0       	ldi	r28, 0x01	; 1
     f32:	b2 cf       	rjmp	.-156    	; 0xe98 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     f34:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     f38:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     f3c:	e6 89       	ldd	r30, Z+22	; 0x16
     f3e:	b9 e0       	ldi	r27, 0x09	; 9
     f40:	eb 9f       	mul	r30, r27
     f42:	f0 01       	movw	r30, r0
     f44:	11 24       	eor	r1, r1
     f46:	ea 53       	subi	r30, 0x3A	; 58
     f48:	fe 4f       	sbci	r31, 0xFE	; 254
     f4a:	80 81       	ld	r24, Z
     f4c:	82 30       	cpi	r24, 0x02	; 2
     f4e:	40 f0       	brcs	.+16     	; 0xf60 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     f50:	c1 e0       	ldi	r28, 0x01	; 1
     f52:	06 c0       	rjmp	.+12     	; 0xf60 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     f54:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <uxPendedTicks>
     f58:	8f 5f       	subi	r24, 0xFF	; 255
     f5a:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     f5e:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     f60:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <xYieldPending>
     f64:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     f66:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     f68:	8c 2f       	mov	r24, r28
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	1f 91       	pop	r17
     f70:	0f 91       	pop	r16
     f72:	ff 90       	pop	r15
     f74:	ef 90       	pop	r14
     f76:	df 90       	pop	r13
     f78:	cf 90       	pop	r12
     f7a:	08 95       	ret

00000f7c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     f7c:	ef 92       	push	r14
     f7e:	ff 92       	push	r15
     f80:	0f 93       	push	r16
     f82:	1f 93       	push	r17
     f84:	cf 93       	push	r28
     f86:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     f8e:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
     f92:	81 50       	subi	r24, 0x01	; 1
     f94:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     f98:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
     f9c:	88 23       	and	r24, r24
     f9e:	11 f0       	breq	.+4      	; 0xfa4 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	52 c0       	rjmp	.+164    	; 0x1048 <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     fa4:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <uxCurrentNumberOfTasks>
     fa8:	88 23       	and	r24, r24
     faa:	d1 f3       	breq	.-12     	; 0xfa0 <xTaskResumeAll+0x24>
     fac:	c0 e0       	ldi	r28, 0x00	; 0
     fae:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     fb0:	89 e0       	ldi	r24, 0x09	; 9
     fb2:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     fb4:	ee 24       	eor	r14, r14
     fb6:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     fb8:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <xPendingReadyList>
     fbc:	88 23       	and	r24, r24
     fbe:	51 f1       	breq	.+84     	; 0x1014 <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     fc0:	e0 91 ac 01 	lds	r30, 0x01AC	; 0x8001ac <xPendingReadyList+0x5>
     fc4:	f0 91 ad 01 	lds	r31, 0x01AD	; 0x8001ad <xPendingReadyList+0x6>
     fc8:	c6 81       	ldd	r28, Z+6	; 0x06
     fca:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     fcc:	ce 01       	movw	r24, r28
     fce:	0c 96       	adiw	r24, 0x0c	; 12
     fd0:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     fd4:	8e 01       	movw	r16, r28
     fd6:	0e 5f       	subi	r16, 0xFE	; 254
     fd8:	1f 4f       	sbci	r17, 0xFF	; 255
     fda:	c8 01       	movw	r24, r16
     fdc:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     fe0:	8e 89       	ldd	r24, Y+22	; 0x16
     fe2:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
     fe6:	98 17       	cp	r25, r24
     fe8:	10 f4       	brcc	.+4      	; 0xfee <xTaskResumeAll+0x72>
     fea:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
     fee:	f8 9e       	mul	r15, r24
     ff0:	c0 01       	movw	r24, r0
     ff2:	11 24       	eor	r1, r1
     ff4:	b8 01       	movw	r22, r16
     ff6:	8a 53       	subi	r24, 0x3A	; 58
     ff8:	9e 4f       	sbci	r25, 0xFE	; 254
     ffa:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ffe:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1002:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1006:	9e 89       	ldd	r25, Y+22	; 0x16
    1008:	86 89       	ldd	r24, Z+22	; 0x16
    100a:	98 17       	cp	r25, r24
    100c:	a8 f2       	brcs	.-86     	; 0xfb8 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
    100e:	e0 92 96 01 	sts	0x0196, r14	; 0x800196 <xYieldPending>
    1012:	d2 cf       	rjmp	.-92     	; 0xfb8 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1014:	cd 2b       	or	r28, r29
    1016:	11 f0       	breq	.+4      	; 0x101c <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1018:	0e 94 e7 04 	call	0x9ce	; 0x9ce <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    101c:	c0 91 97 01 	lds	r28, 0x0197	; 0x800197 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1020:	cc 23       	and	r28, r28
    1022:	51 f0       	breq	.+20     	; 0x1038 <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    1024:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1026:	0e 94 12 07 	call	0xe24	; 0xe24 <xTaskIncrementTick>
    102a:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
    102c:	d0 93 96 01 	sts	0x0196, r29	; 0x800196 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1030:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1032:	c9 f7       	brne	.-14     	; 0x1026 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    1034:	10 92 97 01 	sts	0x0197, r1	; 0x800197 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1038:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <xYieldPending>
    103c:	88 23       	and	r24, r24
    103e:	09 f4       	brne	.+2      	; 0x1042 <xTaskResumeAll+0xc6>
    1040:	af cf       	rjmp	.-162    	; 0xfa0 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1042:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1046:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1048:	0f 90       	pop	r0
    104a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    104c:	df 91       	pop	r29
    104e:	cf 91       	pop	r28
    1050:	1f 91       	pop	r17
    1052:	0f 91       	pop	r16
    1054:	ff 90       	pop	r15
    1056:	ef 90       	pop	r14
    1058:	08 95       	ret

0000105a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    105a:	0f 93       	push	r16
    105c:	1f 93       	push	r17
    105e:	cf 93       	push	r28
    1060:	df 93       	push	r29
    1062:	8c 01       	movw	r16, r24
    1064:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1066:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    106a:	40 91 9a 01 	lds	r20, 0x019A	; 0x80019a <xTickCount>
    106e:	50 91 9b 01 	lds	r21, 0x019B	; 0x80019b <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1072:	f8 01       	movw	r30, r16
    1074:	20 81       	ld	r18, Z
    1076:	31 81       	ldd	r19, Z+1	; 0x01
    1078:	c9 01       	movw	r24, r18
    107a:	8c 0f       	add	r24, r28
    107c:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    107e:	42 17       	cp	r20, r18
    1080:	53 07       	cpc	r21, r19
    1082:	20 f4       	brcc	.+8      	; 0x108c <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1084:	82 17       	cp	r24, r18
    1086:	93 07       	cpc	r25, r19
    1088:	40 f4       	brcc	.+16     	; 0x109a <vTaskDelayUntil+0x40>
    108a:	03 c0       	rjmp	.+6      	; 0x1092 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    108c:	82 17       	cp	r24, r18
    108e:	93 07       	cpc	r25, r19
    1090:	30 f0       	brcs	.+12     	; 0x109e <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1092:	21 e0       	ldi	r18, 0x01	; 1
    1094:	48 17       	cp	r20, r24
    1096:	59 07       	cpc	r21, r25
    1098:	18 f0       	brcs	.+6      	; 0x10a0 <vTaskDelayUntil+0x46>
    109a:	20 e0       	ldi	r18, 0x00	; 0
    109c:	01 c0       	rjmp	.+2      	; 0x10a0 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    109e:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    10a0:	f8 01       	movw	r30, r16
    10a2:	91 83       	std	Z+1, r25	; 0x01
    10a4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    10a6:	22 23       	and	r18, r18
    10a8:	21 f0       	breq	.+8      	; 0x10b2 <vTaskDelayUntil+0x58>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    10aa:	84 1b       	sub	r24, r20
    10ac:	95 0b       	sbc	r25, r21
    10ae:	0e 94 02 05 	call	0xa04	; 0xa04 <prvAddCurrentTaskToDelayedList.isra.2>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    10b2:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    10b6:	81 11       	cpse	r24, r1
    10b8:	02 c0       	rjmp	.+4      	; 0x10be <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
    10ba:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
    10c2:	1f 91       	pop	r17
    10c4:	0f 91       	pop	r16
    10c6:	08 95       	ret

000010c8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    10ce:	89 2b       	or	r24, r25
    10d0:	19 f4       	brne	.+6      	; 0x10d8 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    10d2:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    10d6:	09 c0       	rjmp	.+18     	; 0x10ea <vTaskDelay+0x22>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    10d8:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    10dc:	ce 01       	movw	r24, r28
    10de:	0e 94 02 05 	call	0xa04	; 0xa04 <prvAddCurrentTaskToDelayedList.isra.2>
			}
			xAlreadyYielded = xTaskResumeAll();
    10e2:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    10e6:	88 23       	and	r24, r24
    10e8:	a1 f3       	breq	.-24     	; 0x10d2 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    10ea:	df 91       	pop	r29
    10ec:	cf 91       	pop	r28
    10ee:	08 95       	ret

000010f0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    10f0:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
    10f4:	88 23       	and	r24, r24
    10f6:	21 f0       	breq	.+8      	; 0x1100 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    10f8:	81 e0       	ldi	r24, 0x01	; 1
    10fa:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xYieldPending>
    10fe:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1100:	10 92 96 01 	sts	0x0196, r1	; 0x800196 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1104:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <uxTopReadyPriority>
    1108:	69 e0       	ldi	r22, 0x09	; 9
    110a:	48 2f       	mov	r20, r24
    110c:	50 e0       	ldi	r21, 0x00	; 0
    110e:	64 9f       	mul	r22, r20
    1110:	90 01       	movw	r18, r0
    1112:	65 9f       	mul	r22, r21
    1114:	30 0d       	add	r19, r0
    1116:	11 24       	eor	r1, r1
    1118:	f9 01       	movw	r30, r18
    111a:	ea 53       	subi	r30, 0x3A	; 58
    111c:	fe 4f       	sbci	r31, 0xFE	; 254
    111e:	90 81       	ld	r25, Z
    1120:	91 11       	cpse	r25, r1
    1122:	02 c0       	rjmp	.+4      	; 0x1128 <vTaskSwitchContext+0x38>
    1124:	81 50       	subi	r24, 0x01	; 1
    1126:	f1 cf       	rjmp	.-30     	; 0x110a <vTaskSwitchContext+0x1a>
    1128:	a1 81       	ldd	r26, Z+1	; 0x01
    112a:	b2 81       	ldd	r27, Z+2	; 0x02
    112c:	12 96       	adiw	r26, 0x02	; 2
    112e:	0d 90       	ld	r0, X+
    1130:	bc 91       	ld	r27, X
    1132:	a0 2d       	mov	r26, r0
    1134:	b2 83       	std	Z+2, r27	; 0x02
    1136:	a1 83       	std	Z+1, r26	; 0x01
    1138:	27 53       	subi	r18, 0x37	; 55
    113a:	3e 4f       	sbci	r19, 0xFE	; 254
    113c:	a2 17       	cp	r26, r18
    113e:	b3 07       	cpc	r27, r19
    1140:	31 f4       	brne	.+12     	; 0x114e <vTaskSwitchContext+0x5e>
    1142:	12 96       	adiw	r26, 0x02	; 2
    1144:	2d 91       	ld	r18, X+
    1146:	3c 91       	ld	r19, X
    1148:	13 97       	sbiw	r26, 0x03	; 3
    114a:	32 83       	std	Z+2, r19	; 0x02
    114c:	21 83       	std	Z+1, r18	; 0x01
    114e:	99 e0       	ldi	r25, 0x09	; 9
    1150:	94 9f       	mul	r25, r20
    1152:	f0 01       	movw	r30, r0
    1154:	95 9f       	mul	r25, r21
    1156:	f0 0d       	add	r31, r0
    1158:	11 24       	eor	r1, r1
    115a:	ea 53       	subi	r30, 0x3A	; 58
    115c:	fe 4f       	sbci	r31, 0xFE	; 254
    115e:	01 80       	ldd	r0, Z+1	; 0x01
    1160:	f2 81       	ldd	r31, Z+2	; 0x02
    1162:	e0 2d       	mov	r30, r0
    1164:	26 81       	ldd	r18, Z+6	; 0x06
    1166:	37 81       	ldd	r19, Z+7	; 0x07
    1168:	30 93 8e 01 	sts	0x018E, r19	; 0x80018e <pxCurrentTCB+0x1>
    116c:	20 93 8d 01 	sts	0x018D, r18	; 0x80018d <pxCurrentTCB>
    1170:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
    1174:	08 95       	ret

00001176 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1176:	cf 93       	push	r28
    1178:	df 93       	push	r29
    117a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    117c:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
    1180:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1184:	64 5f       	subi	r22, 0xF4	; 244
    1186:	7f 4f       	sbci	r23, 0xFF	; 255
    1188:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    118c:	ce 01       	movw	r24, r28
}
    118e:	df 91       	pop	r29
    1190:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1192:	0c 94 02 05 	jmp	0xa04	; 0xa04 <prvAddCurrentTaskToDelayedList.isra.2>

00001196 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1196:	cf 93       	push	r28
    1198:	df 93       	push	r29
    119a:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    119c:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    11a0:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    11a4:	70 68       	ori	r23, 0x80	; 128
    11a6:	75 87       	std	Z+13, r23	; 0x0d
    11a8:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    11aa:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
    11ae:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    11b2:	64 5f       	subi	r22, 0xF4	; 244
    11b4:	7f 4f       	sbci	r23, 0xFF	; 255
    11b6:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    11ba:	ce 01       	movw	r24, r28
}
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    11c0:	0c 94 02 05 	jmp	0xa04	; 0xa04 <prvAddCurrentTaskToDelayedList.isra.2>

000011c4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    11c4:	0f 93       	push	r16
    11c6:	1f 93       	push	r17
    11c8:	cf 93       	push	r28
    11ca:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    11cc:	dc 01       	movw	r26, r24
    11ce:	15 96       	adiw	r26, 0x05	; 5
    11d0:	ed 91       	ld	r30, X+
    11d2:	fc 91       	ld	r31, X
    11d4:	16 97       	sbiw	r26, 0x06	; 6
    11d6:	c6 81       	ldd	r28, Z+6	; 0x06
    11d8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    11da:	8e 01       	movw	r16, r28
    11dc:	04 5f       	subi	r16, 0xF4	; 244
    11de:	1f 4f       	sbci	r17, 0xFF	; 255
    11e0:	c8 01       	movw	r24, r16
    11e2:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    11e6:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
    11ea:	81 11       	cpse	r24, r1
    11ec:	14 c0       	rjmp	.+40     	; 0x1216 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    11ee:	0a 50       	subi	r16, 0x0A	; 10
    11f0:	11 09       	sbc	r17, r1
    11f2:	c8 01       	movw	r24, r16
    11f4:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    11f8:	8e 89       	ldd	r24, Y+22	; 0x16
    11fa:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
    11fe:	98 17       	cp	r25, r24
    1200:	10 f4       	brcc	.+4      	; 0x1206 <xTaskRemoveFromEventList+0x42>
    1202:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
    1206:	b9 e0       	ldi	r27, 0x09	; 9
    1208:	8b 9f       	mul	r24, r27
    120a:	c0 01       	movw	r24, r0
    120c:	11 24       	eor	r1, r1
    120e:	b8 01       	movw	r22, r16
    1210:	8a 53       	subi	r24, 0x3A	; 58
    1212:	9e 4f       	sbci	r25, 0xFE	; 254
    1214:	03 c0       	rjmp	.+6      	; 0x121c <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1216:	b8 01       	movw	r22, r16
    1218:	87 ea       	ldi	r24, 0xA7	; 167
    121a:	91 e0       	ldi	r25, 0x01	; 1
    121c:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1220:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1224:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1228:	9e 89       	ldd	r25, Y+22	; 0x16
    122a:	86 89       	ldd	r24, Z+22	; 0x16
    122c:	89 17       	cp	r24, r25
    122e:	20 f4       	brcc	.+8      	; 0x1238 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1230:	81 e0       	ldi	r24, 0x01	; 1
    1232:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xYieldPending>
    1236:	01 c0       	rjmp	.+2      	; 0x123a <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
    1238:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	1f 91       	pop	r17
    1240:	0f 91       	pop	r16
    1242:	08 95       	ret

00001244 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1244:	0f 93       	push	r16
    1246:	1f 93       	push	r17
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    124c:	70 68       	ori	r23, 0x80	; 128
    124e:	fc 01       	movw	r30, r24
    1250:	71 83       	std	Z+1, r23	; 0x01
    1252:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1254:	c6 81       	ldd	r28, Z+6	; 0x06
    1256:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1258:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    125c:	8e 01       	movw	r16, r28
    125e:	0e 5f       	subi	r16, 0xFE	; 254
    1260:	1f 4f       	sbci	r17, 0xFF	; 255
    1262:	c8 01       	movw	r24, r16
    1264:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1268:	8e 89       	ldd	r24, Y+22	; 0x16
    126a:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
    126e:	98 17       	cp	r25, r24
    1270:	10 f4       	brcc	.+4      	; 0x1276 <vTaskRemoveFromUnorderedEventList+0x32>
    1272:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
    1276:	f9 e0       	ldi	r31, 0x09	; 9
    1278:	8f 9f       	mul	r24, r31
    127a:	c0 01       	movw	r24, r0
    127c:	11 24       	eor	r1, r1
    127e:	b8 01       	movw	r22, r16
    1280:	8a 53       	subi	r24, 0x3A	; 58
    1282:	9e 4f       	sbci	r25, 0xFE	; 254
    1284:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1288:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    128c:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1290:	9e 89       	ldd	r25, Y+22	; 0x16
    1292:	86 89       	ldd	r24, Z+22	; 0x16
    1294:	89 17       	cp	r24, r25
    1296:	18 f4       	brcc	.+6      	; 0x129e <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xYieldPending>
	}
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	1f 91       	pop	r17
    12a4:	0f 91       	pop	r16
    12a6:	08 95       	ret

000012a8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    12a8:	0f b6       	in	r0, 0x3f	; 63
    12aa:	f8 94       	cli
    12ac:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    12ae:	20 91 95 01 	lds	r18, 0x0195	; 0x800195 <xNumOfOverflows>
    12b2:	fc 01       	movw	r30, r24
    12b4:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    12b6:	20 91 9a 01 	lds	r18, 0x019A	; 0x80019a <xTickCount>
    12ba:	30 91 9b 01 	lds	r19, 0x019B	; 0x80019b <xTickCount+0x1>
    12be:	32 83       	std	Z+2, r19	; 0x02
    12c0:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    12c2:	0f 90       	pop	r0
    12c4:	0f be       	out	0x3f, r0	; 63
    12c6:	08 95       	ret

000012c8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    12c8:	20 91 95 01 	lds	r18, 0x0195	; 0x800195 <xNumOfOverflows>
    12cc:	fc 01       	movw	r30, r24
    12ce:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    12d0:	20 91 9a 01 	lds	r18, 0x019A	; 0x80019a <xTickCount>
    12d4:	30 91 9b 01 	lds	r19, 0x019B	; 0x80019b <xTickCount+0x1>
    12d8:	32 83       	std	Z+2, r19	; 0x02
    12da:	21 83       	std	Z+1, r18	; 0x01
    12dc:	08 95       	ret

000012de <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    12de:	0f b6       	in	r0, 0x3f	; 63
    12e0:	f8 94       	cli
    12e2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    12e4:	20 91 9a 01 	lds	r18, 0x019A	; 0x80019a <xTickCount>
    12e8:	30 91 9b 01 	lds	r19, 0x019B	; 0x80019b <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    12ec:	dc 01       	movw	r26, r24
    12ee:	11 96       	adiw	r26, 0x01	; 1
    12f0:	4d 91       	ld	r20, X+
    12f2:	5c 91       	ld	r21, X
    12f4:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    12f6:	e0 91 95 01 	lds	r30, 0x0195	; 0x800195 <xNumOfOverflows>
    12fa:	fc 91       	ld	r31, X
    12fc:	fe 17       	cp	r31, r30
    12fe:	19 f0       	breq	.+6      	; 0x1306 <xTaskCheckForTimeOut+0x28>
    1300:	24 17       	cp	r18, r20
    1302:	35 07       	cpc	r19, r21
    1304:	90 f4       	brcc	.+36     	; 0x132a <xTaskCheckForTimeOut+0x4c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1306:	24 1b       	sub	r18, r20
    1308:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    130a:	fb 01       	movw	r30, r22
    130c:	40 81       	ld	r20, Z
    130e:	51 81       	ldd	r21, Z+1	; 0x01
    1310:	24 17       	cp	r18, r20
    1312:	35 07       	cpc	r19, r21
    1314:	40 f4       	brcc	.+16     	; 0x1326 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    1316:	42 1b       	sub	r20, r18
    1318:	53 0b       	sbc	r21, r19
    131a:	51 83       	std	Z+1, r21	; 0x01
    131c:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    131e:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    1322:	80 e0       	ldi	r24, 0x00	; 0
    1324:	03 c0       	rjmp	.+6      	; 0x132c <xTaskCheckForTimeOut+0x4e>
		}
		else
		{
			*pxTicksToWait = 0;
    1326:	11 82       	std	Z+1, r1	; 0x01
    1328:	10 82       	st	Z, r1
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    132a:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1330:	08 95       	ret

00001332 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1332:	81 e0       	ldi	r24, 0x01	; 1
    1334:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xYieldPending>
    1338:	08 95       	ret

0000133a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    133a:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    133e:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1342:	84 85       	ldd	r24, Z+12	; 0x0c
    1344:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1346:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    134a:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    134e:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    1352:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1356:	56 96       	adiw	r26, 0x16	; 22
    1358:	4c 91       	ld	r20, X
    135a:	24 e0       	ldi	r18, 0x04	; 4
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	24 1b       	sub	r18, r20
    1360:	31 09       	sbc	r19, r1
    1362:	35 87       	std	Z+13, r19	; 0x0d
    1364:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1366:	08 95       	ret

00001368 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1368:	0f 93       	push	r16
    136a:	1f 93       	push	r17
    136c:	18 2f       	mov	r17, r24
    136e:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1376:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    137a:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    137e:	41 a1       	ldd	r20, Z+33	; 0x21
    1380:	52 a1       	ldd	r21, Z+34	; 0x22
    1382:	63 a1       	ldd	r22, Z+35	; 0x23
    1384:	74 a1       	ldd	r23, Z+36	; 0x24
    1386:	45 2b       	or	r20, r21
    1388:	46 2b       	or	r20, r22
    138a:	47 2b       	or	r20, r23
    138c:	61 f4       	brne	.+24     	; 0x13a6 <ulTaskNotifyTake+0x3e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    138e:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1392:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1396:	21 e0       	ldi	r18, 0x01	; 1
    1398:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    139a:	00 97       	sbiw	r24, 0x00	; 0
    139c:	21 f0       	breq	.+8      	; 0x13a6 <ulTaskNotifyTake+0x3e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    139e:	0e 94 02 05 	call	0xa04	; 0xa04 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    13a2:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    13a6:	0f 90       	pop	r0
    13a8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    13b0:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    13b4:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    13b8:	61 a1       	ldd	r22, Z+33	; 0x21
    13ba:	72 a1       	ldd	r23, Z+34	; 0x22
    13bc:	83 a1       	ldd	r24, Z+35	; 0x23
    13be:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    13c0:	61 15       	cp	r22, r1
    13c2:	71 05       	cpc	r23, r1
    13c4:	81 05       	cpc	r24, r1
    13c6:	91 05       	cpc	r25, r1
    13c8:	a9 f0       	breq	.+42     	; 0x13f4 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    13ca:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    13ce:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    13d2:	11 23       	and	r17, r17
    13d4:	29 f0       	breq	.+10     	; 0x13e0 <ulTaskNotifyTake+0x78>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    13d6:	11 a2       	std	Z+33, r1	; 0x21
    13d8:	12 a2       	std	Z+34, r1	; 0x22
    13da:	13 a2       	std	Z+35, r1	; 0x23
    13dc:	14 a2       	std	Z+36, r1	; 0x24
    13de:	0a c0       	rjmp	.+20     	; 0x13f4 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    13e0:	8b 01       	movw	r16, r22
    13e2:	9c 01       	movw	r18, r24
    13e4:	01 50       	subi	r16, 0x01	; 1
    13e6:	11 09       	sbc	r17, r1
    13e8:	21 09       	sbc	r18, r1
    13ea:	31 09       	sbc	r19, r1
    13ec:	01 a3       	std	Z+33, r16	; 0x21
    13ee:	12 a3       	std	Z+34, r17	; 0x22
    13f0:	23 a3       	std	Z+35, r18	; 0x23
    13f2:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    13f4:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    13f8:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    13fc:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    13fe:	0f 90       	pop	r0
    1400:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1402:	1f 91       	pop	r17
    1404:	0f 91       	pop	r16
    1406:	08 95       	ret

00001408 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    1408:	4f 92       	push	r4
    140a:	5f 92       	push	r5
    140c:	6f 92       	push	r6
    140e:	7f 92       	push	r7
    1410:	8f 92       	push	r8
    1412:	9f 92       	push	r9
    1414:	af 92       	push	r10
    1416:	bf 92       	push	r11
    1418:	ef 92       	push	r14
    141a:	ff 92       	push	r15
    141c:	0f 93       	push	r16
    141e:	1f 93       	push	r17
    1420:	49 01       	movw	r8, r18
    1422:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    142a:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    142e:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1432:	25 a1       	ldd	r18, Z+37	; 0x25
    1434:	22 30       	cpi	r18, 0x02	; 2
    1436:	31 f1       	breq	.+76     	; 0x1484 <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1438:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    143c:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1440:	21 a1       	ldd	r18, Z+33	; 0x21
    1442:	32 a1       	ldd	r19, Z+34	; 0x22
    1444:	43 a1       	ldd	r20, Z+35	; 0x23
    1446:	54 a1       	ldd	r21, Z+36	; 0x24
    1448:	2b 01       	movw	r4, r22
    144a:	3c 01       	movw	r6, r24
    144c:	40 94       	com	r4
    144e:	50 94       	com	r5
    1450:	60 94       	com	r6
    1452:	70 94       	com	r7
    1454:	d3 01       	movw	r26, r6
    1456:	c2 01       	movw	r24, r4
    1458:	82 23       	and	r24, r18
    145a:	93 23       	and	r25, r19
    145c:	a4 23       	and	r26, r20
    145e:	b5 23       	and	r27, r21
    1460:	81 a3       	std	Z+33, r24	; 0x21
    1462:	92 a3       	std	Z+34, r25	; 0x22
    1464:	a3 a3       	std	Z+35, r26	; 0x23
    1466:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1468:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    146c:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1474:	e1 14       	cp	r14, r1
    1476:	f1 04       	cpc	r15, r1
    1478:	29 f0       	breq	.+10     	; 0x1484 <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    147a:	c7 01       	movw	r24, r14
    147c:	0e 94 02 05 	call	0xa04	; 0xa04 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1480:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1484:	0f 90       	pop	r0
    1486:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1488:	0f b6       	in	r0, 0x3f	; 63
    148a:	f8 94       	cli
    148c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    148e:	01 15       	cp	r16, r1
    1490:	11 05       	cpc	r17, r1
    1492:	69 f0       	breq	.+26     	; 0x14ae <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1494:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1498:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    149c:	81 a1       	ldd	r24, Z+33	; 0x21
    149e:	92 a1       	ldd	r25, Z+34	; 0x22
    14a0:	a3 a1       	ldd	r26, Z+35	; 0x23
    14a2:	b4 a1       	ldd	r27, Z+36	; 0x24
    14a4:	f8 01       	movw	r30, r16
    14a6:	80 83       	st	Z, r24
    14a8:	91 83       	std	Z+1, r25	; 0x01
    14aa:	a2 83       	std	Z+2, r26	; 0x02
    14ac:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    14ae:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    14b2:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    14b6:	85 a1       	ldd	r24, Z+37	; 0x25
    14b8:	82 30       	cpi	r24, 0x02	; 2
    14ba:	c1 f4       	brne	.+48     	; 0x14ec <xTaskNotifyWait+0xe4>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    14bc:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    14c0:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    14c4:	41 a1       	ldd	r20, Z+33	; 0x21
    14c6:	52 a1       	ldd	r21, Z+34	; 0x22
    14c8:	63 a1       	ldd	r22, Z+35	; 0x23
    14ca:	74 a1       	ldd	r23, Z+36	; 0x24
    14cc:	d5 01       	movw	r26, r10
    14ce:	c4 01       	movw	r24, r8
    14d0:	80 95       	com	r24
    14d2:	90 95       	com	r25
    14d4:	a0 95       	com	r26
    14d6:	b0 95       	com	r27
    14d8:	84 23       	and	r24, r20
    14da:	95 23       	and	r25, r21
    14dc:	a6 23       	and	r26, r22
    14de:	b7 23       	and	r27, r23
    14e0:	81 a3       	std	Z+33, r24	; 0x21
    14e2:	92 a3       	std	Z+34, r25	; 0x22
    14e4:	a3 a3       	std	Z+35, r26	; 0x23
    14e6:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    14e8:	81 e0       	ldi	r24, 0x01	; 1
    14ea:	01 c0       	rjmp	.+2      	; 0x14ee <xTaskNotifyWait+0xe6>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    14ec:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    14ee:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    14f2:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    14f6:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    14f8:	0f 90       	pop	r0
    14fa:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    14fc:	1f 91       	pop	r17
    14fe:	0f 91       	pop	r16
    1500:	ff 90       	pop	r15
    1502:	ef 90       	pop	r14
    1504:	bf 90       	pop	r11
    1506:	af 90       	pop	r10
    1508:	9f 90       	pop	r9
    150a:	8f 90       	pop	r8
    150c:	7f 90       	pop	r7
    150e:	6f 90       	pop	r6
    1510:	5f 90       	pop	r5
    1512:	4f 90       	pop	r4
    1514:	08 95       	ret

00001516 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1516:	0f 93       	push	r16
    1518:	1f 93       	push	r17
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	f8 94       	cli
    1524:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1526:	01 15       	cp	r16, r1
    1528:	11 05       	cpc	r17, r1
    152a:	49 f0       	breq	.+18     	; 0x153e <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    152c:	81 a1       	ldd	r24, Z+33	; 0x21
    152e:	92 a1       	ldd	r25, Z+34	; 0x22
    1530:	a3 a1       	ldd	r26, Z+35	; 0x23
    1532:	b4 a1       	ldd	r27, Z+36	; 0x24
    1534:	e8 01       	movw	r28, r16
    1536:	88 83       	st	Y, r24
    1538:	99 83       	std	Y+1, r25	; 0x01
    153a:	aa 83       	std	Y+2, r26	; 0x02
    153c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    153e:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1540:	82 e0       	ldi	r24, 0x02	; 2
    1542:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1544:	22 30       	cpi	r18, 0x02	; 2
    1546:	89 f0       	breq	.+34     	; 0x156a <xTaskGenericNotify+0x54>
    1548:	58 f4       	brcc	.+22     	; 0x1560 <xTaskGenericNotify+0x4a>
    154a:	21 30       	cpi	r18, 0x01	; 1
    154c:	01 f5       	brne	.+64     	; 0x158e <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    154e:	81 a1       	ldd	r24, Z+33	; 0x21
    1550:	92 a1       	ldd	r25, Z+34	; 0x22
    1552:	a3 a1       	ldd	r26, Z+35	; 0x23
    1554:	b4 a1       	ldd	r27, Z+36	; 0x24
    1556:	48 2b       	or	r20, r24
    1558:	59 2b       	or	r21, r25
    155a:	6a 2b       	or	r22, r26
    155c:	7b 2b       	or	r23, r27
    155e:	13 c0       	rjmp	.+38     	; 0x1586 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1560:	23 30       	cpi	r18, 0x03	; 3
    1562:	89 f0       	breq	.+34     	; 0x1586 <xTaskGenericNotify+0x70>
    1564:	24 30       	cpi	r18, 0x04	; 4
    1566:	69 f0       	breq	.+26     	; 0x1582 <xTaskGenericNotify+0x6c>
    1568:	12 c0       	rjmp	.+36     	; 0x158e <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    156a:	81 a1       	ldd	r24, Z+33	; 0x21
    156c:	92 a1       	ldd	r25, Z+34	; 0x22
    156e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1570:	b4 a1       	ldd	r27, Z+36	; 0x24
    1572:	01 96       	adiw	r24, 0x01	; 1
    1574:	a1 1d       	adc	r26, r1
    1576:	b1 1d       	adc	r27, r1
    1578:	81 a3       	std	Z+33, r24	; 0x21
    157a:	92 a3       	std	Z+34, r25	; 0x22
    157c:	a3 a3       	std	Z+35, r26	; 0x23
    157e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1580:	06 c0       	rjmp	.+12     	; 0x158e <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1582:	32 30       	cpi	r19, 0x02	; 2
    1584:	49 f1       	breq	.+82     	; 0x15d8 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1586:	41 a3       	std	Z+33, r20	; 0x21
    1588:	52 a3       	std	Z+34, r21	; 0x22
    158a:	63 a3       	std	Z+35, r22	; 0x23
    158c:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    158e:	31 30       	cpi	r19, 0x01	; 1
    1590:	09 f5       	brne	.+66     	; 0x15d4 <xTaskGenericNotify+0xbe>
    1592:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1594:	8f 01       	movw	r16, r30
    1596:	0e 5f       	subi	r16, 0xFE	; 254
    1598:	1f 4f       	sbci	r17, 0xFF	; 255
    159a:	c8 01       	movw	r24, r16
    159c:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    15a0:	8e 89       	ldd	r24, Y+22	; 0x16
    15a2:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
    15a6:	98 17       	cp	r25, r24
    15a8:	10 f4       	brcc	.+4      	; 0x15ae <xTaskGenericNotify+0x98>
    15aa:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
    15ae:	29 e0       	ldi	r18, 0x09	; 9
    15b0:	82 9f       	mul	r24, r18
    15b2:	c0 01       	movw	r24, r0
    15b4:	11 24       	eor	r1, r1
    15b6:	b8 01       	movw	r22, r16
    15b8:	8a 53       	subi	r24, 0x3A	; 58
    15ba:	9e 4f       	sbci	r25, 0xFE	; 254
    15bc:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    15c0:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    15c4:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    15c8:	9e 89       	ldd	r25, Y+22	; 0x16
    15ca:	86 89       	ldd	r24, Z+22	; 0x16
    15cc:	89 17       	cp	r24, r25
    15ce:	10 f4       	brcc	.+4      	; 0x15d4 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    15d0:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	01 c0       	rjmp	.+2      	; 0x15da <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    15d8:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    15da:	0f 90       	pop	r0
    15dc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	1f 91       	pop	r17
    15e4:	0f 91       	pop	r16
    15e6:	08 95       	ret

000015e8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    15e8:	ef 92       	push	r14
    15ea:	ff 92       	push	r15
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    15f6:	01 15       	cp	r16, r1
    15f8:	11 05       	cpc	r17, r1
    15fa:	49 f0       	breq	.+18     	; 0x160e <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    15fc:	81 a1       	ldd	r24, Z+33	; 0x21
    15fe:	92 a1       	ldd	r25, Z+34	; 0x22
    1600:	a3 a1       	ldd	r26, Z+35	; 0x23
    1602:	b4 a1       	ldd	r27, Z+36	; 0x24
    1604:	e8 01       	movw	r28, r16
    1606:	88 83       	st	Y, r24
    1608:	99 83       	std	Y+1, r25	; 0x01
    160a:	aa 83       	std	Y+2, r26	; 0x02
    160c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    160e:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1610:	82 e0       	ldi	r24, 0x02	; 2
    1612:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1614:	22 30       	cpi	r18, 0x02	; 2
    1616:	89 f0       	breq	.+34     	; 0x163a <xTaskGenericNotifyFromISR+0x52>
    1618:	58 f4       	brcc	.+22     	; 0x1630 <xTaskGenericNotifyFromISR+0x48>
    161a:	21 30       	cpi	r18, 0x01	; 1
    161c:	01 f5       	brne	.+64     	; 0x165e <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    161e:	81 a1       	ldd	r24, Z+33	; 0x21
    1620:	92 a1       	ldd	r25, Z+34	; 0x22
    1622:	a3 a1       	ldd	r26, Z+35	; 0x23
    1624:	b4 a1       	ldd	r27, Z+36	; 0x24
    1626:	48 2b       	or	r20, r24
    1628:	59 2b       	or	r21, r25
    162a:	6a 2b       	or	r22, r26
    162c:	7b 2b       	or	r23, r27
    162e:	13 c0       	rjmp	.+38     	; 0x1656 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1630:	23 30       	cpi	r18, 0x03	; 3
    1632:	89 f0       	breq	.+34     	; 0x1656 <xTaskGenericNotifyFromISR+0x6e>
    1634:	24 30       	cpi	r18, 0x04	; 4
    1636:	69 f0       	breq	.+26     	; 0x1652 <xTaskGenericNotifyFromISR+0x6a>
    1638:	12 c0       	rjmp	.+36     	; 0x165e <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    163a:	81 a1       	ldd	r24, Z+33	; 0x21
    163c:	92 a1       	ldd	r25, Z+34	; 0x22
    163e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1640:	b4 a1       	ldd	r27, Z+36	; 0x24
    1642:	01 96       	adiw	r24, 0x01	; 1
    1644:	a1 1d       	adc	r26, r1
    1646:	b1 1d       	adc	r27, r1
    1648:	81 a3       	std	Z+33, r24	; 0x21
    164a:	92 a3       	std	Z+34, r25	; 0x22
    164c:	a3 a3       	std	Z+35, r26	; 0x23
    164e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1650:	06 c0       	rjmp	.+12     	; 0x165e <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1652:	32 30       	cpi	r19, 0x02	; 2
    1654:	d9 f1       	breq	.+118    	; 0x16cc <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1656:	41 a3       	std	Z+33, r20	; 0x21
    1658:	52 a3       	std	Z+34, r21	; 0x22
    165a:	63 a3       	std	Z+35, r22	; 0x23
    165c:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    165e:	31 30       	cpi	r19, 0x01	; 1
    1660:	11 f0       	breq	.+4      	; 0x1666 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	34 c0       	rjmp	.+104    	; 0x16ce <xTaskGenericNotifyFromISR+0xe6>
    1666:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1668:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
    166c:	81 11       	cpse	r24, r1
    166e:	15 c0       	rjmp	.+42     	; 0x169a <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1670:	8f 01       	movw	r16, r30
    1672:	0e 5f       	subi	r16, 0xFE	; 254
    1674:	1f 4f       	sbci	r17, 0xFF	; 255
    1676:	c8 01       	movw	r24, r16
    1678:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    167c:	8e 89       	ldd	r24, Y+22	; 0x16
    167e:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
    1682:	98 17       	cp	r25, r24
    1684:	10 f4       	brcc	.+4      	; 0x168a <xTaskGenericNotifyFromISR+0xa2>
    1686:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
    168a:	e9 e0       	ldi	r30, 0x09	; 9
    168c:	8e 9f       	mul	r24, r30
    168e:	c0 01       	movw	r24, r0
    1690:	11 24       	eor	r1, r1
    1692:	b8 01       	movw	r22, r16
    1694:	8a 53       	subi	r24, 0x3A	; 58
    1696:	9e 4f       	sbci	r25, 0xFE	; 254
    1698:	05 c0       	rjmp	.+10     	; 0x16a4 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    169a:	bf 01       	movw	r22, r30
    169c:	64 5f       	subi	r22, 0xF4	; 244
    169e:	7f 4f       	sbci	r23, 0xFF	; 255
    16a0:	87 ea       	ldi	r24, 0xA7	; 167
    16a2:	91 e0       	ldi	r25, 0x01	; 1
    16a4:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    16a8:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    16ac:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    16b0:	9e 89       	ldd	r25, Y+22	; 0x16
    16b2:	86 89       	ldd	r24, Z+22	; 0x16
    16b4:	89 17       	cp	r24, r25
    16b6:	a8 f6       	brcc	.-86     	; 0x1662 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    16b8:	e1 14       	cp	r14, r1
    16ba:	f1 04       	cpc	r15, r1
    16bc:	19 f0       	breq	.+6      	; 0x16c4 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	e7 01       	movw	r28, r14
    16c2:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    16c4:	81 e0       	ldi	r24, 0x01	; 1
    16c6:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xYieldPending>
    16ca:	01 c0       	rjmp	.+2      	; 0x16ce <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    16cc:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    16ce:	df 91       	pop	r29
    16d0:	cf 91       	pop	r28
    16d2:	1f 91       	pop	r17
    16d4:	0f 91       	pop	r16
    16d6:	ff 90       	pop	r15
    16d8:	ef 90       	pop	r14
    16da:	08 95       	ret

000016dc <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    16dc:	ef 92       	push	r14
    16de:	ff 92       	push	r15
    16e0:	0f 93       	push	r16
    16e2:	1f 93       	push	r17
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    16ea:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    16ec:	82 e0       	ldi	r24, 0x02	; 2
    16ee:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    16f0:	81 a1       	ldd	r24, Z+33	; 0x21
    16f2:	92 a1       	ldd	r25, Z+34	; 0x22
    16f4:	a3 a1       	ldd	r26, Z+35	; 0x23
    16f6:	b4 a1       	ldd	r27, Z+36	; 0x24
    16f8:	01 96       	adiw	r24, 0x01	; 1
    16fa:	a1 1d       	adc	r26, r1
    16fc:	b1 1d       	adc	r27, r1
    16fe:	81 a3       	std	Z+33, r24	; 0x21
    1700:	92 a3       	std	Z+34, r25	; 0x22
    1702:	a3 a3       	std	Z+35, r26	; 0x23
    1704:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1706:	21 30       	cpi	r18, 0x01	; 1
    1708:	a1 f5       	brne	.+104    	; 0x1772 <vTaskNotifyGiveFromISR+0x96>
    170a:	8b 01       	movw	r16, r22
    170c:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    170e:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <uxSchedulerSuspended>
    1712:	81 11       	cpse	r24, r1
    1714:	16 c0       	rjmp	.+44     	; 0x1742 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1716:	7f 01       	movw	r14, r30
    1718:	22 e0       	ldi	r18, 0x02	; 2
    171a:	e2 0e       	add	r14, r18
    171c:	f1 1c       	adc	r15, r1
    171e:	c7 01       	movw	r24, r14
    1720:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1724:	8e 89       	ldd	r24, Y+22	; 0x16
    1726:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <uxTopReadyPriority>
    172a:	98 17       	cp	r25, r24
    172c:	10 f4       	brcc	.+4      	; 0x1732 <vTaskNotifyGiveFromISR+0x56>
    172e:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <uxTopReadyPriority>
    1732:	e9 e0       	ldi	r30, 0x09	; 9
    1734:	8e 9f       	mul	r24, r30
    1736:	c0 01       	movw	r24, r0
    1738:	11 24       	eor	r1, r1
    173a:	b7 01       	movw	r22, r14
    173c:	8a 53       	subi	r24, 0x3A	; 58
    173e:	9e 4f       	sbci	r25, 0xFE	; 254
    1740:	05 c0       	rjmp	.+10     	; 0x174c <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1742:	bf 01       	movw	r22, r30
    1744:	64 5f       	subi	r22, 0xF4	; 244
    1746:	7f 4f       	sbci	r23, 0xFF	; 255
    1748:	87 ea       	ldi	r24, 0xA7	; 167
    174a:	91 e0       	ldi	r25, 0x01	; 1
    174c:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1750:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1754:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1758:	9e 89       	ldd	r25, Y+22	; 0x16
    175a:	86 89       	ldd	r24, Z+22	; 0x16
    175c:	89 17       	cp	r24, r25
    175e:	48 f4       	brcc	.+18     	; 0x1772 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1760:	01 15       	cp	r16, r1
    1762:	11 05       	cpc	r17, r1
    1764:	19 f0       	breq	.+6      	; 0x176c <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1766:	81 e0       	ldi	r24, 0x01	; 1
    1768:	f8 01       	movw	r30, r16
    176a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1772:	df 91       	pop	r29
    1774:	cf 91       	pop	r28
    1776:	1f 91       	pop	r17
    1778:	0f 91       	pop	r16
    177a:	ff 90       	pop	r15
    177c:	ef 90       	pop	r14
    177e:	08 95       	ret

00001780 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1780:	00 97       	sbiw	r24, 0x00	; 0
    1782:	21 f4       	brne	.+8      	; 0x178c <xTaskNotifyStateClear+0xc>
    1784:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
    1788:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1792:	fc 01       	movw	r30, r24
    1794:	25 a1       	ldd	r18, Z+37	; 0x25
    1796:	22 30       	cpi	r18, 0x02	; 2
    1798:	19 f4       	brne	.+6      	; 0x17a0 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    179a:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	01 c0       	rjmp	.+2      	; 0x17a2 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    17a0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    17a2:	0f 90       	pop	r0
    17a4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    17a6:	08 95       	ret

000017a8 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    17ae:	fc 01       	movw	r30, r24
    17b0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    17b2:	0f 90       	pop	r0
    17b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	91 11       	cpse	r25, r1
    17ba:	80 e0       	ldi	r24, 0x00	; 0
}
    17bc:	08 95       	ret

000017be <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    17be:	0f 93       	push	r16
    17c0:	1f 93       	push	r17
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	ec 01       	movw	r28, r24
    17c8:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17ca:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    17cc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    17ce:	44 23       	and	r20, r20
    17d0:	b1 f1       	breq	.+108    	; 0x183e <prvCopyDataToQueue+0x80>
    17d2:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    17d4:	01 11       	cpse	r16, r1
    17d6:	15 c0       	rjmp	.+42     	; 0x1802 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    17d8:	8a 81       	ldd	r24, Y+2	; 0x02
    17da:	9b 81       	ldd	r25, Y+3	; 0x03
    17dc:	0e 94 4c 2a 	call	0x5498	; 0x5498 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    17e0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17e2:	8a 81       	ldd	r24, Y+2	; 0x02
    17e4:	9b 81       	ldd	r25, Y+3	; 0x03
    17e6:	82 0f       	add	r24, r18
    17e8:	91 1d       	adc	r25, r1
    17ea:	9b 83       	std	Y+3, r25	; 0x03
    17ec:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    17ee:	2c 81       	ldd	r18, Y+4	; 0x04
    17f0:	3d 81       	ldd	r19, Y+5	; 0x05
    17f2:	82 17       	cp	r24, r18
    17f4:	93 07       	cpc	r25, r19
    17f6:	18 f1       	brcs	.+70     	; 0x183e <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    17f8:	88 81       	ld	r24, Y
    17fa:	99 81       	ldd	r25, Y+1	; 0x01
    17fc:	9b 83       	std	Y+3, r25	; 0x03
    17fe:	8a 83       	std	Y+2, r24	; 0x02
    1800:	1e c0       	rjmp	.+60     	; 0x183e <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1802:	8e 81       	ldd	r24, Y+6	; 0x06
    1804:	9f 81       	ldd	r25, Y+7	; 0x07
    1806:	0e 94 4c 2a 	call	0x5498	; 0x5498 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    180a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	91 95       	neg	r25
    1810:	81 95       	neg	r24
    1812:	91 09       	sbc	r25, r1
    1814:	2e 81       	ldd	r18, Y+6	; 0x06
    1816:	3f 81       	ldd	r19, Y+7	; 0x07
    1818:	28 0f       	add	r18, r24
    181a:	39 1f       	adc	r19, r25
    181c:	3f 83       	std	Y+7, r19	; 0x07
    181e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1820:	48 81       	ld	r20, Y
    1822:	59 81       	ldd	r21, Y+1	; 0x01
    1824:	24 17       	cp	r18, r20
    1826:	35 07       	cpc	r19, r21
    1828:	30 f4       	brcc	.+12     	; 0x1836 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    182a:	2c 81       	ldd	r18, Y+4	; 0x04
    182c:	3d 81       	ldd	r19, Y+5	; 0x05
    182e:	82 0f       	add	r24, r18
    1830:	93 1f       	adc	r25, r19
    1832:	9f 83       	std	Y+7, r25	; 0x07
    1834:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1836:	02 30       	cpi	r16, 0x02	; 2
    1838:	11 f4       	brne	.+4      	; 0x183e <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    183a:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    183c:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    183e:	1f 5f       	subi	r17, 0xFF	; 255
    1840:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	1f 91       	pop	r17
    184a:	0f 91       	pop	r16
    184c:	08 95       	ret

0000184e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    184e:	fc 01       	movw	r30, r24
    1850:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1852:	44 8d       	ldd	r20, Z+28	; 0x1c
    1854:	44 23       	and	r20, r20
    1856:	a1 f0       	breq	.+40     	; 0x1880 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1858:	50 e0       	ldi	r21, 0x00	; 0
    185a:	26 81       	ldd	r18, Z+6	; 0x06
    185c:	37 81       	ldd	r19, Z+7	; 0x07
    185e:	24 0f       	add	r18, r20
    1860:	35 1f       	adc	r19, r21
    1862:	37 83       	std	Z+7, r19	; 0x07
    1864:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1866:	64 81       	ldd	r22, Z+4	; 0x04
    1868:	75 81       	ldd	r23, Z+5	; 0x05
    186a:	26 17       	cp	r18, r22
    186c:	37 07       	cpc	r19, r23
    186e:	20 f0       	brcs	.+8      	; 0x1878 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1870:	20 81       	ld	r18, Z
    1872:	31 81       	ldd	r19, Z+1	; 0x01
    1874:	37 83       	std	Z+7, r19	; 0x07
    1876:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1878:	66 81       	ldd	r22, Z+6	; 0x06
    187a:	77 81       	ldd	r23, Z+7	; 0x07
    187c:	0c 94 4c 2a 	jmp	0x5498	; 0x5498 <memcpy>
    1880:	08 95       	ret

00001882 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1882:	ef 92       	push	r14
    1884:	ff 92       	push	r15
    1886:	1f 93       	push	r17
    1888:	cf 93       	push	r28
    188a:	df 93       	push	r29
    188c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    188e:	0f b6       	in	r0, 0x3f	; 63
    1890:	f8 94       	cli
    1892:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1894:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1896:	7c 01       	movw	r14, r24
    1898:	81 e1       	ldi	r24, 0x11	; 17
    189a:	e8 0e       	add	r14, r24
    189c:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    189e:	11 16       	cp	r1, r17
    18a0:	5c f4       	brge	.+22     	; 0x18b8 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18a2:	89 89       	ldd	r24, Y+17	; 0x11
    18a4:	88 23       	and	r24, r24
    18a6:	41 f0       	breq	.+16     	; 0x18b8 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18a8:	c7 01       	movw	r24, r14
    18aa:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    18ae:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    18b0:	0e 94 99 09 	call	0x1332	; 0x1332 <vTaskMissedYield>
    18b4:	11 50       	subi	r17, 0x01	; 1
    18b6:	f3 cf       	rjmp	.-26     	; 0x189e <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    18b8:	8f ef       	ldi	r24, 0xFF	; 255
    18ba:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    18c6:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18c8:	7e 01       	movw	r14, r28
    18ca:	88 e0       	ldi	r24, 0x08	; 8
    18cc:	e8 0e       	add	r14, r24
    18ce:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    18d0:	11 16       	cp	r1, r17
    18d2:	5c f4       	brge	.+22     	; 0x18ea <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18d4:	88 85       	ldd	r24, Y+8	; 0x08
    18d6:	88 23       	and	r24, r24
    18d8:	41 f0       	breq	.+16     	; 0x18ea <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18da:	c7 01       	movw	r24, r14
    18dc:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    18e0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    18e2:	0e 94 99 09 	call	0x1332	; 0x1332 <vTaskMissedYield>
    18e6:	11 50       	subi	r17, 0x01	; 1
    18e8:	f3 cf       	rjmp	.-26     	; 0x18d0 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    18ea:	8f ef       	ldi	r24, 0xFF	; 255
    18ec:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    18ee:	0f 90       	pop	r0
    18f0:	0f be       	out	0x3f, r0	; 63
}
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	1f 91       	pop	r17
    18f8:	ff 90       	pop	r15
    18fa:	ef 90       	pop	r14
    18fc:	08 95       	ret

000018fe <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    18fe:	cf 93       	push	r28
    1900:	df 93       	push	r29
    1902:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	f8 94       	cli
    1908:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    190a:	48 81       	ld	r20, Y
    190c:	59 81       	ldd	r21, Y+1	; 0x01
    190e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1910:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1912:	9a 01       	movw	r18, r20
    1914:	87 9f       	mul	r24, r23
    1916:	20 0d       	add	r18, r0
    1918:	31 1d       	adc	r19, r1
    191a:	11 24       	eor	r1, r1
    191c:	3d 83       	std	Y+5, r19	; 0x05
    191e:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1920:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1922:	5b 83       	std	Y+3, r21	; 0x03
    1924:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1926:	90 e0       	ldi	r25, 0x00	; 0
    1928:	01 97       	sbiw	r24, 0x01	; 1
    192a:	78 9f       	mul	r23, r24
    192c:	90 01       	movw	r18, r0
    192e:	79 9f       	mul	r23, r25
    1930:	30 0d       	add	r19, r0
    1932:	11 24       	eor	r1, r1
    1934:	ca 01       	movw	r24, r20
    1936:	82 0f       	add	r24, r18
    1938:	93 1f       	adc	r25, r19
    193a:	9f 83       	std	Y+7, r25	; 0x07
    193c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    193e:	8f ef       	ldi	r24, 0xFF	; 255
    1940:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1942:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1944:	61 11       	cpse	r22, r1
    1946:	0c c0       	rjmp	.+24     	; 0x1960 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1948:	88 85       	ldd	r24, Y+8	; 0x08
    194a:	88 23       	and	r24, r24
    194c:	89 f0       	breq	.+34     	; 0x1970 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    194e:	ce 01       	movw	r24, r28
    1950:	08 96       	adiw	r24, 0x08	; 8
    1952:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1956:	88 23       	and	r24, r24
    1958:	59 f0       	breq	.+22     	; 0x1970 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    195a:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    195e:	08 c0       	rjmp	.+16     	; 0x1970 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1960:	ce 01       	movw	r24, r28
    1962:	08 96       	adiw	r24, 0x08	; 8
    1964:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1968:	ce 01       	movw	r24, r28
    196a:	41 96       	adiw	r24, 0x11	; 17
    196c:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	df 91       	pop	r29
    1978:	cf 91       	pop	r28
    197a:	08 95       	ret

0000197c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    197c:	0f 93       	push	r16
    197e:	1f 93       	push	r17
    1980:	cf 93       	push	r28
    1982:	df 93       	push	r29
    1984:	08 2f       	mov	r16, r24
    1986:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1988:	66 23       	and	r22, r22
    198a:	21 f0       	breq	.+8      	; 0x1994 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    198c:	86 9f       	mul	r24, r22
    198e:	c0 01       	movw	r24, r0
    1990:	11 24       	eor	r1, r1
    1992:	02 c0       	rjmp	.+4      	; 0x1998 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1994:	80 e0       	ldi	r24, 0x00	; 0
    1996:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1998:	4f 96       	adiw	r24, 0x1f	; 31
    199a:	0e 94 15 13 	call	0x262a	; 0x262a <pvPortMalloc>
    199e:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    19a0:	00 97       	sbiw	r24, 0x00	; 0
    19a2:	71 f0       	breq	.+28     	; 0x19c0 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    19a4:	11 11       	cpse	r17, r1
    19a6:	03 c0       	rjmp	.+6      	; 0x19ae <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    19a8:	99 83       	std	Y+1, r25	; 0x01
    19aa:	88 83       	st	Y, r24
    19ac:	03 c0       	rjmp	.+6      	; 0x19b4 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    19ae:	4f 96       	adiw	r24, 0x1f	; 31
    19b0:	99 83       	std	Y+1, r25	; 0x01
    19b2:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    19b4:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    19b6:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    19b8:	61 e0       	ldi	r22, 0x01	; 1
    19ba:	ce 01       	movw	r24, r28
    19bc:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    19c0:	ce 01       	movw	r24, r28
    19c2:	df 91       	pop	r29
    19c4:	cf 91       	pop	r28
    19c6:	1f 91       	pop	r17
    19c8:	0f 91       	pop	r16
    19ca:	08 95       	ret

000019cc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    19cc:	af 92       	push	r10
    19ce:	bf 92       	push	r11
    19d0:	cf 92       	push	r12
    19d2:	df 92       	push	r13
    19d4:	ff 92       	push	r15
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
    19de:	00 d0       	rcall	.+0      	; 0x19e0 <xQueueGenericSend+0x14>
    19e0:	00 d0       	rcall	.+0      	; 0x19e2 <xQueueGenericSend+0x16>
    19e2:	1f 92       	push	r1
    19e4:	cd b7       	in	r28, 0x3d	; 61
    19e6:	de b7       	in	r29, 0x3e	; 62
    19e8:	8c 01       	movw	r16, r24
    19ea:	6b 01       	movw	r12, r22
    19ec:	5d 83       	std	Y+5, r21	; 0x05
    19ee:	4c 83       	std	Y+4, r20	; 0x04
    19f0:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19f2:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19f4:	58 01       	movw	r10, r16
    19f6:	98 e0       	ldi	r25, 0x08	; 8
    19f8:	a9 0e       	add	r10, r25
    19fa:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19fc:	0f b6       	in	r0, 0x3f	; 63
    19fe:	f8 94       	cli
    1a00:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a02:	f8 01       	movw	r30, r16
    1a04:	22 8d       	ldd	r18, Z+26	; 0x1a
    1a06:	93 8d       	ldd	r25, Z+27	; 0x1b
    1a08:	29 17       	cp	r18, r25
    1a0a:	18 f0       	brcs	.+6      	; 0x1a12 <xQueueGenericSend+0x46>
    1a0c:	f2 e0       	ldi	r31, 0x02	; 2
    1a0e:	ff 12       	cpse	r15, r31
    1a10:	14 c0       	rjmp	.+40     	; 0x1a3a <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a12:	4f 2d       	mov	r20, r15
    1a14:	b6 01       	movw	r22, r12
    1a16:	c8 01       	movw	r24, r16
    1a18:	0e 94 df 0b 	call	0x17be	; 0x17be <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a1c:	f8 01       	movw	r30, r16
    1a1e:	91 89       	ldd	r25, Z+17	; 0x11
    1a20:	99 23       	and	r25, r25
    1a22:	21 f0       	breq	.+8      	; 0x1a2c <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a24:	c8 01       	movw	r24, r16
    1a26:	41 96       	adiw	r24, 0x11	; 17
    1a28:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1a2c:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1a2e:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	50 c0       	rjmp	.+160    	; 0x1ada <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a3a:	2c 81       	ldd	r18, Y+4	; 0x04
    1a3c:	3d 81       	ldd	r19, Y+5	; 0x05
    1a3e:	23 2b       	or	r18, r19
    1a40:	19 f4       	brne	.+6      	; 0x1a48 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63
    1a46:	48 c0       	rjmp	.+144    	; 0x1ad8 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1a48:	81 11       	cpse	r24, r1
    1a4a:	04 c0       	rjmp	.+8      	; 0x1a54 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	01 96       	adiw	r24, 0x01	; 1
    1a50:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a54:	0f 90       	pop	r0
    1a56:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a58:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	0f 92       	push	r0
    1a62:	f8 01       	movw	r30, r16
    1a64:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a66:	8f 3f       	cpi	r24, 0xFF	; 255
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <xQueueGenericSend+0xa0>
    1a6a:	15 8e       	std	Z+29, r1	; 0x1d
    1a6c:	f8 01       	movw	r30, r16
    1a6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a70:	8f 3f       	cpi	r24, 0xFF	; 255
    1a72:	09 f4       	brne	.+2      	; 0x1a76 <xQueueGenericSend+0xaa>
    1a74:	16 8e       	std	Z+30, r1	; 0x1e
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a7a:	be 01       	movw	r22, r28
    1a7c:	6c 5f       	subi	r22, 0xFC	; 252
    1a7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a80:	ce 01       	movw	r24, r28
    1a82:	01 96       	adiw	r24, 0x01	; 1
    1a84:	0e 94 6f 09 	call	0x12de	; 0x12de <xTaskCheckForTimeOut>
    1a88:	81 11       	cpse	r24, r1
    1a8a:	21 c0       	rjmp	.+66     	; 0x1ace <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	f8 94       	cli
    1a90:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a92:	f8 01       	movw	r30, r16
    1a94:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a9a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a9c:	98 13       	cpse	r25, r24
    1a9e:	11 c0       	rjmp	.+34     	; 0x1ac2 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1aa0:	6c 81       	ldd	r22, Y+4	; 0x04
    1aa2:	7d 81       	ldd	r23, Y+5	; 0x05
    1aa4:	c5 01       	movw	r24, r10
    1aa6:	0e 94 bb 08 	call	0x1176	; 0x1176 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1aaa:	c8 01       	movw	r24, r16
    1aac:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1ab0:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1ab4:	88 23       	and	r24, r24
    1ab6:	11 f0       	breq	.+4      	; 0x1abc <xQueueGenericSend+0xf0>
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	a0 cf       	rjmp	.-192    	; 0x19fc <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1abc:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    1ac0:	fb cf       	rjmp	.-10     	; 0x1ab8 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ac2:	c8 01       	movw	r24, r16
    1ac4:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ac8:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1acc:	f5 cf       	rjmp	.-22     	; 0x1ab8 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1ace:	c8 01       	movw	r24, r16
    1ad0:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ad4:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ad8:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1ada:	0f 90       	pop	r0
    1adc:	0f 90       	pop	r0
    1ade:	0f 90       	pop	r0
    1ae0:	0f 90       	pop	r0
    1ae2:	0f 90       	pop	r0
    1ae4:	df 91       	pop	r29
    1ae6:	cf 91       	pop	r28
    1ae8:	1f 91       	pop	r17
    1aea:	0f 91       	pop	r16
    1aec:	ff 90       	pop	r15
    1aee:	df 90       	pop	r13
    1af0:	cf 90       	pop	r12
    1af2:	bf 90       	pop	r11
    1af4:	af 90       	pop	r10
    1af6:	08 95       	ret

00001af8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1af8:	ef 92       	push	r14
    1afa:	ff 92       	push	r15
    1afc:	1f 93       	push	r17
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1b04:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b06:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b08:	98 17       	cp	r25, r24
    1b0a:	10 f0       	brcs	.+4      	; 0x1b10 <xQueueGenericSendFromISR+0x18>
    1b0c:	22 30       	cpi	r18, 0x02	; 2
    1b0e:	e1 f4       	brne	.+56     	; 0x1b48 <xQueueGenericSendFromISR+0x50>
    1b10:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1b12:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b14:	42 2f       	mov	r20, r18
    1b16:	ce 01       	movw	r24, r28
    1b18:	0e 94 df 0b 	call	0x17be	; 0x17be <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1b1c:	1f 3f       	cpi	r17, 0xFF	; 255
    1b1e:	81 f4       	brne	.+32     	; 0x1b40 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b20:	89 89       	ldd	r24, Y+17	; 0x11
    1b22:	88 23       	and	r24, r24
    1b24:	79 f0       	breq	.+30     	; 0x1b44 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b26:	ce 01       	movw	r24, r28
    1b28:	41 96       	adiw	r24, 0x11	; 17
    1b2a:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1b2e:	88 23       	and	r24, r24
    1b30:	49 f0       	breq	.+18     	; 0x1b44 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b32:	e1 14       	cp	r14, r1
    1b34:	f1 04       	cpc	r15, r1
    1b36:	31 f0       	breq	.+12     	; 0x1b44 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	f7 01       	movw	r30, r14
    1b3c:	80 83       	st	Z, r24
    1b3e:	05 c0       	rjmp	.+10     	; 0x1b4a <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b40:	1f 5f       	subi	r17, 0xFF	; 255
    1b42:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1b44:	81 e0       	ldi	r24, 0x01	; 1
    1b46:	01 c0       	rjmp	.+2      	; 0x1b4a <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b48:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b4a:	df 91       	pop	r29
    1b4c:	cf 91       	pop	r28
    1b4e:	1f 91       	pop	r17
    1b50:	ff 90       	pop	r15
    1b52:	ef 90       	pop	r14
    1b54:	08 95       	ret

00001b56 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1b56:	cf 93       	push	r28
    1b58:	df 93       	push	r29
    1b5a:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b5c:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1b5e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b60:	98 17       	cp	r25, r24
    1b62:	c0 f4       	brcc	.+48     	; 0x1b94 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1b64:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1b66:	9f 5f       	subi	r25, 0xFF	; 255
    1b68:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1b6a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b6c:	79 f4       	brne	.+30     	; 0x1b8c <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b6e:	81 89       	ldd	r24, Z+17	; 0x11
    1b70:	88 23       	and	r24, r24
    1b72:	71 f0       	breq	.+28     	; 0x1b90 <xQueueGiveFromISR+0x3a>
    1b74:	eb 01       	movw	r28, r22
    1b76:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b78:	41 96       	adiw	r24, 0x11	; 17
    1b7a:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1b7e:	88 23       	and	r24, r24
    1b80:	39 f0       	breq	.+14     	; 0x1b90 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b82:	20 97       	sbiw	r28, 0x00	; 0
    1b84:	29 f0       	breq	.+10     	; 0x1b90 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b86:	81 e0       	ldi	r24, 0x01	; 1
    1b88:	88 83       	st	Y, r24
    1b8a:	05 c0       	rjmp	.+10     	; 0x1b96 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b8c:	8f 5f       	subi	r24, 0xFF	; 255
    1b8e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	01 c0       	rjmp	.+2      	; 0x1b96 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b94:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	08 95       	ret

00001b9c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1b9c:	af 92       	push	r10
    1b9e:	bf 92       	push	r11
    1ba0:	cf 92       	push	r12
    1ba2:	df 92       	push	r13
    1ba4:	ff 92       	push	r15
    1ba6:	0f 93       	push	r16
    1ba8:	1f 93       	push	r17
    1baa:	cf 93       	push	r28
    1bac:	df 93       	push	r29
    1bae:	00 d0       	rcall	.+0      	; 0x1bb0 <xQueueReceive+0x14>
    1bb0:	00 d0       	rcall	.+0      	; 0x1bb2 <xQueueReceive+0x16>
    1bb2:	1f 92       	push	r1
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
    1bb8:	8c 01       	movw	r16, r24
    1bba:	6b 01       	movw	r12, r22
    1bbc:	5d 83       	std	Y+5, r21	; 0x05
    1bbe:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bc2:	58 01       	movw	r10, r16
    1bc4:	91 e1       	ldi	r25, 0x11	; 17
    1bc6:	a9 0e       	add	r10, r25
    1bc8:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1bca:	0f b6       	in	r0, 0x3f	; 63
    1bcc:	f8 94       	cli
    1bce:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bd0:	f8 01       	movw	r30, r16
    1bd2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bd4:	ff 20       	and	r15, r15
    1bd6:	a9 f0       	breq	.+42     	; 0x1c02 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bd8:	b6 01       	movw	r22, r12
    1bda:	c8 01       	movw	r24, r16
    1bdc:	0e 94 27 0c 	call	0x184e	; 0x184e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1be0:	fa 94       	dec	r15
    1be2:	f8 01       	movw	r30, r16
    1be4:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1be6:	80 85       	ldd	r24, Z+8	; 0x08
    1be8:	88 23       	and	r24, r24
    1bea:	39 f0       	breq	.+14     	; 0x1bfa <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bec:	c8 01       	movw	r24, r16
    1bee:	08 96       	adiw	r24, 0x08	; 8
    1bf0:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1bf4:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1bf6:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1bfa:	0f 90       	pop	r0
    1bfc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	50 c0       	rjmp	.+160    	; 0x1ca2 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c02:	2c 81       	ldd	r18, Y+4	; 0x04
    1c04:	3d 81       	ldd	r19, Y+5	; 0x05
    1c06:	23 2b       	or	r18, r19
    1c08:	19 f4       	brne	.+6      	; 0x1c10 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c0a:	0f 90       	pop	r0
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	48 c0       	rjmp	.+144    	; 0x1ca0 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1c10:	81 11       	cpse	r24, r1
    1c12:	04 c0       	rjmp	.+8      	; 0x1c1c <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1c14:	ce 01       	movw	r24, r28
    1c16:	01 96       	adiw	r24, 0x01	; 1
    1c18:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c1c:	0f 90       	pop	r0
    1c1e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c20:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	0f 92       	push	r0
    1c2a:	f8 01       	movw	r30, r16
    1c2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c2e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c30:	09 f4       	brne	.+2      	; 0x1c34 <xQueueReceive+0x98>
    1c32:	15 8e       	std	Z+29, r1	; 0x1d
    1c34:	f8 01       	movw	r30, r16
    1c36:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c38:	8f 3f       	cpi	r24, 0xFF	; 255
    1c3a:	09 f4       	brne	.+2      	; 0x1c3e <xQueueReceive+0xa2>
    1c3c:	16 8e       	std	Z+30, r1	; 0x1e
    1c3e:	0f 90       	pop	r0
    1c40:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c42:	be 01       	movw	r22, r28
    1c44:	6c 5f       	subi	r22, 0xFC	; 252
    1c46:	7f 4f       	sbci	r23, 0xFF	; 255
    1c48:	ce 01       	movw	r24, r28
    1c4a:	01 96       	adiw	r24, 0x01	; 1
    1c4c:	0e 94 6f 09 	call	0x12de	; 0x12de <xTaskCheckForTimeOut>
    1c50:	81 11       	cpse	r24, r1
    1c52:	1c c0       	rjmp	.+56     	; 0x1c8c <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c54:	c8 01       	movw	r24, r16
    1c56:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvIsQueueEmpty>
    1c5a:	88 23       	and	r24, r24
    1c5c:	89 f0       	breq	.+34     	; 0x1c80 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c5e:	6c 81       	ldd	r22, Y+4	; 0x04
    1c60:	7d 81       	ldd	r23, Y+5	; 0x05
    1c62:	c5 01       	movw	r24, r10
    1c64:	0e 94 bb 08 	call	0x1176	; 0x1176 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c68:	c8 01       	movw	r24, r16
    1c6a:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c6e:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1c72:	88 23       	and	r24, r24
    1c74:	11 f0       	breq	.+4      	; 0x1c7a <xQueueReceive+0xde>
    1c76:	81 e0       	ldi	r24, 0x01	; 1
    1c78:	a8 cf       	rjmp	.-176    	; 0x1bca <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1c7a:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    1c7e:	fb cf       	rjmp	.-10     	; 0x1c76 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1c80:	c8 01       	movw	r24, r16
    1c82:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c86:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1c8a:	f5 cf       	rjmp	.-22     	; 0x1c76 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1c8c:	c8 01       	movw	r24, r16
    1c8e:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c92:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c96:	c8 01       	movw	r24, r16
    1c98:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvIsQueueEmpty>
    1c9c:	88 23       	and	r24, r24
    1c9e:	59 f3       	breq	.-42     	; 0x1c76 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ca0:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1ca2:	0f 90       	pop	r0
    1ca4:	0f 90       	pop	r0
    1ca6:	0f 90       	pop	r0
    1ca8:	0f 90       	pop	r0
    1caa:	0f 90       	pop	r0
    1cac:	df 91       	pop	r29
    1cae:	cf 91       	pop	r28
    1cb0:	1f 91       	pop	r17
    1cb2:	0f 91       	pop	r16
    1cb4:	ff 90       	pop	r15
    1cb6:	df 90       	pop	r13
    1cb8:	cf 90       	pop	r12
    1cba:	bf 90       	pop	r11
    1cbc:	af 90       	pop	r10
    1cbe:	08 95       	ret

00001cc0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1cc0:	ef 92       	push	r14
    1cc2:	ff 92       	push	r15
    1cc4:	0f 93       	push	r16
    1cc6:	1f 93       	push	r17
    1cc8:	cf 93       	push	r28
    1cca:	df 93       	push	r29
    1ccc:	00 d0       	rcall	.+0      	; 0x1cce <xQueueSemaphoreTake+0xe>
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <xQueueSemaphoreTake+0x10>
    1cd0:	1f 92       	push	r1
    1cd2:	cd b7       	in	r28, 0x3d	; 61
    1cd4:	de b7       	in	r29, 0x3e	; 62
    1cd6:	8c 01       	movw	r16, r24
    1cd8:	7d 83       	std	Y+5, r23	; 0x05
    1cda:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1cdc:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1cde:	78 01       	movw	r14, r16
    1ce0:	81 e1       	ldi	r24, 0x11	; 17
    1ce2:	e8 0e       	add	r14, r24
    1ce4:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1ce6:	0f b6       	in	r0, 0x3f	; 63
    1ce8:	f8 94       	cli
    1cea:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1cec:	f8 01       	movw	r30, r16
    1cee:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1cf0:	88 23       	and	r24, r24
    1cf2:	81 f0       	breq	.+32     	; 0x1d14 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1cf4:	81 50       	subi	r24, 0x01	; 1
    1cf6:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cf8:	80 85       	ldd	r24, Z+8	; 0x08
    1cfa:	88 23       	and	r24, r24
    1cfc:	39 f0       	breq	.+14     	; 0x1d0c <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cfe:	c8 01       	movw	r24, r16
    1d00:	08 96       	adiw	r24, 0x08	; 8
    1d02:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1d06:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1d08:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1d0c:	0f 90       	pop	r0
    1d0e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1d10:	81 e0       	ldi	r24, 0x01	; 1
    1d12:	50 c0       	rjmp	.+160    	; 0x1db4 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1d14:	2c 81       	ldd	r18, Y+4	; 0x04
    1d16:	3d 81       	ldd	r19, Y+5	; 0x05
    1d18:	23 2b       	or	r18, r19
    1d1a:	19 f4       	brne	.+6      	; 0x1d22 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1d1c:	0f 90       	pop	r0
    1d1e:	0f be       	out	0x3f, r0	; 63
    1d20:	48 c0       	rjmp	.+144    	; 0x1db2 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1d22:	91 11       	cpse	r25, r1
    1d24:	04 c0       	rjmp	.+8      	; 0x1d2e <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1d26:	ce 01       	movw	r24, r28
    1d28:	01 96       	adiw	r24, 0x01	; 1
    1d2a:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d32:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d36:	0f b6       	in	r0, 0x3f	; 63
    1d38:	f8 94       	cli
    1d3a:	0f 92       	push	r0
    1d3c:	f8 01       	movw	r30, r16
    1d3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d40:	8f 3f       	cpi	r24, 0xFF	; 255
    1d42:	09 f4       	brne	.+2      	; 0x1d46 <xQueueSemaphoreTake+0x86>
    1d44:	15 8e       	std	Z+29, r1	; 0x1d
    1d46:	f8 01       	movw	r30, r16
    1d48:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4c:	09 f4       	brne	.+2      	; 0x1d50 <xQueueSemaphoreTake+0x90>
    1d4e:	16 8e       	std	Z+30, r1	; 0x1e
    1d50:	0f 90       	pop	r0
    1d52:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d54:	be 01       	movw	r22, r28
    1d56:	6c 5f       	subi	r22, 0xFC	; 252
    1d58:	7f 4f       	sbci	r23, 0xFF	; 255
    1d5a:	ce 01       	movw	r24, r28
    1d5c:	01 96       	adiw	r24, 0x01	; 1
    1d5e:	0e 94 6f 09 	call	0x12de	; 0x12de <xTaskCheckForTimeOut>
    1d62:	81 11       	cpse	r24, r1
    1d64:	1c c0       	rjmp	.+56     	; 0x1d9e <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d66:	c8 01       	movw	r24, r16
    1d68:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvIsQueueEmpty>
    1d6c:	88 23       	and	r24, r24
    1d6e:	89 f0       	breq	.+34     	; 0x1d92 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d70:	6c 81       	ldd	r22, Y+4	; 0x04
    1d72:	7d 81       	ldd	r23, Y+5	; 0x05
    1d74:	c7 01       	movw	r24, r14
    1d76:	0e 94 bb 08 	call	0x1176	; 0x1176 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d7a:	c8 01       	movw	r24, r16
    1d7c:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d80:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1d84:	88 23       	and	r24, r24
    1d86:	11 f0       	breq	.+4      	; 0x1d8c <xQueueSemaphoreTake+0xcc>
    1d88:	91 e0       	ldi	r25, 0x01	; 1
    1d8a:	ad cf       	rjmp	.-166    	; 0x1ce6 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1d8c:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    1d90:	fb cf       	rjmp	.-10     	; 0x1d88 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1d92:	c8 01       	movw	r24, r16
    1d94:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d98:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1d9c:	f5 cf       	rjmp	.-22     	; 0x1d88 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1d9e:	c8 01       	movw	r24, r16
    1da0:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1da4:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1da8:	c8 01       	movw	r24, r16
    1daa:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvIsQueueEmpty>
    1dae:	88 23       	and	r24, r24
    1db0:	59 f3       	breq	.-42     	; 0x1d88 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1db2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1db4:	0f 90       	pop	r0
    1db6:	0f 90       	pop	r0
    1db8:	0f 90       	pop	r0
    1dba:	0f 90       	pop	r0
    1dbc:	0f 90       	pop	r0
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	1f 91       	pop	r17
    1dc4:	0f 91       	pop	r16
    1dc6:	ff 90       	pop	r15
    1dc8:	ef 90       	pop	r14
    1dca:	08 95       	ret

00001dcc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1dcc:	cf 92       	push	r12
    1dce:	df 92       	push	r13
    1dd0:	ef 92       	push	r14
    1dd2:	ff 92       	push	r15
    1dd4:	0f 93       	push	r16
    1dd6:	1f 93       	push	r17
    1dd8:	cf 93       	push	r28
    1dda:	df 93       	push	r29
    1ddc:	00 d0       	rcall	.+0      	; 0x1dde <xQueuePeek+0x12>
    1dde:	00 d0       	rcall	.+0      	; 0x1de0 <xQueuePeek+0x14>
    1de0:	1f 92       	push	r1
    1de2:	cd b7       	in	r28, 0x3d	; 61
    1de4:	de b7       	in	r29, 0x3e	; 62
    1de6:	8c 01       	movw	r16, r24
    1de8:	7b 01       	movw	r14, r22
    1dea:	5d 83       	std	Y+5, r21	; 0x05
    1dec:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1dee:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1df0:	68 01       	movw	r12, r16
    1df2:	91 e1       	ldi	r25, 0x11	; 17
    1df4:	c9 0e       	add	r12, r25
    1df6:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	f8 94       	cli
    1dfc:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1dfe:	f8 01       	movw	r30, r16
    1e00:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e02:	99 23       	and	r25, r25
    1e04:	b9 f0       	breq	.+46     	; 0x1e34 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1e06:	c6 80       	ldd	r12, Z+6	; 0x06
    1e08:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e0a:	b7 01       	movw	r22, r14
    1e0c:	c8 01       	movw	r24, r16
    1e0e:	0e 94 27 0c 	call	0x184e	; 0x184e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1e12:	f8 01       	movw	r30, r16
    1e14:	d7 82       	std	Z+7, r13	; 0x07
    1e16:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e18:	81 89       	ldd	r24, Z+17	; 0x11
    1e1a:	88 23       	and	r24, r24
    1e1c:	39 f0       	breq	.+14     	; 0x1e2c <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e1e:	c8 01       	movw	r24, r16
    1e20:	41 96       	adiw	r24, 0x11	; 17
    1e22:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1e26:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1e28:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e30:	81 e0       	ldi	r24, 0x01	; 1
    1e32:	50 c0       	rjmp	.+160    	; 0x1ed4 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e34:	2c 81       	ldd	r18, Y+4	; 0x04
    1e36:	3d 81       	ldd	r19, Y+5	; 0x05
    1e38:	23 2b       	or	r18, r19
    1e3a:	19 f4       	brne	.+6      	; 0x1e42 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e3c:	0f 90       	pop	r0
    1e3e:	0f be       	out	0x3f, r0	; 63
    1e40:	48 c0       	rjmp	.+144    	; 0x1ed2 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1e42:	81 11       	cpse	r24, r1
    1e44:	04 c0       	rjmp	.+8      	; 0x1e4e <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1e46:	ce 01       	movw	r24, r28
    1e48:	01 96       	adiw	r24, 0x01	; 1
    1e4a:	0e 94 64 09 	call	0x12c8	; 0x12c8 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e4e:	0f 90       	pop	r0
    1e50:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e52:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e56:	0f b6       	in	r0, 0x3f	; 63
    1e58:	f8 94       	cli
    1e5a:	0f 92       	push	r0
    1e5c:	f8 01       	movw	r30, r16
    1e5e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e60:	8f 3f       	cpi	r24, 0xFF	; 255
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <xQueuePeek+0x9a>
    1e64:	15 8e       	std	Z+29, r1	; 0x1d
    1e66:	f8 01       	movw	r30, r16
    1e68:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e6a:	8f 3f       	cpi	r24, 0xFF	; 255
    1e6c:	09 f4       	brne	.+2      	; 0x1e70 <xQueuePeek+0xa4>
    1e6e:	16 8e       	std	Z+30, r1	; 0x1e
    1e70:	0f 90       	pop	r0
    1e72:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e74:	be 01       	movw	r22, r28
    1e76:	6c 5f       	subi	r22, 0xFC	; 252
    1e78:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7a:	ce 01       	movw	r24, r28
    1e7c:	01 96       	adiw	r24, 0x01	; 1
    1e7e:	0e 94 6f 09 	call	0x12de	; 0x12de <xTaskCheckForTimeOut>
    1e82:	81 11       	cpse	r24, r1
    1e84:	1c c0       	rjmp	.+56     	; 0x1ebe <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e86:	c8 01       	movw	r24, r16
    1e88:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvIsQueueEmpty>
    1e8c:	88 23       	and	r24, r24
    1e8e:	89 f0       	breq	.+34     	; 0x1eb2 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e90:	6c 81       	ldd	r22, Y+4	; 0x04
    1e92:	7d 81       	ldd	r23, Y+5	; 0x05
    1e94:	c6 01       	movw	r24, r12
    1e96:	0e 94 bb 08 	call	0x1176	; 0x1176 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e9a:	c8 01       	movw	r24, r16
    1e9c:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ea0:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1ea4:	88 23       	and	r24, r24
    1ea6:	11 f0       	breq	.+4      	; 0x1eac <xQueuePeek+0xe0>
    1ea8:	81 e0       	ldi	r24, 0x01	; 1
    1eaa:	a6 cf       	rjmp	.-180    	; 0x1df8 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1eac:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vPortYield>
    1eb0:	fb cf       	rjmp	.-10     	; 0x1ea8 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1eb2:	c8 01       	movw	r24, r16
    1eb4:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1eb8:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
    1ebc:	f5 cf       	rjmp	.-22     	; 0x1ea8 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1ebe:	c8 01       	movw	r24, r16
    1ec0:	0e 94 41 0c 	call	0x1882	; 0x1882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ec4:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ec8:	c8 01       	movw	r24, r16
    1eca:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvIsQueueEmpty>
    1ece:	88 23       	and	r24, r24
    1ed0:	59 f3       	breq	.-42     	; 0x1ea8 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ed2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1ed4:	0f 90       	pop	r0
    1ed6:	0f 90       	pop	r0
    1ed8:	0f 90       	pop	r0
    1eda:	0f 90       	pop	r0
    1edc:	0f 90       	pop	r0
    1ede:	df 91       	pop	r29
    1ee0:	cf 91       	pop	r28
    1ee2:	1f 91       	pop	r17
    1ee4:	0f 91       	pop	r16
    1ee6:	ff 90       	pop	r15
    1ee8:	ef 90       	pop	r14
    1eea:	df 90       	pop	r13
    1eec:	cf 90       	pop	r12
    1eee:	08 95       	ret

00001ef0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1ef0:	ef 92       	push	r14
    1ef2:	ff 92       	push	r15
    1ef4:	0f 93       	push	r16
    1ef6:	1f 93       	push	r17
    1ef8:	cf 93       	push	r28
    1efa:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1efc:	fc 01       	movw	r30, r24
    1efe:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f00:	00 23       	and	r16, r16
    1f02:	e9 f0       	breq	.+58     	; 0x1f3e <xQueueReceiveFromISR+0x4e>
    1f04:	7a 01       	movw	r14, r20
    1f06:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1f08:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f0a:	0e 94 27 0c 	call	0x184e	; 0x184e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1f0e:	01 50       	subi	r16, 0x01	; 1
    1f10:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1f12:	1f 3f       	cpi	r17, 0xFF	; 255
    1f14:	81 f4       	brne	.+32     	; 0x1f36 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f16:	88 85       	ldd	r24, Y+8	; 0x08
    1f18:	88 23       	and	r24, r24
    1f1a:	79 f0       	breq	.+30     	; 0x1f3a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f1c:	ce 01       	movw	r24, r28
    1f1e:	08 96       	adiw	r24, 0x08	; 8
    1f20:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <xTaskRemoveFromEventList>
    1f24:	88 23       	and	r24, r24
    1f26:	49 f0       	breq	.+18     	; 0x1f3a <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1f28:	e1 14       	cp	r14, r1
    1f2a:	f1 04       	cpc	r15, r1
    1f2c:	31 f0       	breq	.+12     	; 0x1f3a <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	f7 01       	movw	r30, r14
    1f32:	80 83       	st	Z, r24
    1f34:	05 c0       	rjmp	.+10     	; 0x1f40 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1f36:	1f 5f       	subi	r17, 0xFF	; 255
    1f38:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	01 c0       	rjmp	.+2      	; 0x1f40 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f40:	df 91       	pop	r29
    1f42:	cf 91       	pop	r28
    1f44:	1f 91       	pop	r17
    1f46:	0f 91       	pop	r16
    1f48:	ff 90       	pop	r15
    1f4a:	ef 90       	pop	r14
    1f4c:	08 95       	ret

00001f4e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1f4e:	0f 93       	push	r16
    1f50:	1f 93       	push	r17
    1f52:	cf 93       	push	r28
    1f54:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f56:	fc 01       	movw	r30, r24
    1f58:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f5a:	22 23       	and	r18, r18
    1f5c:	49 f0       	breq	.+18     	; 0x1f70 <xQueuePeekFromISR+0x22>
    1f5e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1f60:	06 81       	ldd	r16, Z+6	; 0x06
    1f62:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f64:	0e 94 27 0c 	call	0x184e	; 0x184e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1f68:	1f 83       	std	Y+7, r17	; 0x07
    1f6a:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
    1f6e:	01 c0       	rjmp	.+2      	; 0x1f72 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1f70:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f72:	df 91       	pop	r29
    1f74:	cf 91       	pop	r28
    1f76:	1f 91       	pop	r17
    1f78:	0f 91       	pop	r16
    1f7a:	08 95       	ret

00001f7c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1f7c:	0f b6       	in	r0, 0x3f	; 63
    1f7e:	f8 94       	cli
    1f80:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1f82:	fc 01       	movw	r30, r24
    1f84:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1f86:	0f 90       	pop	r0
    1f88:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1f8a:	08 95       	ret

00001f8c <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1f8c:	0f b6       	in	r0, 0x3f	; 63
    1f8e:	f8 94       	cli
    1f90:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1f92:	fc 01       	movw	r30, r24
    1f94:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1f96:	0f 90       	pop	r0
    1f98:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1f9a:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1f9c:	82 1b       	sub	r24, r18
    1f9e:	08 95       	ret

00001fa0 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1fa0:	fc 01       	movw	r30, r24
    1fa2:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1fa4:	08 95       	ret

00001fa6 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1fa6:	0c 94 47 13 	jmp	0x268e	; 0x268e <vPortFree>

00001faa <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1faa:	fc 01       	movw	r30, r24
    1fac:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	91 11       	cpse	r25, r1
    1fb2:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1fb4:	08 95       	ret

00001fb6 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1fb6:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1fb8:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1fba:	81 e0       	ldi	r24, 0x01	; 1
    1fbc:	23 8d       	ldd	r18, Z+27	; 0x1b
    1fbe:	29 13       	cpse	r18, r25
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1fc2:	08 95       	ret

00001fc4 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1fc4:	cf 93       	push	r28
    1fc6:	df 93       	push	r29
    1fc8:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1fca:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1fcc:	0f b6       	in	r0, 0x3f	; 63
    1fce:	f8 94       	cli
    1fd0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1fd2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fd4:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1fd6:	0f 90       	pop	r0
    1fd8:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1fda:	89 13       	cpse	r24, r25
    1fdc:	0f c0       	rjmp	.+30     	; 0x1ffc <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1fde:	41 15       	cp	r20, r1
    1fe0:	51 05       	cpc	r21, r1
    1fe2:	49 f0       	breq	.+18     	; 0x1ff6 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1fe4:	be 01       	movw	r22, r28
    1fe6:	68 5f       	subi	r22, 0xF8	; 248
    1fe8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fea:	ca 01       	movw	r24, r20
    1fec:	0e 94 c1 11 	call	0x2382	; 0x2382 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1ff0:	78 94       	sei
					return errQUEUE_BLOCKED;
    1ff2:	8c ef       	ldi	r24, 0xFC	; 252
    1ff4:	1b c0       	rjmp	.+54     	; 0x202c <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1ff6:	78 94       	sei
					return errQUEUE_FULL;
    1ff8:	80 e0       	ldi	r24, 0x00	; 0
    1ffa:	18 c0       	rjmp	.+48     	; 0x202c <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1ffc:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1ffe:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2000:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2002:	89 17       	cp	r24, r25
    2004:	88 f4       	brcc	.+34     	; 0x2028 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2006:	40 e0       	ldi	r20, 0x00	; 0
    2008:	ce 01       	movw	r24, r28
    200a:	0e 94 df 0b 	call	0x17be	; 0x17be <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    200e:	89 89       	ldd	r24, Y+17	; 0x11
    2010:	81 11       	cpse	r24, r1
    2012:	02 c0       	rjmp	.+4      	; 0x2018 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	09 c0       	rjmp	.+18     	; 0x202a <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2018:	ce 01       	movw	r24, r28
    201a:	41 96       	adiw	r24, 0x11	; 17
    201c:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <xCoRoutineRemoveFromEventList>
    2020:	88 23       	and	r24, r24
    2022:	c1 f3       	breq	.-16     	; 0x2014 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    2024:	8b ef       	ldi	r24, 0xFB	; 251
    2026:	01 c0       	rjmp	.+2      	; 0x202a <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    2028:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    202a:	78 94       	sei

		return xReturn;
	}
    202c:	df 91       	pop	r29
    202e:	cf 91       	pop	r28
    2030:	08 95       	ret

00002032 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    2032:	cf 93       	push	r28
    2034:	df 93       	push	r29
    2036:	ec 01       	movw	r28, r24
    2038:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    203a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    203c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    203e:	81 11       	cpse	r24, r1
    2040:	0f c0       	rjmp	.+30     	; 0x2060 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2042:	41 15       	cp	r20, r1
    2044:	51 05       	cpc	r21, r1
    2046:	49 f0       	breq	.+18     	; 0x205a <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2048:	be 01       	movw	r22, r28
    204a:	6f 5e       	subi	r22, 0xEF	; 239
    204c:	7f 4f       	sbci	r23, 0xFF	; 255
    204e:	ca 01       	movw	r24, r20
    2050:	0e 94 c1 11 	call	0x2382	; 0x2382 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    2054:	78 94       	sei
					return errQUEUE_BLOCKED;
    2056:	8c ef       	ldi	r24, 0xFC	; 252
    2058:	30 c0       	rjmp	.+96     	; 0x20ba <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    205a:	78 94       	sei
					return errQUEUE_FULL;
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	2d c0       	rjmp	.+90     	; 0x20ba <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    2060:	78 94       	sei

		portDISABLE_INTERRUPTS();
    2062:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2064:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2066:	88 23       	and	r24, r24
    2068:	31 f1       	breq	.+76     	; 0x20b6 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    206a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    206c:	50 e0       	ldi	r21, 0x00	; 0
    206e:	2e 81       	ldd	r18, Y+6	; 0x06
    2070:	3f 81       	ldd	r19, Y+7	; 0x07
    2072:	24 0f       	add	r18, r20
    2074:	35 1f       	adc	r19, r21
    2076:	3f 83       	std	Y+7, r19	; 0x07
    2078:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    207a:	8c 81       	ldd	r24, Y+4	; 0x04
    207c:	9d 81       	ldd	r25, Y+5	; 0x05
    207e:	28 17       	cp	r18, r24
    2080:	39 07       	cpc	r19, r25
    2082:	20 f0       	brcs	.+8      	; 0x208c <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2084:	88 81       	ld	r24, Y
    2086:	99 81       	ldd	r25, Y+1	; 0x01
    2088:	9f 83       	std	Y+7, r25	; 0x07
    208a:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    208c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    208e:	91 50       	subi	r25, 0x01	; 1
    2090:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2092:	6e 81       	ldd	r22, Y+6	; 0x06
    2094:	7f 81       	ldd	r23, Y+7	; 0x07
    2096:	cf 01       	movw	r24, r30
    2098:	0e 94 4c 2a 	call	0x5498	; 0x5498 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    209c:	88 85       	ldd	r24, Y+8	; 0x08
    209e:	81 11       	cpse	r24, r1
    20a0:	02 c0       	rjmp	.+4      	; 0x20a6 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	09 c0       	rjmp	.+18     	; 0x20b8 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20a6:	ce 01       	movw	r24, r28
    20a8:	08 96       	adiw	r24, 0x08	; 8
    20aa:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <xCoRoutineRemoveFromEventList>
    20ae:	88 23       	and	r24, r24
    20b0:	c1 f3       	breq	.-16     	; 0x20a2 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    20b2:	8b ef       	ldi	r24, 0xFB	; 251
    20b4:	01 c0       	rjmp	.+2      	; 0x20b8 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    20b6:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    20b8:	78 94       	sei

		return xReturn;
	}
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	08 95       	ret

000020c0 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    20c0:	0f 93       	push	r16
    20c2:	1f 93       	push	r17
    20c4:	cf 93       	push	r28
    20c6:	8c 01       	movw	r16, r24
    20c8:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20ca:	fc 01       	movw	r30, r24
    20cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    20ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    20d0:	98 17       	cp	r25, r24
    20d2:	10 f0       	brcs	.+4      	; 0x20d8 <xQueueCRSendFromISR+0x18>
    20d4:	4c 2f       	mov	r20, r28
    20d6:	12 c0       	rjmp	.+36     	; 0x20fc <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    20d8:	40 e0       	ldi	r20, 0x00	; 0
    20da:	c8 01       	movw	r24, r16
    20dc:	0e 94 df 0b 	call	0x17be	; 0x17be <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    20e0:	c1 11       	cpse	r28, r1
    20e2:	f8 cf       	rjmp	.-16     	; 0x20d4 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20e4:	f8 01       	movw	r30, r16
    20e6:	81 89       	ldd	r24, Z+17	; 0x11
    20e8:	88 23       	and	r24, r24
    20ea:	39 f0       	breq	.+14     	; 0x20fa <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ec:	c8 01       	movw	r24, r16
    20ee:	41 96       	adiw	r24, 0x11	; 17
    20f0:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    20f4:	41 e0       	ldi	r20, 0x01	; 1
    20f6:	81 11       	cpse	r24, r1
    20f8:	01 c0       	rjmp	.+2      	; 0x20fc <xQueueCRSendFromISR+0x3c>
    20fa:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    20fc:	84 2f       	mov	r24, r20
    20fe:	cf 91       	pop	r28
    2100:	1f 91       	pop	r17
    2102:	0f 91       	pop	r16
    2104:	08 95       	ret

00002106 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    2106:	0f 93       	push	r16
    2108:	1f 93       	push	r17
    210a:	cf 93       	push	r28
    210c:	df 93       	push	r29
    210e:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2110:	82 8d       	ldd	r24, Z+26	; 0x1a
    2112:	88 23       	and	r24, r24
    2114:	79 f1       	breq	.+94     	; 0x2174 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2116:	24 8d       	ldd	r18, Z+28	; 0x1c
    2118:	30 e0       	ldi	r19, 0x00	; 0
    211a:	a6 81       	ldd	r26, Z+6	; 0x06
    211c:	b7 81       	ldd	r27, Z+7	; 0x07
    211e:	a2 0f       	add	r26, r18
    2120:	b3 1f       	adc	r27, r19
    2122:	b7 83       	std	Z+7, r27	; 0x07
    2124:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2126:	84 81       	ldd	r24, Z+4	; 0x04
    2128:	95 81       	ldd	r25, Z+5	; 0x05
    212a:	a8 17       	cp	r26, r24
    212c:	b9 07       	cpc	r27, r25
    212e:	20 f0       	brcs	.+8      	; 0x2138 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2130:	80 81       	ld	r24, Z
    2132:	91 81       	ldd	r25, Z+1	; 0x01
    2134:	97 83       	std	Z+7, r25	; 0x07
    2136:	86 83       	std	Z+6, r24	; 0x06
    2138:	8a 01       	movw	r16, r20
    213a:	cb 01       	movw	r24, r22
    213c:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    213e:	42 8d       	ldd	r20, Z+26	; 0x1a
    2140:	41 50       	subi	r20, 0x01	; 1
    2142:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2144:	66 81       	ldd	r22, Z+6	; 0x06
    2146:	77 81       	ldd	r23, Z+7	; 0x07
    2148:	a9 01       	movw	r20, r18
    214a:	0e 94 4c 2a 	call	0x5498	; 0x5498 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    214e:	f8 01       	movw	r30, r16
    2150:	80 81       	ld	r24, Z
    2152:	88 23       	and	r24, r24
    2154:	11 f0       	breq	.+4      	; 0x215a <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    2156:	81 e0       	ldi	r24, 0x01	; 1
    2158:	0e c0       	rjmp	.+28     	; 0x2176 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    215a:	88 85       	ldd	r24, Y+8	; 0x08
    215c:	88 23       	and	r24, r24
    215e:	d9 f3       	breq	.-10     	; 0x2156 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2160:	ce 01       	movw	r24, r28
    2162:	08 96       	adiw	r24, 0x08	; 8
    2164:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <xCoRoutineRemoveFromEventList>
    2168:	88 23       	and	r24, r24
    216a:	a9 f3       	breq	.-22     	; 0x2156 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	f8 01       	movw	r30, r16
    2170:	80 83       	st	Z, r24
    2172:	01 c0       	rjmp	.+2      	; 0x2176 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    2174:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	08 95       	ret

00002180 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2180:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2182:	03 96       	adiw	r24, 0x03	; 3
    2184:	92 83       	std	Z+2, r25	; 0x02
    2186:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2188:	2f ef       	ldi	r18, 0xFF	; 255
    218a:	3f ef       	ldi	r19, 0xFF	; 255
    218c:	34 83       	std	Z+4, r19	; 0x04
    218e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2190:	96 83       	std	Z+6, r25	; 0x06
    2192:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2194:	90 87       	std	Z+8, r25	; 0x08
    2196:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2198:	10 82       	st	Z, r1
    219a:	08 95       	ret

0000219c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    219c:	fc 01       	movw	r30, r24
    219e:	11 86       	std	Z+9, r1	; 0x09
    21a0:	10 86       	std	Z+8, r1	; 0x08
    21a2:	08 95       	ret

000021a4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    21a4:	cf 93       	push	r28
    21a6:	df 93       	push	r29
    21a8:	9c 01       	movw	r18, r24
    21aa:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    21ac:	dc 01       	movw	r26, r24
    21ae:	11 96       	adiw	r26, 0x01	; 1
    21b0:	cd 91       	ld	r28, X+
    21b2:	dc 91       	ld	r29, X
    21b4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    21b6:	d3 83       	std	Z+3, r29	; 0x03
    21b8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    21ba:	8c 81       	ldd	r24, Y+4	; 0x04
    21bc:	9d 81       	ldd	r25, Y+5	; 0x05
    21be:	95 83       	std	Z+5, r25	; 0x05
    21c0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    21c2:	8c 81       	ldd	r24, Y+4	; 0x04
    21c4:	9d 81       	ldd	r25, Y+5	; 0x05
    21c6:	dc 01       	movw	r26, r24
    21c8:	13 96       	adiw	r26, 0x03	; 3
    21ca:	7c 93       	st	X, r23
    21cc:	6e 93       	st	-X, r22
    21ce:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    21d0:	7d 83       	std	Y+5, r23	; 0x05
    21d2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    21d4:	31 87       	std	Z+9, r19	; 0x09
    21d6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    21d8:	f9 01       	movw	r30, r18
    21da:	80 81       	ld	r24, Z
    21dc:	8f 5f       	subi	r24, 0xFF	; 255
    21de:	80 83       	st	Z, r24
}
    21e0:	df 91       	pop	r29
    21e2:	cf 91       	pop	r28
    21e4:	08 95       	ret

000021e6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    21e6:	0f 93       	push	r16
    21e8:	1f 93       	push	r17
    21ea:	cf 93       	push	r28
    21ec:	df 93       	push	r29
    21ee:	8c 01       	movw	r16, r24
    21f0:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    21f2:	80 81       	ld	r24, Z
    21f4:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    21f6:	8f 3f       	cpi	r24, 0xFF	; 255
    21f8:	2f ef       	ldi	r18, 0xFF	; 255
    21fa:	92 07       	cpc	r25, r18
    21fc:	21 f4       	brne	.+8      	; 0x2206 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    21fe:	e8 01       	movw	r28, r16
    2200:	af 81       	ldd	r26, Y+7	; 0x07
    2202:	b8 85       	ldd	r27, Y+8	; 0x08
    2204:	0e c0       	rjmp	.+28     	; 0x2222 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2206:	d8 01       	movw	r26, r16
    2208:	13 96       	adiw	r26, 0x03	; 3
    220a:	12 96       	adiw	r26, 0x02	; 2
    220c:	2d 91       	ld	r18, X+
    220e:	3c 91       	ld	r19, X
    2210:	13 97       	sbiw	r26, 0x03	; 3
    2212:	e9 01       	movw	r28, r18
    2214:	48 81       	ld	r20, Y
    2216:	59 81       	ldd	r21, Y+1	; 0x01
    2218:	84 17       	cp	r24, r20
    221a:	95 07       	cpc	r25, r21
    221c:	10 f0       	brcs	.+4      	; 0x2222 <vListInsert+0x3c>
    221e:	d9 01       	movw	r26, r18
    2220:	f4 cf       	rjmp	.-24     	; 0x220a <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2222:	12 96       	adiw	r26, 0x02	; 2
    2224:	8d 91       	ld	r24, X+
    2226:	9c 91       	ld	r25, X
    2228:	13 97       	sbiw	r26, 0x03	; 3
    222a:	93 83       	std	Z+3, r25	; 0x03
    222c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    222e:	ec 01       	movw	r28, r24
    2230:	fd 83       	std	Y+5, r31	; 0x05
    2232:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2234:	b5 83       	std	Z+5, r27	; 0x05
    2236:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2238:	13 96       	adiw	r26, 0x03	; 3
    223a:	fc 93       	st	X, r31
    223c:	ee 93       	st	-X, r30
    223e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2240:	11 87       	std	Z+9, r17	; 0x09
    2242:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    2244:	f8 01       	movw	r30, r16
    2246:	80 81       	ld	r24, Z
    2248:	8f 5f       	subi	r24, 0xFF	; 255
    224a:	80 83       	st	Z, r24
}
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	1f 91       	pop	r17
    2252:	0f 91       	pop	r16
    2254:	08 95       	ret

00002256 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2256:	cf 93       	push	r28
    2258:	df 93       	push	r29
    225a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    225c:	a0 85       	ldd	r26, Z+8	; 0x08
    225e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2260:	82 81       	ldd	r24, Z+2	; 0x02
    2262:	93 81       	ldd	r25, Z+3	; 0x03
    2264:	24 81       	ldd	r18, Z+4	; 0x04
    2266:	35 81       	ldd	r19, Z+5	; 0x05
    2268:	ec 01       	movw	r28, r24
    226a:	3d 83       	std	Y+5, r19	; 0x05
    226c:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    226e:	c4 81       	ldd	r28, Z+4	; 0x04
    2270:	d5 81       	ldd	r29, Z+5	; 0x05
    2272:	9b 83       	std	Y+3, r25	; 0x03
    2274:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2276:	11 96       	adiw	r26, 0x01	; 1
    2278:	8d 91       	ld	r24, X+
    227a:	9c 91       	ld	r25, X
    227c:	12 97       	sbiw	r26, 0x02	; 2
    227e:	e8 17       	cp	r30, r24
    2280:	f9 07       	cpc	r31, r25
    2282:	21 f4       	brne	.+8      	; 0x228c <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2284:	12 96       	adiw	r26, 0x02	; 2
    2286:	dc 93       	st	X, r29
    2288:	ce 93       	st	-X, r28
    228a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    228c:	11 86       	std	Z+9, r1	; 0x09
    228e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2290:	8c 91       	ld	r24, X
    2292:	81 50       	subi	r24, 0x01	; 1
    2294:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    2296:	8c 91       	ld	r24, X
}
    2298:	df 91       	pop	r29
    229a:	cf 91       	pop	r28
    229c:	08 95       	ret

0000229e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    229e:	cf 92       	push	r12
    22a0:	df 92       	push	r13
    22a2:	ef 92       	push	r14
    22a4:	ff 92       	push	r15
    22a6:	1f 93       	push	r17
    22a8:	cf 93       	push	r28
    22aa:	df 93       	push	r29
    22ac:	6c 01       	movw	r12, r24
    22ae:	16 2f       	mov	r17, r22
    22b0:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    22b2:	8a e1       	ldi	r24, 0x1A	; 26
    22b4:	90 e0       	ldi	r25, 0x00	; 0
    22b6:	0e 94 15 13 	call	0x262a	; 0x262a <pvPortMalloc>
    22ba:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    22bc:	89 2b       	or	r24, r25
    22be:	09 f4       	brne	.+2      	; 0x22c2 <xCoRoutineCreate+0x24>
    22c0:	57 c0       	rjmp	.+174    	; 0x2370 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    22c2:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <pxCurrentCoRoutine>
    22c6:	90 91 eb 01 	lds	r25, 0x01EB	; 0x8001eb <pxCurrentCoRoutine+0x1>
    22ca:	89 2b       	or	r24, r25
    22cc:	21 f5       	brne	.+72     	; 0x2316 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    22ce:	d0 93 eb 01 	sts	0x01EB, r29	; 0x8001eb <pxCurrentCoRoutine+0x1>
    22d2:	c0 93 ea 01 	sts	0x01EA, r28	; 0x8001ea <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    22d6:	82 e1       	ldi	r24, 0x12	; 18
    22d8:	92 e0       	ldi	r25, 0x02	; 2
    22da:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
    22de:	8b e1       	ldi	r24, 0x1B	; 27
    22e0:	92 e0       	ldi	r25, 0x02	; 2
    22e2:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    22e6:	89 e0       	ldi	r24, 0x09	; 9
    22e8:	92 e0       	ldi	r25, 0x02	; 2
    22ea:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    22ee:	80 e0       	ldi	r24, 0x00	; 0
    22f0:	92 e0       	ldi	r25, 0x02	; 2
    22f2:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    22f6:	83 ef       	ldi	r24, 0xF3	; 243
    22f8:	91 e0       	ldi	r25, 0x01	; 1
    22fa:	0e 94 c0 10 	call	0x2180	; 0x2180 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    22fe:	89 e0       	ldi	r24, 0x09	; 9
    2300:	92 e0       	ldi	r25, 0x02	; 2
    2302:	90 93 ff 01 	sts	0x01FF, r25	; 0x8001ff <pxDelayedCoRoutineList+0x1>
    2306:	80 93 fe 01 	sts	0x01FE, r24	; 0x8001fe <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    230a:	80 e0       	ldi	r24, 0x00	; 0
    230c:	92 e0       	ldi	r25, 0x02	; 2
    230e:	90 93 fd 01 	sts	0x01FD, r25	; 0x8001fd <pxOverflowDelayedCoRoutineList+0x1>
    2312:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <pxOverflowDelayedCoRoutineList>
    2316:	11 11       	cpse	r17, r1
    2318:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    231a:	19 8e       	std	Y+25, r1	; 0x19
    231c:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    231e:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2320:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2322:	fe 01       	movw	r30, r28
    2324:	c1 92       	st	Z+, r12
    2326:	d1 92       	st	Z+, r13
    2328:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    232a:	cf 01       	movw	r24, r30
    232c:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2330:	ce 01       	movw	r24, r28
    2332:	0c 96       	adiw	r24, 0x0c	; 12
    2334:	0e 94 ce 10 	call	0x219c	; 0x219c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2338:	d9 87       	std	Y+9, r29	; 0x09
    233a:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    233c:	db 8b       	std	Y+19, r29	; 0x13
    233e:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2340:	82 e0       	ldi	r24, 0x02	; 2
    2342:	90 e0       	ldi	r25, 0x00	; 0
    2344:	81 1b       	sub	r24, r17
    2346:	91 09       	sbc	r25, r1
    2348:	9d 87       	std	Y+13, r25	; 0x0d
    234a:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    234c:	8e 89       	ldd	r24, Y+22	; 0x16
    234e:	90 91 f2 01 	lds	r25, 0x01F2	; 0x8001f2 <uxTopCoRoutineReadyPriority>
    2352:	98 17       	cp	r25, r24
    2354:	10 f4       	brcc	.+4      	; 0x235a <xCoRoutineCreate+0xbc>
    2356:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <uxTopCoRoutineReadyPriority>
    235a:	f9 e0       	ldi	r31, 0x09	; 9
    235c:	8f 9f       	mul	r24, r31
    235e:	c0 01       	movw	r24, r0
    2360:	11 24       	eor	r1, r1
    2362:	b7 01       	movw	r22, r14
    2364:	8e 5e       	subi	r24, 0xEE	; 238
    2366:	9d 4f       	sbci	r25, 0xFD	; 253
    2368:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

		xReturn = pdPASS;
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	01 c0       	rjmp	.+2      	; 0x2372 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2370:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    2372:	df 91       	pop	r29
    2374:	cf 91       	pop	r28
    2376:	1f 91       	pop	r17
    2378:	ff 90       	pop	r15
    237a:	ef 90       	pop	r14
    237c:	df 90       	pop	r13
    237e:	cf 90       	pop	r12
    2380:	08 95       	ret

00002382 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2382:	0f 93       	push	r16
    2384:	1f 93       	push	r17
    2386:	cf 93       	push	r28
    2388:	df 93       	push	r29
    238a:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    238c:	c0 91 f0 01 	lds	r28, 0x01F0	; 0x8001f0 <xCoRoutineTickCount>
    2390:	d0 91 f1 01 	lds	r29, 0x01F1	; 0x8001f1 <xCoRoutineTickCount+0x1>
    2394:	c8 0f       	add	r28, r24
    2396:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2398:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <pxCurrentCoRoutine>
    239c:	90 91 eb 01 	lds	r25, 0x01EB	; 0x8001eb <pxCurrentCoRoutine+0x1>
    23a0:	02 96       	adiw	r24, 0x02	; 2
    23a2:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    23a6:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <pxCurrentCoRoutine>
    23aa:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <pxCurrentCoRoutine+0x1>
    23ae:	d3 83       	std	Z+3, r29	; 0x03
    23b0:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    23b2:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <xCoRoutineTickCount>
    23b6:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <xCoRoutineTickCount+0x1>
    23ba:	bf 01       	movw	r22, r30
    23bc:	6e 5f       	subi	r22, 0xFE	; 254
    23be:	7f 4f       	sbci	r23, 0xFF	; 255
    23c0:	c8 17       	cp	r28, r24
    23c2:	d9 07       	cpc	r29, r25
    23c4:	28 f4       	brcc	.+10     	; 0x23d0 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    23c6:	80 91 fc 01 	lds	r24, 0x01FC	; 0x8001fc <pxOverflowDelayedCoRoutineList>
    23ca:	90 91 fd 01 	lds	r25, 0x01FD	; 0x8001fd <pxOverflowDelayedCoRoutineList+0x1>
    23ce:	04 c0       	rjmp	.+8      	; 0x23d8 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    23d0:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <pxDelayedCoRoutineList>
    23d4:	90 91 ff 01 	lds	r25, 0x01FF	; 0x8001ff <pxDelayedCoRoutineList+0x1>
    23d8:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <vListInsert>
	}

	if( pxEventList )
    23dc:	01 15       	cp	r16, r1
    23de:	11 05       	cpc	r17, r1
    23e0:	69 f0       	breq	.+26     	; 0x23fc <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    23e2:	60 91 ea 01 	lds	r22, 0x01EA	; 0x8001ea <pxCurrentCoRoutine>
    23e6:	70 91 eb 01 	lds	r23, 0x01EB	; 0x8001eb <pxCurrentCoRoutine+0x1>
    23ea:	64 5f       	subi	r22, 0xF4	; 244
    23ec:	7f 4f       	sbci	r23, 0xFF	; 255
    23ee:	c8 01       	movw	r24, r16
	}
}
    23f0:	df 91       	pop	r29
    23f2:	cf 91       	pop	r28
    23f4:	1f 91       	pop	r17
    23f6:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    23f8:	0c 94 f3 10 	jmp	0x21e6	; 0x21e6 <vListInsert>
	}
}
    23fc:	df 91       	pop	r29
    23fe:	cf 91       	pop	r28
    2400:	1f 91       	pop	r17
    2402:	0f 91       	pop	r16
    2404:	08 95       	ret

00002406 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2406:	ff 92       	push	r15
    2408:	0f 93       	push	r16
    240a:	1f 93       	push	r17
    240c:	cf 93       	push	r28
    240e:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2410:	99 e0       	ldi	r25, 0x09	; 9
    2412:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2414:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <xPendingReadyCoRoutineList>
    2418:	88 23       	and	r24, r24
    241a:	11 f1       	breq	.+68     	; 0x2460 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    241c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    241e:	e0 91 f8 01 	lds	r30, 0x01F8	; 0x8001f8 <xPendingReadyCoRoutineList+0x5>
    2422:	f0 91 f9 01 	lds	r31, 0x01F9	; 0x8001f9 <xPendingReadyCoRoutineList+0x6>
    2426:	c6 81       	ldd	r28, Z+6	; 0x06
    2428:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    242a:	ce 01       	movw	r24, r28
    242c:	0c 96       	adiw	r24, 0x0c	; 12
    242e:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2432:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2434:	8e 01       	movw	r16, r28
    2436:	0e 5f       	subi	r16, 0xFE	; 254
    2438:	1f 4f       	sbci	r17, 0xFF	; 255
    243a:	c8 01       	movw	r24, r16
    243c:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2440:	8e 89       	ldd	r24, Y+22	; 0x16
    2442:	90 91 f2 01 	lds	r25, 0x01F2	; 0x8001f2 <uxTopCoRoutineReadyPriority>
    2446:	98 17       	cp	r25, r24
    2448:	10 f4       	brcc	.+4      	; 0x244e <vCoRoutineSchedule+0x48>
    244a:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <uxTopCoRoutineReadyPriority>
    244e:	f8 9e       	mul	r15, r24
    2450:	c0 01       	movw	r24, r0
    2452:	11 24       	eor	r1, r1
    2454:	b8 01       	movw	r22, r16
    2456:	8e 5e       	subi	r24, 0xEE	; 238
    2458:	9d 4f       	sbci	r25, 0xFD	; 253
    245a:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
    245e:	da cf       	rjmp	.-76     	; 0x2414 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2460:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <xTaskGetTickCount>
    2464:	20 91 ee 01 	lds	r18, 0x01EE	; 0x8001ee <xLastTickCount>
    2468:	30 91 ef 01 	lds	r19, 0x01EF	; 0x8001ef <xLastTickCount+0x1>
    246c:	82 1b       	sub	r24, r18
    246e:	93 0b       	sbc	r25, r19
    2470:	90 93 ed 01 	sts	0x01ED, r25	; 0x8001ed <xPassedTicks+0x1>
    2474:	80 93 ec 01 	sts	0x01EC, r24	; 0x8001ec <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2478:	89 e0       	ldi	r24, 0x09	; 9
    247a:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    247c:	20 91 ec 01 	lds	r18, 0x01EC	; 0x8001ec <xPassedTicks>
    2480:	30 91 ed 01 	lds	r19, 0x01ED	; 0x8001ed <xPassedTicks+0x1>
    2484:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <xCoRoutineTickCount>
    2488:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <xCoRoutineTickCount+0x1>
    248c:	21 15       	cp	r18, r1
    248e:	31 05       	cpc	r19, r1
    2490:	09 f4       	brne	.+2      	; 0x2494 <vCoRoutineSchedule+0x8e>
    2492:	54 c0       	rjmp	.+168    	; 0x253c <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    2494:	01 96       	adiw	r24, 0x01	; 1
    2496:	90 93 f1 01 	sts	0x01F1, r25	; 0x8001f1 <xCoRoutineTickCount+0x1>
    249a:	80 93 f0 01 	sts	0x01F0, r24	; 0x8001f0 <xCoRoutineTickCount>
		xPassedTicks--;
    249e:	21 50       	subi	r18, 0x01	; 1
    24a0:	31 09       	sbc	r19, r1
    24a2:	30 93 ed 01 	sts	0x01ED, r19	; 0x8001ed <xPassedTicks+0x1>
    24a6:	20 93 ec 01 	sts	0x01EC, r18	; 0x8001ec <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    24aa:	89 2b       	or	r24, r25
    24ac:	09 f0       	breq	.+2      	; 0x24b0 <vCoRoutineSchedule+0xaa>
    24ae:	3e c0       	rjmp	.+124    	; 0x252c <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    24b0:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <pxDelayedCoRoutineList>
    24b4:	90 91 ff 01 	lds	r25, 0x01FF	; 0x8001ff <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    24b8:	20 91 fc 01 	lds	r18, 0x01FC	; 0x8001fc <pxOverflowDelayedCoRoutineList>
    24bc:	30 91 fd 01 	lds	r19, 0x01FD	; 0x8001fd <pxOverflowDelayedCoRoutineList+0x1>
    24c0:	30 93 ff 01 	sts	0x01FF, r19	; 0x8001ff <pxDelayedCoRoutineList+0x1>
    24c4:	20 93 fe 01 	sts	0x01FE, r18	; 0x8001fe <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    24c8:	90 93 fd 01 	sts	0x01FD, r25	; 0x8001fd <pxOverflowDelayedCoRoutineList+0x1>
    24cc:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <pxOverflowDelayedCoRoutineList>
    24d0:	2d c0       	rjmp	.+90     	; 0x252c <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    24d2:	05 80       	ldd	r0, Z+5	; 0x05
    24d4:	f6 81       	ldd	r31, Z+6	; 0x06
    24d6:	e0 2d       	mov	r30, r0
    24d8:	c6 81       	ldd	r28, Z+6	; 0x06
    24da:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    24dc:	2a 81       	ldd	r18, Y+2	; 0x02
    24de:	3b 81       	ldd	r19, Y+3	; 0x03
    24e0:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <xCoRoutineTickCount>
    24e4:	90 91 f1 01 	lds	r25, 0x01F1	; 0x8001f1 <xCoRoutineTickCount+0x1>
    24e8:	82 17       	cp	r24, r18
    24ea:	93 07       	cpc	r25, r19
    24ec:	38 f2       	brcs	.-114    	; 0x247c <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    24ee:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    24f0:	8e 01       	movw	r16, r28
    24f2:	0e 5f       	subi	r16, 0xFE	; 254
    24f4:	1f 4f       	sbci	r17, 0xFF	; 255
    24f6:	c8 01       	movw	r24, r16
    24f8:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    24fc:	8c 89       	ldd	r24, Y+20	; 0x14
    24fe:	9d 89       	ldd	r25, Y+21	; 0x15
    2500:	89 2b       	or	r24, r25
    2502:	21 f0       	breq	.+8      	; 0x250c <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2504:	ce 01       	movw	r24, r28
    2506:	0c 96       	adiw	r24, 0x0c	; 12
    2508:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    250c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    250e:	8e 89       	ldd	r24, Y+22	; 0x16
    2510:	90 91 f2 01 	lds	r25, 0x01F2	; 0x8001f2 <uxTopCoRoutineReadyPriority>
    2514:	98 17       	cp	r25, r24
    2516:	10 f4       	brcc	.+4      	; 0x251c <vCoRoutineSchedule+0x116>
    2518:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <uxTopCoRoutineReadyPriority>
    251c:	f8 9e       	mul	r15, r24
    251e:	c0 01       	movw	r24, r0
    2520:	11 24       	eor	r1, r1
    2522:	b8 01       	movw	r22, r16
    2524:	8e 5e       	subi	r24, 0xEE	; 238
    2526:	9d 4f       	sbci	r25, 0xFD	; 253
    2528:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    252c:	e0 91 fe 01 	lds	r30, 0x01FE	; 0x8001fe <pxDelayedCoRoutineList>
    2530:	f0 91 ff 01 	lds	r31, 0x01FF	; 0x8001ff <pxDelayedCoRoutineList+0x1>
    2534:	80 81       	ld	r24, Z
    2536:	81 11       	cpse	r24, r1
    2538:	cc cf       	rjmp	.-104    	; 0x24d2 <vCoRoutineSchedule+0xcc>
    253a:	a0 cf       	rjmp	.-192    	; 0x247c <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    253c:	90 93 ef 01 	sts	0x01EF, r25	; 0x8001ef <xLastTickCount+0x1>
    2540:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <xLastTickCount>
    2544:	80 91 f2 01 	lds	r24, 0x01F2	; 0x8001f2 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2548:	69 e0       	ldi	r22, 0x09	; 9
    254a:	48 2f       	mov	r20, r24
    254c:	50 e0       	ldi	r21, 0x00	; 0
    254e:	64 9f       	mul	r22, r20
    2550:	90 01       	movw	r18, r0
    2552:	65 9f       	mul	r22, r21
    2554:	30 0d       	add	r19, r0
    2556:	11 24       	eor	r1, r1
    2558:	f9 01       	movw	r30, r18
    255a:	ee 5e       	subi	r30, 0xEE	; 238
    255c:	fd 4f       	sbci	r31, 0xFD	; 253
    255e:	90 81       	ld	r25, Z
    2560:	91 11       	cpse	r25, r1
    2562:	0c c0       	rjmp	.+24     	; 0x257c <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2564:	81 11       	cpse	r24, r1
    2566:	08 c0       	rjmp	.+16     	; 0x2578 <vCoRoutineSchedule+0x172>
    2568:	10 92 f2 01 	sts	0x01F2, r1	; 0x8001f2 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    256c:	df 91       	pop	r29
    256e:	cf 91       	pop	r28
    2570:	1f 91       	pop	r17
    2572:	0f 91       	pop	r16
    2574:	ff 90       	pop	r15
    2576:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2578:	81 50       	subi	r24, 0x01	; 1
    257a:	e7 cf       	rjmp	.-50     	; 0x254a <vCoRoutineSchedule+0x144>
    257c:	80 93 f2 01 	sts	0x01F2, r24	; 0x8001f2 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2580:	a1 81       	ldd	r26, Z+1	; 0x01
    2582:	b2 81       	ldd	r27, Z+2	; 0x02
    2584:	12 96       	adiw	r26, 0x02	; 2
    2586:	0d 90       	ld	r0, X+
    2588:	bc 91       	ld	r27, X
    258a:	a0 2d       	mov	r26, r0
    258c:	b2 83       	std	Z+2, r27	; 0x02
    258e:	a1 83       	std	Z+1, r26	; 0x01
    2590:	2b 5e       	subi	r18, 0xEB	; 235
    2592:	3d 4f       	sbci	r19, 0xFD	; 253
    2594:	a2 17       	cp	r26, r18
    2596:	b3 07       	cpc	r27, r19
    2598:	31 f4       	brne	.+12     	; 0x25a6 <vCoRoutineSchedule+0x1a0>
    259a:	12 96       	adiw	r26, 0x02	; 2
    259c:	8d 91       	ld	r24, X+
    259e:	9c 91       	ld	r25, X
    25a0:	13 97       	sbiw	r26, 0x03	; 3
    25a2:	92 83       	std	Z+2, r25	; 0x02
    25a4:	81 83       	std	Z+1, r24	; 0x01
    25a6:	89 e0       	ldi	r24, 0x09	; 9
    25a8:	84 9f       	mul	r24, r20
    25aa:	f0 01       	movw	r30, r0
    25ac:	85 9f       	mul	r24, r21
    25ae:	f0 0d       	add	r31, r0
    25b0:	11 24       	eor	r1, r1
    25b2:	ee 5e       	subi	r30, 0xEE	; 238
    25b4:	fd 4f       	sbci	r31, 0xFD	; 253
    25b6:	01 80       	ldd	r0, Z+1	; 0x01
    25b8:	f2 81       	ldd	r31, Z+2	; 0x02
    25ba:	e0 2d       	mov	r30, r0
    25bc:	86 81       	ldd	r24, Z+6	; 0x06
    25be:	97 81       	ldd	r25, Z+7	; 0x07
    25c0:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <pxCurrentCoRoutine+0x1>
    25c4:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    25c8:	dc 01       	movw	r26, r24
    25ca:	ed 91       	ld	r30, X+
    25cc:	fc 91       	ld	r31, X
    25ce:	11 97       	sbiw	r26, 0x01	; 1
    25d0:	57 96       	adiw	r26, 0x17	; 23
    25d2:	6c 91       	ld	r22, X

	return;
}
    25d4:	df 91       	pop	r29
    25d6:	cf 91       	pop	r28
    25d8:	1f 91       	pop	r17
    25da:	0f 91       	pop	r16
    25dc:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    25de:	09 94       	ijmp

000025e0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    25e0:	0f 93       	push	r16
    25e2:	1f 93       	push	r17
    25e4:	cf 93       	push	r28
    25e6:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    25e8:	dc 01       	movw	r26, r24
    25ea:	15 96       	adiw	r26, 0x05	; 5
    25ec:	ed 91       	ld	r30, X+
    25ee:	fc 91       	ld	r31, X
    25f0:	16 97       	sbiw	r26, 0x06	; 6
    25f2:	c6 81       	ldd	r28, Z+6	; 0x06
    25f4:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25f6:	8e 01       	movw	r16, r28
    25f8:	04 5f       	subi	r16, 0xF4	; 244
    25fa:	1f 4f       	sbci	r17, 0xFF	; 255
    25fc:	c8 01       	movw	r24, r16
    25fe:	0e 94 2b 11 	call	0x2256	; 0x2256 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2602:	b8 01       	movw	r22, r16
    2604:	83 ef       	ldi	r24, 0xF3	; 243
    2606:	91 e0       	ldi	r25, 0x01	; 1
    2608:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    260c:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <pxCurrentCoRoutine>
    2610:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2614:	81 e0       	ldi	r24, 0x01	; 1
    2616:	2e 89       	ldd	r18, Y+22	; 0x16
    2618:	96 89       	ldd	r25, Z+22	; 0x16
    261a:	29 17       	cp	r18, r25
    261c:	08 f4       	brcc	.+2      	; 0x2620 <xCoRoutineRemoveFromEventList+0x40>
    261e:	80 e0       	ldi	r24, 0x00	; 0
}
    2620:	df 91       	pop	r29
    2622:	cf 91       	pop	r28
    2624:	1f 91       	pop	r17
    2626:	0f 91       	pop	r16
    2628:	08 95       	ret

0000262a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    262a:	cf 93       	push	r28
    262c:	df 93       	push	r29
    262e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2630:	0e 94 f2 06 	call	0xde4	; 0xde4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2634:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <pucAlignedHeap.2085>
    2638:	90 91 25 02 	lds	r25, 0x0225	; 0x800225 <pucAlignedHeap.2085+0x1>
    263c:	89 2b       	or	r24, r25
    263e:	31 f4       	brne	.+12     	; 0x264c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2640:	89 e2       	ldi	r24, 0x29	; 41
    2642:	92 e0       	ldi	r25, 0x02	; 2
    2644:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <pucAlignedHeap.2085+0x1>
    2648:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    264c:	20 91 26 02 	lds	r18, 0x0226	; 0x800226 <xNextFreeByte>
    2650:	30 91 27 02 	lds	r19, 0x0227	; 0x800227 <xNextFreeByte+0x1>
    2654:	c9 01       	movw	r24, r18
    2656:	8c 0f       	add	r24, r28
    2658:	9d 1f       	adc	r25, r29
    265a:	8b 3d       	cpi	r24, 0xDB	; 219
    265c:	45 e0       	ldi	r20, 0x05	; 5
    265e:	94 07       	cpc	r25, r20
    2660:	70 f4       	brcc	.+28     	; 0x267e <pvPortMalloc+0x54>
    2662:	28 17       	cp	r18, r24
    2664:	39 07       	cpc	r19, r25
    2666:	58 f4       	brcc	.+22     	; 0x267e <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2668:	c0 91 24 02 	lds	r28, 0x0224	; 0x800224 <pucAlignedHeap.2085>
    266c:	d0 91 25 02 	lds	r29, 0x0225	; 0x800225 <pucAlignedHeap.2085+0x1>
    2670:	c2 0f       	add	r28, r18
    2672:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2674:	90 93 27 02 	sts	0x0227, r25	; 0x800227 <xNextFreeByte+0x1>
    2678:	80 93 26 02 	sts	0x0226, r24	; 0x800226 <xNextFreeByte>
    267c:	02 c0       	rjmp	.+4      	; 0x2682 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    267e:	c0 e0       	ldi	r28, 0x00	; 0
    2680:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2682:	0e 94 be 07 	call	0xf7c	; 0xf7c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2686:	ce 01       	movw	r24, r28
    2688:	df 91       	pop	r29
    268a:	cf 91       	pop	r28
    268c:	08 95       	ret

0000268e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    268e:	08 95       	ret

00002690 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2690:	10 92 27 02 	sts	0x0227, r1	; 0x800227 <xNextFreeByte+0x1>
    2694:	10 92 26 02 	sts	0x0226, r1	; 0x800226 <xNextFreeByte>
    2698:	08 95       	ret

0000269a <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    269a:	20 91 26 02 	lds	r18, 0x0226	; 0x800226 <xNextFreeByte>
    269e:	30 91 27 02 	lds	r19, 0x0227	; 0x800227 <xNextFreeByte+0x1>
}
    26a2:	8b ed       	ldi	r24, 0xDB	; 219
    26a4:	95 e0       	ldi	r25, 0x05	; 5
    26a6:	82 1b       	sub	r24, r18
    26a8:	93 0b       	sbc	r25, r19
    26aa:	08 95       	ret

000026ac <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    26ac:	31 e1       	ldi	r19, 0x11	; 17
    26ae:	fc 01       	movw	r30, r24
    26b0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    26b2:	31 97       	sbiw	r30, 0x01	; 1
    26b4:	22 e2       	ldi	r18, 0x22	; 34
    26b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    26b8:	31 97       	sbiw	r30, 0x01	; 1
    26ba:	a3 e3       	ldi	r26, 0x33	; 51
    26bc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    26be:	31 97       	sbiw	r30, 0x01	; 1
    26c0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    26c2:	31 97       	sbiw	r30, 0x01	; 1
    26c4:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    26c6:	31 97       	sbiw	r30, 0x01	; 1
    26c8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    26ca:	31 97       	sbiw	r30, 0x01	; 1
    26cc:	60 e8       	ldi	r22, 0x80	; 128
    26ce:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    26d0:	31 97       	sbiw	r30, 0x01	; 1
    26d2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    26d4:	31 97       	sbiw	r30, 0x01	; 1
    26d6:	62 e0       	ldi	r22, 0x02	; 2
    26d8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    26da:	31 97       	sbiw	r30, 0x01	; 1
    26dc:	63 e0       	ldi	r22, 0x03	; 3
    26de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    26e0:	31 97       	sbiw	r30, 0x01	; 1
    26e2:	64 e0       	ldi	r22, 0x04	; 4
    26e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    26e6:	31 97       	sbiw	r30, 0x01	; 1
    26e8:	65 e0       	ldi	r22, 0x05	; 5
    26ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    26ec:	31 97       	sbiw	r30, 0x01	; 1
    26ee:	66 e0       	ldi	r22, 0x06	; 6
    26f0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    26f2:	31 97       	sbiw	r30, 0x01	; 1
    26f4:	67 e0       	ldi	r22, 0x07	; 7
    26f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    26f8:	31 97       	sbiw	r30, 0x01	; 1
    26fa:	68 e0       	ldi	r22, 0x08	; 8
    26fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    26fe:	31 97       	sbiw	r30, 0x01	; 1
    2700:	69 e0       	ldi	r22, 0x09	; 9
    2702:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2704:	31 97       	sbiw	r30, 0x01	; 1
    2706:	60 e1       	ldi	r22, 0x10	; 16
    2708:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    270a:	31 97       	sbiw	r30, 0x01	; 1
    270c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    270e:	31 97       	sbiw	r30, 0x01	; 1
    2710:	32 e1       	ldi	r19, 0x12	; 18
    2712:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2714:	31 97       	sbiw	r30, 0x01	; 1
    2716:	33 e1       	ldi	r19, 0x13	; 19
    2718:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    271a:	31 97       	sbiw	r30, 0x01	; 1
    271c:	34 e1       	ldi	r19, 0x14	; 20
    271e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2720:	31 97       	sbiw	r30, 0x01	; 1
    2722:	35 e1       	ldi	r19, 0x15	; 21
    2724:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2726:	31 97       	sbiw	r30, 0x01	; 1
    2728:	36 e1       	ldi	r19, 0x16	; 22
    272a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    272c:	31 97       	sbiw	r30, 0x01	; 1
    272e:	37 e1       	ldi	r19, 0x17	; 23
    2730:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2732:	31 97       	sbiw	r30, 0x01	; 1
    2734:	38 e1       	ldi	r19, 0x18	; 24
    2736:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2738:	31 97       	sbiw	r30, 0x01	; 1
    273a:	39 e1       	ldi	r19, 0x19	; 25
    273c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    273e:	31 97       	sbiw	r30, 0x01	; 1
    2740:	30 e2       	ldi	r19, 0x20	; 32
    2742:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2744:	31 97       	sbiw	r30, 0x01	; 1
    2746:	31 e2       	ldi	r19, 0x21	; 33
    2748:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    274a:	31 97       	sbiw	r30, 0x01	; 1
    274c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    274e:	31 97       	sbiw	r30, 0x01	; 1
    2750:	23 e2       	ldi	r18, 0x23	; 35
    2752:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2754:	31 97       	sbiw	r30, 0x01	; 1
    2756:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2758:	31 97       	sbiw	r30, 0x01	; 1
    275a:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    275c:	31 97       	sbiw	r30, 0x01	; 1
    275e:	26 e2       	ldi	r18, 0x26	; 38
    2760:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2762:	31 97       	sbiw	r30, 0x01	; 1
    2764:	27 e2       	ldi	r18, 0x27	; 39
    2766:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2768:	31 97       	sbiw	r30, 0x01	; 1
    276a:	28 e2       	ldi	r18, 0x28	; 40
    276c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    276e:	31 97       	sbiw	r30, 0x01	; 1
    2770:	29 e2       	ldi	r18, 0x29	; 41
    2772:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2774:	31 97       	sbiw	r30, 0x01	; 1
    2776:	20 e3       	ldi	r18, 0x30	; 48
    2778:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    277a:	31 97       	sbiw	r30, 0x01	; 1
    277c:	21 e3       	ldi	r18, 0x31	; 49
    277e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2780:	86 97       	sbiw	r24, 0x26	; 38
    2782:	08 95       	ret

00002784 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2784:	89 e0       	ldi	r24, 0x09	; 9
    2786:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
	OCR1AL = ucLowByte;
    278a:	83 ec       	ldi	r24, 0xC3	; 195
    278c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2790:	8b e0       	ldi	r24, 0x0B	; 11
    2792:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK0;
    2796:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    279a:	82 60       	ori	r24, 0x02	; 2
	//TIMSK0 = ucLowByte;
	TIMSK1 = ucLowByte;
    279c:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    27a0:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    27a4:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    27a8:	cd 91       	ld	r28, X+
    27aa:	cd bf       	out	0x3d, r28	; 61
    27ac:	dd 91       	ld	r29, X+
    27ae:	de bf       	out	0x3e, r29	; 62
    27b0:	ff 91       	pop	r31
    27b2:	ef 91       	pop	r30
    27b4:	df 91       	pop	r29
    27b6:	cf 91       	pop	r28
    27b8:	bf 91       	pop	r27
    27ba:	af 91       	pop	r26
    27bc:	9f 91       	pop	r25
    27be:	8f 91       	pop	r24
    27c0:	7f 91       	pop	r23
    27c2:	6f 91       	pop	r22
    27c4:	5f 91       	pop	r21
    27c6:	4f 91       	pop	r20
    27c8:	3f 91       	pop	r19
    27ca:	2f 91       	pop	r18
    27cc:	1f 91       	pop	r17
    27ce:	0f 91       	pop	r16
    27d0:	ff 90       	pop	r15
    27d2:	ef 90       	pop	r14
    27d4:	df 90       	pop	r13
    27d6:	cf 90       	pop	r12
    27d8:	bf 90       	pop	r11
    27da:	af 90       	pop	r10
    27dc:	9f 90       	pop	r9
    27de:	8f 90       	pop	r8
    27e0:	7f 90       	pop	r7
    27e2:	6f 90       	pop	r6
    27e4:	5f 90       	pop	r5
    27e6:	4f 90       	pop	r4
    27e8:	3f 90       	pop	r3
    27ea:	2f 90       	pop	r2
    27ec:	1f 90       	pop	r1
    27ee:	0f 90       	pop	r0
    27f0:	0f be       	out	0x3f, r0	; 63
    27f2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    27f4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    27f6:	81 e0       	ldi	r24, 0x01	; 1
    27f8:	08 95       	ret

000027fa <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    27fa:	08 95       	ret

000027fc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    27fc:	0f 92       	push	r0
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	f8 94       	cli
    2802:	0f 92       	push	r0
    2804:	1f 92       	push	r1
    2806:	11 24       	eor	r1, r1
    2808:	2f 92       	push	r2
    280a:	3f 92       	push	r3
    280c:	4f 92       	push	r4
    280e:	5f 92       	push	r5
    2810:	6f 92       	push	r6
    2812:	7f 92       	push	r7
    2814:	8f 92       	push	r8
    2816:	9f 92       	push	r9
    2818:	af 92       	push	r10
    281a:	bf 92       	push	r11
    281c:	cf 92       	push	r12
    281e:	df 92       	push	r13
    2820:	ef 92       	push	r14
    2822:	ff 92       	push	r15
    2824:	0f 93       	push	r16
    2826:	1f 93       	push	r17
    2828:	2f 93       	push	r18
    282a:	3f 93       	push	r19
    282c:	4f 93       	push	r20
    282e:	5f 93       	push	r21
    2830:	6f 93       	push	r22
    2832:	7f 93       	push	r23
    2834:	8f 93       	push	r24
    2836:	9f 93       	push	r25
    2838:	af 93       	push	r26
    283a:	bf 93       	push	r27
    283c:	cf 93       	push	r28
    283e:	df 93       	push	r29
    2840:	ef 93       	push	r30
    2842:	ff 93       	push	r31
    2844:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    2848:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    284c:	0d b6       	in	r0, 0x3d	; 61
    284e:	0d 92       	st	X+, r0
    2850:	0e b6       	in	r0, 0x3e	; 62
    2852:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2854:	0e 94 78 08 	call	0x10f0	; 0x10f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2858:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    285c:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    2860:	cd 91       	ld	r28, X+
    2862:	cd bf       	out	0x3d, r28	; 61
    2864:	dd 91       	ld	r29, X+
    2866:	de bf       	out	0x3e, r29	; 62
    2868:	ff 91       	pop	r31
    286a:	ef 91       	pop	r30
    286c:	df 91       	pop	r29
    286e:	cf 91       	pop	r28
    2870:	bf 91       	pop	r27
    2872:	af 91       	pop	r26
    2874:	9f 91       	pop	r25
    2876:	8f 91       	pop	r24
    2878:	7f 91       	pop	r23
    287a:	6f 91       	pop	r22
    287c:	5f 91       	pop	r21
    287e:	4f 91       	pop	r20
    2880:	3f 91       	pop	r19
    2882:	2f 91       	pop	r18
    2884:	1f 91       	pop	r17
    2886:	0f 91       	pop	r16
    2888:	ff 90       	pop	r15
    288a:	ef 90       	pop	r14
    288c:	df 90       	pop	r13
    288e:	cf 90       	pop	r12
    2890:	bf 90       	pop	r11
    2892:	af 90       	pop	r10
    2894:	9f 90       	pop	r9
    2896:	8f 90       	pop	r8
    2898:	7f 90       	pop	r7
    289a:	6f 90       	pop	r6
    289c:	5f 90       	pop	r5
    289e:	4f 90       	pop	r4
    28a0:	3f 90       	pop	r3
    28a2:	2f 90       	pop	r2
    28a4:	1f 90       	pop	r1
    28a6:	0f 90       	pop	r0
    28a8:	0f be       	out	0x3f, r0	; 63
    28aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    28ac:	08 95       	ret

000028ae <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    28ae:	0f 92       	push	r0
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	f8 94       	cli
    28b4:	0f 92       	push	r0
    28b6:	1f 92       	push	r1
    28b8:	11 24       	eor	r1, r1
    28ba:	2f 92       	push	r2
    28bc:	3f 92       	push	r3
    28be:	4f 92       	push	r4
    28c0:	5f 92       	push	r5
    28c2:	6f 92       	push	r6
    28c4:	7f 92       	push	r7
    28c6:	8f 92       	push	r8
    28c8:	9f 92       	push	r9
    28ca:	af 92       	push	r10
    28cc:	bf 92       	push	r11
    28ce:	cf 92       	push	r12
    28d0:	df 92       	push	r13
    28d2:	ef 92       	push	r14
    28d4:	ff 92       	push	r15
    28d6:	0f 93       	push	r16
    28d8:	1f 93       	push	r17
    28da:	2f 93       	push	r18
    28dc:	3f 93       	push	r19
    28de:	4f 93       	push	r20
    28e0:	5f 93       	push	r21
    28e2:	6f 93       	push	r22
    28e4:	7f 93       	push	r23
    28e6:	8f 93       	push	r24
    28e8:	9f 93       	push	r25
    28ea:	af 93       	push	r26
    28ec:	bf 93       	push	r27
    28ee:	cf 93       	push	r28
    28f0:	df 93       	push	r29
    28f2:	ef 93       	push	r30
    28f4:	ff 93       	push	r31
    28f6:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    28fa:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    28fe:	0d b6       	in	r0, 0x3d	; 61
    2900:	0d 92       	st	X+, r0
    2902:	0e b6       	in	r0, 0x3e	; 62
    2904:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2906:	0e 94 12 07 	call	0xe24	; 0xe24 <xTaskIncrementTick>
    290a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    290c:	0e 94 78 08 	call	0x10f0	; 0x10f0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2910:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    2914:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    2918:	cd 91       	ld	r28, X+
    291a:	cd bf       	out	0x3d, r28	; 61
    291c:	dd 91       	ld	r29, X+
    291e:	de bf       	out	0x3e, r29	; 62
    2920:	ff 91       	pop	r31
    2922:	ef 91       	pop	r30
    2924:	df 91       	pop	r29
    2926:	cf 91       	pop	r28
    2928:	bf 91       	pop	r27
    292a:	af 91       	pop	r26
    292c:	9f 91       	pop	r25
    292e:	8f 91       	pop	r24
    2930:	7f 91       	pop	r23
    2932:	6f 91       	pop	r22
    2934:	5f 91       	pop	r21
    2936:	4f 91       	pop	r20
    2938:	3f 91       	pop	r19
    293a:	2f 91       	pop	r18
    293c:	1f 91       	pop	r17
    293e:	0f 91       	pop	r16
    2940:	ff 90       	pop	r15
    2942:	ef 90       	pop	r14
    2944:	df 90       	pop	r13
    2946:	cf 90       	pop	r12
    2948:	bf 90       	pop	r11
    294a:	af 90       	pop	r10
    294c:	9f 90       	pop	r9
    294e:	8f 90       	pop	r8
    2950:	7f 90       	pop	r7
    2952:	6f 90       	pop	r6
    2954:	5f 90       	pop	r5
    2956:	4f 90       	pop	r4
    2958:	3f 90       	pop	r3
    295a:	2f 90       	pop	r2
    295c:	1f 90       	pop	r1
    295e:	0f 90       	pop	r0
    2960:	0f be       	out	0x3f, r0	; 63
    2962:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2964:	08 95       	ret

00002966 <__vector_11>:
	 */
	//void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	//void SIG_OUTPUT_COMPARE1A( void )
    ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    2966:	0e 94 57 14 	call	0x28ae	; 0x28ae <vPortYieldFromTick>
		asm volatile ( "reti" );
    296a:	18 95       	reti

0000296c <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    296c:	0f 93       	push	r16
    296e:	1f 93       	push	r17
    2970:	cf 93       	push	r28
    2972:	df 93       	push	r29
    2974:	1f 92       	push	r1
    2976:	cd b7       	in	r28, 0x3d	; 61
    2978:	de b7       	in	r29, 0x3e	; 62
    297a:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    297c:	fc 01       	movw	r30, r24
    297e:	80 8d       	ldd	r24, Z+24	; 0x18
    2980:	91 8d       	ldd	r25, Z+25	; 0x19
    2982:	8e 36       	cpi	r24, 0x6E	; 110
    2984:	f1 e0       	ldi	r31, 0x01	; 1
    2986:	9f 07       	cpc	r25, r31
    2988:	b1 f0       	breq	.+44     	; 0x29b6 <prvFlashCoRoutine+0x4a>
    298a:	8f 36       	cpi	r24, 0x6F	; 111
    298c:	21 e0       	ldi	r18, 0x01	; 1
    298e:	92 07       	cpc	r25, r18
    2990:	51 f1       	breq	.+84     	; 0x29e6 <prvFlashCoRoutine+0x7a>
    2992:	89 2b       	or	r24, r25
    2994:	61 f5       	brne	.+88     	; 0x29ee <prvFlashCoRoutine+0x82>
	( void ) uxIndex;

	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
    2996:	4f ef       	ldi	r20, 0xFF	; 255
    2998:	5f ef       	ldi	r21, 0xFF	; 255
    299a:	be 01       	movw	r22, r28
    299c:	6f 5f       	subi	r22, 0xFF	; 255
    299e:	7f 4f       	sbci	r23, 0xFF	; 255
    29a0:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <xFlashQueue>
    29a4:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <xFlashQueue+0x1>
    29a8:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueCRReceive>
    29ac:	8c 3f       	cpi	r24, 0xFC	; 252
    29ae:	71 f4       	brne	.+28     	; 0x29cc <prvFlashCoRoutine+0x60>
    29b0:	8e e6       	ldi	r24, 0x6E	; 110
    29b2:	91 e0       	ldi	r25, 0x01	; 1
    29b4:	0f c0       	rjmp	.+30     	; 0x29d4 <prvFlashCoRoutine+0x68>
    29b6:	40 e0       	ldi	r20, 0x00	; 0
    29b8:	50 e0       	ldi	r21, 0x00	; 0
    29ba:	be 01       	movw	r22, r28
    29bc:	6f 5f       	subi	r22, 0xFF	; 255
    29be:	7f 4f       	sbci	r23, 0xFF	; 255
    29c0:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <xFlashQueue>
    29c4:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <xFlashQueue+0x1>
    29c8:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueCRReceive>
    29cc:	8b 3f       	cpi	r24, 0xFB	; 251
    29ce:	31 f4       	brne	.+12     	; 0x29dc <prvFlashCoRoutine+0x70>
    29d0:	8f e6       	ldi	r24, 0x6F	; 111
    29d2:	91 e0       	ldi	r25, 0x01	; 1
    29d4:	f8 01       	movw	r30, r16
    29d6:	91 8f       	std	Z+25, r25	; 0x19
    29d8:	80 8f       	std	Z+24, r24	; 0x18
    29da:	09 c0       	rjmp	.+18     	; 0x29ee <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    29dc:	81 30       	cpi	r24, 0x01	; 1
    29de:	19 f0       	breq	.+6      	; 0x29e6 <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    29e0:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <xCoRoutineFlashStatus>
    29e4:	d8 cf       	rjmp	.-80     	; 0x2996 <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <vParTestToggleLED>
    29ec:	d4 cf       	rjmp	.-88     	; 0x2996 <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    29ee:	0f 90       	pop	r0
    29f0:	df 91       	pop	r29
    29f2:	cf 91       	pop	r28
    29f4:	1f 91       	pop	r17
    29f6:	0f 91       	pop	r16
    29f8:	08 95       	ret

000029fa <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    29fa:	0f 93       	push	r16
    29fc:	1f 93       	push	r17
    29fe:	cf 93       	push	r28
    2a00:	df 93       	push	r29
    2a02:	1f 92       	push	r1
    2a04:	cd b7       	in	r28, 0x3d	; 61
    2a06:	de b7       	in	r29, 0x3e	; 62
    2a08:	8c 01       	movw	r16, r24
    2a0a:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2a0c:	fc 01       	movw	r30, r24
    2a0e:	80 8d       	ldd	r24, Z+24	; 0x18
    2a10:	91 8d       	ldd	r25, Z+25	; 0x19
    2a12:	8e 32       	cpi	r24, 0x2E	; 46
    2a14:	f1 e0       	ldi	r31, 0x01	; 1
    2a16:	9f 07       	cpc	r25, r31
    2a18:	d9 f0       	breq	.+54     	; 0x2a50 <prvFixedDelayCoRoutine+0x56>
    2a1a:	18 f4       	brcc	.+6      	; 0x2a22 <prvFixedDelayCoRoutine+0x28>
    2a1c:	89 2b       	or	r24, r25
    2a1e:	41 f0       	breq	.+16     	; 0x2a30 <prvFixedDelayCoRoutine+0x36>
    2a20:	3e c0       	rjmp	.+124    	; 0x2a9e <prvFixedDelayCoRoutine+0xa4>
    2a22:	8f 32       	cpi	r24, 0x2F	; 47
    2a24:	e1 e0       	ldi	r30, 0x01	; 1
    2a26:	9e 07       	cpc	r25, r30
    2a28:	39 f1       	breq	.+78     	; 0x2a78 <prvFixedDelayCoRoutine+0x7e>
    2a2a:	82 34       	cpi	r24, 0x42	; 66
    2a2c:	91 40       	sbci	r25, 0x01	; 1
    2a2e:	b9 f5       	brne	.+110    	; 0x2a9e <prvFixedDelayCoRoutine+0xa4>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    2a30:	40 e0       	ldi	r20, 0x00	; 0
    2a32:	50 e0       	ldi	r21, 0x00	; 0
    2a34:	be 01       	movw	r22, r28
    2a36:	6f 5f       	subi	r22, 0xFF	; 255
    2a38:	7f 4f       	sbci	r23, 0xFF	; 255
    2a3a:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <xFlashQueue>
    2a3e:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <xFlashQueue+0x1>
    2a42:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <xQueueCRSend>
    2a46:	8c 3f       	cpi	r24, 0xFC	; 252
    2a48:	71 f4       	brne	.+28     	; 0x2a66 <prvFixedDelayCoRoutine+0x6c>
    2a4a:	8e e2       	ldi	r24, 0x2E	; 46
    2a4c:	91 e0       	ldi	r25, 0x01	; 1
    2a4e:	24 c0       	rjmp	.+72     	; 0x2a98 <prvFixedDelayCoRoutine+0x9e>
    2a50:	40 e0       	ldi	r20, 0x00	; 0
    2a52:	50 e0       	ldi	r21, 0x00	; 0
    2a54:	be 01       	movw	r22, r28
    2a56:	6f 5f       	subi	r22, 0xFF	; 255
    2a58:	7f 4f       	sbci	r23, 0xFF	; 255
    2a5a:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <xFlashQueue>
    2a5e:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <xFlashQueue+0x1>
    2a62:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <xQueueCRSend>
    2a66:	8b 3f       	cpi	r24, 0xFB	; 251
    2a68:	19 f4       	brne	.+6      	; 0x2a70 <prvFixedDelayCoRoutine+0x76>
    2a6a:	8f e2       	ldi	r24, 0x2F	; 47
    2a6c:	91 e0       	ldi	r25, 0x01	; 1
    2a6e:	14 c0       	rjmp	.+40     	; 0x2a98 <prvFixedDelayCoRoutine+0x9e>

		if( xResult != pdPASS )
    2a70:	81 30       	cpi	r24, 0x01	; 1
    2a72:	11 f0       	breq	.+4      	; 0x2a78 <prvFixedDelayCoRoutine+0x7e>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    2a74:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <xCoRoutineFlashStatus>
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    2a78:	e9 81       	ldd	r30, Y+1	; 0x01
    2a7a:	f0 e0       	ldi	r31, 0x00	; 0
    2a7c:	ee 0f       	add	r30, r30
    2a7e:	ff 1f       	adc	r31, r31
    2a80:	e3 5e       	subi	r30, 0xE3	; 227
    2a82:	fe 4f       	sbci	r31, 0xFE	; 254
    2a84:	80 81       	ld	r24, Z
    2a86:	91 81       	ldd	r25, Z+1	; 0x01
    2a88:	00 97       	sbiw	r24, 0x00	; 0
    2a8a:	21 f0       	breq	.+8      	; 0x2a94 <prvFixedDelayCoRoutine+0x9a>
    2a8c:	60 e0       	ldi	r22, 0x00	; 0
    2a8e:	70 e0       	ldi	r23, 0x00	; 0
    2a90:	0e 94 c1 11 	call	0x2382	; 0x2382 <vCoRoutineAddToDelayedList>
    2a94:	82 e4       	ldi	r24, 0x42	; 66
    2a96:	91 e0       	ldi	r25, 0x01	; 1
    2a98:	f8 01       	movw	r30, r16
    2a9a:	91 8f       	std	Z+25, r25	; 0x19
    2a9c:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2a9e:	0f 90       	pop	r0
    2aa0:	df 91       	pop	r29
    2aa2:	cf 91       	pop	r28
    2aa4:	1f 91       	pop	r17
    2aa6:	0f 91       	pop	r16
    2aa8:	08 95       	ret

00002aaa <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    2aaa:	cf 93       	push	r28
    2aac:	df 93       	push	r29
    2aae:	d8 2f       	mov	r29, r24
    2ab0:	89 30       	cpi	r24, 0x09	; 9
    2ab2:	08 f0       	brcs	.+2      	; 0x2ab6 <vStartFlashCoRoutines+0xc>
    2ab4:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    2ab6:	40 e0       	ldi	r20, 0x00	; 0
    2ab8:	61 e0       	ldi	r22, 0x01	; 1
    2aba:	81 e0       	ldi	r24, 0x01	; 1
    2abc:	0e 94 be 0c 	call	0x197c	; 0x197c <xQueueGenericCreate>
    2ac0:	90 93 05 08 	sts	0x0805, r25	; 0x800805 <xFlashQueue+0x1>
    2ac4:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <xFlashQueue>

	if( xFlashQueue )
    2ac8:	89 2b       	or	r24, r25
    2aca:	99 f0       	breq	.+38     	; 0x2af2 <vStartFlashCoRoutines+0x48>
    2acc:	c0 e0       	ldi	r28, 0x00	; 0
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2ace:	cd 17       	cp	r28, r29
    2ad0:	41 f0       	breq	.+16     	; 0x2ae2 <vStartFlashCoRoutines+0x38>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    2ad2:	4c 2f       	mov	r20, r28
    2ad4:	60 e0       	ldi	r22, 0x00	; 0
    2ad6:	8d ef       	ldi	r24, 0xFD	; 253
    2ad8:	94 e1       	ldi	r25, 0x14	; 20
    2ada:	0e 94 4f 11 	call	0x229e	; 0x229e <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2ade:	cf 5f       	subi	r28, 0xFF	; 255
    2ae0:	f6 cf       	rjmp	.-20     	; 0x2ace <vStartFlashCoRoutines+0x24>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2ae2:	40 e0       	ldi	r20, 0x00	; 0
    2ae4:	61 e0       	ldi	r22, 0x01	; 1
    2ae6:	86 eb       	ldi	r24, 0xB6	; 182
    2ae8:	94 e1       	ldi	r25, 0x14	; 20
	}
}
    2aea:	df 91       	pop	r29
    2aec:	cf 91       	pop	r28
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2aee:	0c 94 4f 11 	jmp	0x229e	; 0x229e <xCoRoutineCreate>
	}
}
    2af2:	df 91       	pop	r29
    2af4:	cf 91       	pop	r28
    2af6:	08 95       	ret

00002af8 <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    2af8:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <xCoRoutineFlashStatus>
    2afc:	08 95       	ret

00002afe <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    2afe:	cf 93       	push	r28
    2b00:	df 93       	push	r29
    2b02:	00 d0       	rcall	.+0      	; 0x2b04 <vCompeteingIntMathTask+0x6>
    2b04:	00 d0       	rcall	.+0      	; 0x2b06 <vCompeteingIntMathTask+0x8>
    2b06:	cd b7       	in	r28, 0x3d	; 61
    2b08:	de b7       	in	r29, 0x3e	; 62
    2b0a:	7c 01       	movw	r14, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    2b0c:	00 e0       	ldi	r16, 0x00	; 0
    2b0e:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2b10:	8b e7       	ldi	r24, 0x7B	; 123
    2b12:	88 2e       	mov	r8, r24
    2b14:	91 2c       	mov	r9, r1
    2b16:	a1 2c       	mov	r10, r1
    2b18:	b1 2c       	mov	r11, r1
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
    2b1a:	97 e0       	ldi	r25, 0x07	; 7
    2b1c:	49 2e       	mov	r4, r25
    2b1e:	51 2c       	mov	r5, r1
    2b20:	61 2c       	mov	r6, r1
    2b22:	71 2c       	mov	r7, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    2b24:	dd 24       	eor	r13, r13
    2b26:	d3 94       	inc	r13
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2b28:	89 82       	std	Y+1, r8	; 0x01
    2b2a:	9a 82       	std	Y+2, r9	; 0x02
    2b2c:	ab 82       	std	Y+3, r10	; 0x03
    2b2e:	bc 82       	std	Y+4, r11	; 0x04
		lValue += intgCONST2;
    2b30:	89 81       	ldd	r24, Y+1	; 0x01
    2b32:	9a 81       	ldd	r25, Y+2	; 0x02
    2b34:	ab 81       	ldd	r26, Y+3	; 0x03
    2b36:	bc 81       	ldd	r27, Y+4	; 0x04
    2b38:	89 5b       	subi	r24, 0xB9	; 185
    2b3a:	9b 46       	sbci	r25, 0x6B	; 107
    2b3c:	ac 4f       	sbci	r26, 0xFC	; 252
    2b3e:	bf 4f       	sbci	r27, 0xFF	; 255
    2b40:	89 83       	std	Y+1, r24	; 0x01
    2b42:	9a 83       	std	Y+2, r25	; 0x02
    2b44:	ab 83       	std	Y+3, r26	; 0x03
    2b46:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    2b48:	29 81       	ldd	r18, Y+1	; 0x01
    2b4a:	3a 81       	ldd	r19, Y+2	; 0x02
    2b4c:	4b 81       	ldd	r20, Y+3	; 0x03
    2b4e:	5c 81       	ldd	r21, Y+4	; 0x04
    2b50:	ad ef       	ldi	r26, 0xFD	; 253
    2b52:	bf ef       	ldi	r27, 0xFF	; 255
    2b54:	0e 94 2d 2a 	call	0x545a	; 0x545a <__mulohisi3>
    2b58:	69 83       	std	Y+1, r22	; 0x01
    2b5a:	7a 83       	std	Y+2, r23	; 0x02
    2b5c:	8b 83       	std	Y+3, r24	; 0x03
    2b5e:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    2b60:	69 81       	ldd	r22, Y+1	; 0x01
    2b62:	7a 81       	ldd	r23, Y+2	; 0x02
    2b64:	8b 81       	ldd	r24, Y+3	; 0x03
    2b66:	9c 81       	ldd	r25, Y+4	; 0x04
    2b68:	a3 01       	movw	r20, r6
    2b6a:	92 01       	movw	r18, r4
    2b6c:	0e 94 05 2a 	call	0x540a	; 0x540a <__divmodsi4>
    2b70:	29 83       	std	Y+1, r18	; 0x01
    2b72:	3a 83       	std	Y+2, r19	; 0x02
    2b74:	4b 83       	std	Y+3, r20	; 0x03
    2b76:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the
		TaskHasExecuted variable so the check task can see an error has
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    2b78:	89 81       	ldd	r24, Y+1	; 0x01
    2b7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b7c:	ab 81       	ldd	r26, Y+3	; 0x03
    2b7e:	bc 81       	ldd	r27, Y+4	; 0x04
    2b80:	8b 31       	cpi	r24, 0x1B	; 27
    2b82:	97 47       	sbci	r25, 0x77	; 119
    2b84:	ae 4f       	sbci	r26, 0xFE	; 254
    2b86:	bf 4f       	sbci	r27, 0xFF	; 255
    2b88:	19 f0       	breq	.+6      	; 0x2b90 <vCompeteingIntMathTask+0x92>
    2b8a:	01 e0       	ldi	r16, 0x01	; 1
    2b8c:	10 e0       	ldi	r17, 0x00	; 0
    2b8e:	cc cf       	rjmp	.-104    	; 0x2b28 <vCompeteingIntMathTask+0x2a>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    2b90:	01 15       	cp	r16, r1
    2b92:	11 05       	cpc	r17, r1
    2b94:	d1 f7       	brne	.-12     	; 0x2b8a <vCompeteingIntMathTask+0x8c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    2b96:	0f b6       	in	r0, 0x3f	; 63
    2b98:	f8 94       	cli
    2b9a:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    2b9c:	f7 01       	movw	r30, r14
    2b9e:	d0 82       	st	Z, r13
			portEXIT_CRITICAL();
    2ba0:	0f 90       	pop	r0
    2ba2:	0f be       	out	0x3f, r0	; 63
    2ba4:	c1 cf       	rjmp	.-126    	; 0x2b28 <vCompeteingIntMathTask+0x2a>

00002ba6 <vStartIntegerMathTasks>:
static BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    2ba6:	ef 92       	push	r14
    2ba8:	ff 92       	push	r15
    2baa:	0f 93       	push	r16
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    2bac:	e1 2c       	mov	r14, r1
    2bae:	f1 2c       	mov	r15, r1
    2bb0:	08 2f       	mov	r16, r24
    2bb2:	26 e0       	ldi	r18, 0x06	; 6
    2bb4:	38 e0       	ldi	r19, 0x08	; 8
    2bb6:	45 e5       	ldi	r20, 0x55	; 85
    2bb8:	50 e0       	ldi	r21, 0x00	; 0
    2bba:	68 e5       	ldi	r22, 0x58	; 88
    2bbc:	71 e0       	ldi	r23, 0x01	; 1
    2bbe:	8f e7       	ldi	r24, 0x7F	; 127
    2bc0:	95 e1       	ldi	r25, 0x15	; 21
    2bc2:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
	}
}
    2bc6:	0f 91       	pop	r16
    2bc8:	ff 90       	pop	r15
    2bca:	ef 90       	pop	r14
    2bcc:	08 95       	ret

00002bce <xAreIntegerMathsTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
BaseType_t xReturn = pdTRUE;
    2bce:	81 e0       	ldi	r24, 0x01	; 1
    2bd0:	90 91 06 08 	lds	r25, 0x0806	; 0x800806 <xTaskCheck>
    2bd4:	91 11       	cpse	r25, r1
    2bd6:	01 c0       	rjmp	.+2      	; 0x2bda <xAreIntegerMathsTaskStillRunning+0xc>
    2bd8:	80 e0       	ldi	r24, 0x00	; 0
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    2bda:	10 92 06 08 	sts	0x0806, r1	; 0x800806 <xTaskCheck>
	}

	return xReturn;
}
    2bde:	08 95       	ret

00002be0 <vPolledQueueProducer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2be0:	cf 93       	push	r28
    2be2:	df 93       	push	r29
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <vPolledQueueProducer+0x6>
    2be6:	cd b7       	in	r28, 0x3d	; 61
    2be8:	de b7       	in	r29, 0x3e	; 62
    2bea:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    2bec:	1a 82       	std	Y+2, r1	; 0x02
    2bee:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xError = pdFALSE, xLoop;
    2bf0:	00 e0       	ldi	r16, 0x00	; 0
    2bf2:	13 e0       	ldi	r17, 0x03	; 3
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2bf4:	20 e0       	ldi	r18, 0x00	; 0
    2bf6:	40 e0       	ldi	r20, 0x00	; 0
    2bf8:	50 e0       	ldi	r21, 0x00	; 0
    2bfa:	be 01       	movw	r22, r28
    2bfc:	6f 5f       	subi	r22, 0xFF	; 255
    2bfe:	7f 4f       	sbci	r23, 0xFF	; 255
    2c00:	f7 01       	movw	r30, r14
    2c02:	80 81       	ld	r24, Z
    2c04:	91 81       	ldd	r25, Z+1	; 0x01
    2c06:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xQueueGenericSend>
    2c0a:	81 30       	cpi	r24, 0x01	; 1
    2c0c:	91 f4       	brne	.+36     	; 0x2c32 <vPolledQueueProducer+0x52>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    2c0e:	01 11       	cpse	r16, r1
    2c10:	0a c0       	rjmp	.+20     	; 0x2c26 <vPolledQueueProducer+0x46>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    2c12:	0f b6       	in	r0, 0x3f	; 63
    2c14:	f8 94       	cli
    2c16:	0f 92       	push	r0
						xPollingProducerCount++;
    2c18:	80 91 09 08 	lds	r24, 0x0809	; 0x800809 <xPollingProducerCount>
    2c1c:	8f 5f       	subi	r24, 0xFF	; 255
    2c1e:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <xPollingProducerCount>
					portEXIT_CRITICAL();
    2c22:	0f 90       	pop	r0
    2c24:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2c26:	89 81       	ldd	r24, Y+1	; 0x01
    2c28:	9a 81       	ldd	r25, Y+2	; 0x02
    2c2a:	01 96       	adiw	r24, 0x01	; 1
    2c2c:	9a 83       	std	Y+2, r25	; 0x02
    2c2e:	89 83       	std	Y+1, r24	; 0x01
    2c30:	01 c0       	rjmp	.+2      	; 0x2c34 <vPolledQueueProducer+0x54>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    2c32:	01 e0       	ldi	r16, 0x01	; 1
    2c34:	11 50       	subi	r17, 0x01	; 1
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2c36:	f1 f6       	brne	.-68     	; 0x2bf4 <vPolledQueueProducer+0x14>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2c38:	84 e1       	ldi	r24, 0x14	; 20
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskDelay>
	}
    2c40:	d8 cf       	rjmp	.-80     	; 0x2bf2 <vPolledQueueProducer+0x12>

00002c42 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    2c42:	cf 93       	push	r28
    2c44:	df 93       	push	r29
    2c46:	00 d0       	rcall	.+0      	; 0x2c48 <vPolledQueueConsumer+0x6>
    2c48:	cd b7       	in	r28, 0x3d	; 61
    2c4a:	de b7       	in	r29, 0x3e	; 62
    2c4c:	6c 01       	movw	r12, r24
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE;
    2c4e:	f1 2c       	mov	r15, r1
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    2c50:	00 e0       	ldi	r16, 0x00	; 0
    2c52:	10 e0       	ldi	r17, 0x00	; 0
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    2c54:	f6 01       	movw	r30, r12
    2c56:	80 81       	ld	r24, Z
    2c58:	91 81       	ldd	r25, Z+1	; 0x01
    2c5a:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxQueueMessagesWaiting>
    2c5e:	88 23       	and	r24, r24
    2c60:	21 f1       	breq	.+72     	; 0x2caa <vPolledQueueConsumer+0x68>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2c62:	40 e0       	ldi	r20, 0x00	; 0
    2c64:	50 e0       	ldi	r21, 0x00	; 0
    2c66:	be 01       	movw	r22, r28
    2c68:	6f 5f       	subi	r22, 0xFF	; 255
    2c6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c6c:	f6 01       	movw	r30, r12
    2c6e:	80 81       	ld	r24, Z
    2c70:	91 81       	ldd	r25, Z+1	; 0x01
    2c72:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <xQueueReceive>
    2c76:	81 30       	cpi	r24, 0x01	; 1
    2c78:	69 f7       	brne	.-38     	; 0x2c54 <vPolledQueueConsumer+0x12>
			{
				if( usData != usExpectedValue )
    2c7a:	89 81       	ldd	r24, Y+1	; 0x01
    2c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7e:	08 17       	cp	r16, r24
    2c80:	19 07       	cpc	r17, r25
    2c82:	69 f4       	brne	.+26     	; 0x2c9e <vPolledQueueConsumer+0x5c>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    2c84:	f1 10       	cpse	r15, r1
    2c86:	0e c0       	rjmp	.+28     	; 0x2ca4 <vPolledQueueConsumer+0x62>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2c88:	0f b6       	in	r0, 0x3f	; 63
    2c8a:	f8 94       	cli
    2c8c:	0f 92       	push	r0
							xPollingConsumerCount++;
    2c8e:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xPollingConsumerCount>
    2c92:	8f 5f       	subi	r24, 0xFF	; 255
    2c94:	80 93 0a 08 	sts	0x080A, r24	; 0x80080a <xPollingConsumerCount>
						portEXIT_CRITICAL();
    2c98:	0f 90       	pop	r0
    2c9a:	0f be       	out	0x3f, r0	; 63
    2c9c:	03 c0       	rjmp	.+6      	; 0x2ca4 <vPolledQueueConsumer+0x62>
    2c9e:	8c 01       	movw	r16, r24
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    2ca0:	ff 24       	eor	r15, r15
    2ca2:	f3 94       	inc	r15
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2ca4:	0f 5f       	subi	r16, 0xFF	; 255
    2ca6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ca8:	d5 cf       	rjmp	.-86     	; 0x2c54 <vPolledQueueConsumer+0x12>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    2caa:	82 e1       	ldi	r24, 0x12	; 18
    2cac:	90 e0       	ldi	r25, 0x00	; 0
    2cae:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskDelay>
	}
    2cb2:	d0 cf       	rjmp	.-96     	; 0x2c54 <vPolledQueueConsumer+0x12>

00002cb4 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    2cb4:	ef 92       	push	r14
    2cb6:	ff 92       	push	r15
    2cb8:	0f 93       	push	r16
    2cba:	cf 93       	push	r28
    2cbc:	c8 2f       	mov	r28, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2cbe:	40 e0       	ldi	r20, 0x00	; 0
    2cc0:	62 e0       	ldi	r22, 0x02	; 2
    2cc2:	8a e0       	ldi	r24, 0x0A	; 10
    2cc4:	0e 94 be 0c 	call	0x197c	; 0x197c <xQueueGenericCreate>
    2cc8:	90 93 08 08 	sts	0x0808, r25	; 0x800808 <xPolledQueue.2207+0x1>
    2ccc:	80 93 07 08 	sts	0x0807, r24	; 0x800807 <xPolledQueue.2207>

	if( xPolledQueue != NULL )
    2cd0:	89 2b       	or	r24, r25
    2cd2:	b9 f0       	breq	.+46     	; 0x2d02 <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2cd4:	e1 2c       	mov	r14, r1
    2cd6:	f1 2c       	mov	r15, r1
    2cd8:	0c 2f       	mov	r16, r28
    2cda:	27 e0       	ldi	r18, 0x07	; 7
    2cdc:	38 e0       	ldi	r19, 0x08	; 8
    2cde:	45 e5       	ldi	r20, 0x55	; 85
    2ce0:	50 e0       	ldi	r21, 0x00	; 0
    2ce2:	60 e6       	ldi	r22, 0x60	; 96
    2ce4:	71 e0       	ldi	r23, 0x01	; 1
    2ce6:	81 e2       	ldi	r24, 0x21	; 33
    2ce8:	96 e1       	ldi	r25, 0x16	; 22
    2cea:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2cee:	27 e0       	ldi	r18, 0x07	; 7
    2cf0:	38 e0       	ldi	r19, 0x08	; 8
    2cf2:	45 e5       	ldi	r20, 0x55	; 85
    2cf4:	50 e0       	ldi	r21, 0x00	; 0
    2cf6:	68 e6       	ldi	r22, 0x68	; 104
    2cf8:	71 e0       	ldi	r23, 0x01	; 1
    2cfa:	80 ef       	ldi	r24, 0xF0	; 240
    2cfc:	95 e1       	ldi	r25, 0x15	; 21
    2cfe:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
	}
}
    2d02:	cf 91       	pop	r28
    2d04:	0f 91       	pop	r16
    2d06:	ff 90       	pop	r15
    2d08:	ef 90       	pop	r14
    2d0a:	08 95       	ret

00002d0c <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2d0c:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xPollingConsumerCount>
    2d10:	88 23       	and	r24, r24
    2d12:	29 f0       	breq	.+10     	; 0x2d1e <xArePollingQueuesStillRunning+0x12>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    2d14:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <xPollingProducerCount>
	  )
	{
		xReturn = pdFALSE;
    2d18:	81 e0       	ldi	r24, 0x01	; 1
    2d1a:	91 11       	cpse	r25, r1
    2d1c:	01 c0       	rjmp	.+2      	; 0x2d20 <xArePollingQueuesStillRunning+0x14>
    2d1e:	80 e0       	ldi	r24, 0x00	; 0
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2d20:	10 92 0a 08 	sts	0x080A, r1	; 0x80080a <xPollingConsumerCount>
	xPollingProducerCount = pollqINITIAL_VALUE;
    2d24:	10 92 09 08 	sts	0x0809, r1	; 0x800809 <xPollingProducerCount>

	return xReturn;
}
    2d28:	08 95       	ret

00002d2a <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2d2a:	cf 93       	push	r28
    2d2c:	df 93       	push	r29
    2d2e:	1f 92       	push	r1
    2d30:	cd b7       	in	r28, 0x3d	; 61
    2d32:	de b7       	in	r29, 0x3e	; 62
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
    2d34:	00 e0       	ldi	r16, 0x00	; 0

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    2d36:	11 e4       	ldi	r17, 0x41	; 65
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2d38:	4f ef       	ldi	r20, 0xFF	; 255
    2d3a:	5f ef       	ldi	r21, 0xFF	; 255
    2d3c:	be 01       	movw	r22, r28
    2d3e:	6f 5f       	subi	r22, 0xFF	; 255
    2d40:	7f 4f       	sbci	r23, 0xFF	; 255
    2d42:	80 e0       	ldi	r24, 0x00	; 0
    2d44:	90 e0       	ldi	r25, 0x00	; 0
    2d46:	0e 94 56 01 	call	0x2ac	; 0x2ac <xSerialGetChar>
    2d4a:	88 23       	and	r24, r24
    2d4c:	41 f0       	breq	.+16     	; 0x2d5e <vComRxTask+0x34>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    2d4e:	89 81       	ldd	r24, Y+1	; 0x01
    2d50:	81 13       	cpse	r24, r17
    2d52:	0a c0       	rjmp	.+20     	; 0x2d68 <vComRxTask+0x3e>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    2d54:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxBaseLED>
    2d58:	8f 5f       	subi	r24, 0xFF	; 255
    2d5a:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <vParTestToggleLED>
    2d5e:	1f 5f       	subi	r17, 0xFF	; 255

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    2d60:	19 35       	cpi	r17, 0x59	; 89
    2d62:	51 f7       	brne	.-44     	; 0x2d38 <vComRxTask+0xe>
    2d64:	10 e0       	ldi	r17, 0x00	; 0
    2d66:	01 c0       	rjmp	.+2      	; 0x2d6a <vComRxTask+0x40>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
				}
				else
				{
					xResyncRequired = pdTRUE;
    2d68:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    2d6a:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxBaseLED>
    2d6e:	60 e0       	ldi	r22, 0x00	; 0
    2d70:	8f 5f       	subi	r24, 0xFF	; 255
    2d72:	0e 94 c5 00 	call	0x18a	; 0x18a <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    2d76:	11 30       	cpi	r17, 0x01	; 1
    2d78:	79 f4       	brne	.+30     	; 0x2d98 <vComRxTask+0x6e>
		{
			while( cByteRxed != comLAST_BYTE )
    2d7a:	89 81       	ldd	r24, Y+1	; 0x01
    2d7c:	88 35       	cpi	r24, 0x58	; 88
    2d7e:	51 f0       	breq	.+20     	; 0x2d94 <vComRxTask+0x6a>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    2d80:	4f ef       	ldi	r20, 0xFF	; 255
    2d82:	5f ef       	ldi	r21, 0xFF	; 255
    2d84:	be 01       	movw	r22, r28
    2d86:	6f 5f       	subi	r22, 0xFF	; 255
    2d88:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8a:	80 e0       	ldi	r24, 0x00	; 0
    2d8c:	90 e0       	ldi	r25, 0x00	; 0
    2d8e:	0e 94 56 01 	call	0x2ac	; 0x2ac <xSerialGetChar>
    2d92:	f3 cf       	rjmp	.-26     	; 0x2d7a <vComRxTask+0x50>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    2d94:	0f 5f       	subi	r16, 0xFF	; 255
    2d96:	cf cf       	rjmp	.-98     	; 0x2d36 <vComRxTask+0xc>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    2d98:	02 30       	cpi	r16, 0x02	; 2
    2d9a:	6c f6       	brge	.-102    	; 0x2d36 <vComRxTask+0xc>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    2d9c:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxRxLoops>
    2da0:	8f 5f       	subi	r24, 0xFF	; 255
    2da2:	80 93 0b 08 	sts	0x080B, r24	; 0x80080b <uxRxLoops>
    2da6:	c7 cf       	rjmp	.-114    	; 0x2d36 <vComRxTask+0xc>

00002da8 <vComTxTask>:
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2da8:	06 e9       	ldi	r16, 0x96	; 150
    2daa:	10 e0       	ldi	r17, 0x00	; 0

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2dac:	c1 e4       	ldi	r28, 0x41	; 65
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    2dae:	40 e0       	ldi	r20, 0x00	; 0
    2db0:	50 e0       	ldi	r21, 0x00	; 0
    2db2:	6c 2f       	mov	r22, r28
    2db4:	80 e0       	ldi	r24, 0x00	; 0
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	0e 94 62 01 	call	0x2c4	; 0x2c4 <xSerialPutChar>
    2dbc:	81 30       	cpi	r24, 0x01	; 1
    2dbe:	21 f4       	brne	.+8      	; 0x2dc8 <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    2dc0:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxBaseLED>
    2dc4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <vParTestToggleLED>
    2dc8:	cf 5f       	subi	r28, 0xFF	; 255

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2dca:	c9 35       	cpi	r28, 0x59	; 89
    2dcc:	81 f7       	brne	.-32     	; 0x2dae <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    2dce:	60 e0       	ldi	r22, 0x00	; 0
    2dd0:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxBaseLED>
    2dd4:	0e 94 c5 00 	call	0x18a	; 0x18a <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    2dd8:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <xTaskGetTickCount>
    2ddc:	03 96       	adiw	r24, 0x03	; 3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2dde:	b8 01       	movw	r22, r16
    2de0:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    2de4:	82 33       	cpi	r24, 0x32	; 50
    2de6:	91 05       	cpc	r25, r1
    2de8:	10 f4       	brcc	.+4      	; 0x2dee <vComTxTask+0x46>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
    2dea:	82 e3       	ldi	r24, 0x32	; 50
    2dec:	90 e0       	ldi	r25, 0x00	; 0
		}

		vTaskDelay( xTimeToWait );
    2dee:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskDelay>
	}
    2df2:	dc cf       	rjmp	.-72     	; 0x2dac <vComTxTask+0x4>

00002df4 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    2df4:	ef 92       	push	r14
    2df6:	ff 92       	push	r15
    2df8:	0f 93       	push	r16
    2dfa:	cf 93       	push	r28
    2dfc:	c8 2f       	mov	r28, r24
    2dfe:	cb 01       	movw	r24, r22
    2e00:	ba 01       	movw	r22, r20
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    2e02:	20 93 0c 08 	sts	0x080C, r18	; 0x80080c <uxBaseLED>
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    2e06:	48 e1       	ldi	r20, 0x18	; 24
    2e08:	0e 94 0d 01 	call	0x21a	; 0x21a <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    2e0c:	0f ef       	ldi	r16, 0xFF	; 255
    2e0e:	0c 0f       	add	r16, r28
    2e10:	e1 2c       	mov	r14, r1
    2e12:	f1 2c       	mov	r15, r1
    2e14:	20 e0       	ldi	r18, 0x00	; 0
    2e16:	30 e0       	ldi	r19, 0x00	; 0
    2e18:	45 e5       	ldi	r20, 0x55	; 85
    2e1a:	50 e0       	ldi	r21, 0x00	; 0
    2e1c:	60 e7       	ldi	r22, 0x70	; 112
    2e1e:	71 e0       	ldi	r23, 0x01	; 1
    2e20:	84 ed       	ldi	r24, 0xD4	; 212
    2e22:	96 e1       	ldi	r25, 0x16	; 22
    2e24:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    2e28:	0c 2f       	mov	r16, r28
    2e2a:	20 e0       	ldi	r18, 0x00	; 0
    2e2c:	30 e0       	ldi	r19, 0x00	; 0
    2e2e:	45 e5       	ldi	r20, 0x55	; 85
    2e30:	50 e0       	ldi	r21, 0x00	; 0
    2e32:	66 e7       	ldi	r22, 0x76	; 118
    2e34:	71 e0       	ldi	r23, 0x01	; 1
    2e36:	85 e9       	ldi	r24, 0x95	; 149
    2e38:	96 e1       	ldi	r25, 0x16	; 22
    2e3a:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
}
    2e3e:	cf 91       	pop	r28
    2e40:	0f 91       	pop	r16
    2e42:	ff 90       	pop	r15
    2e44:	ef 90       	pop	r14
    2e46:	08 95       	ret

00002e48 <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    2e48:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <uxRxLoops>
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    2e4c:	10 92 0b 08 	sts	0x080B, r1	; 0x80080b <uxRxLoops>

	return xReturn;
    2e50:	81 e0       	ldi	r24, 0x01	; 1
    2e52:	91 11       	cpse	r25, r1
    2e54:	01 c0       	rjmp	.+2      	; 0x2e58 <xAreComTestTasksStillRunning+0x10>
    2e56:	80 e0       	ldi	r24, 0x00	; 0
}
    2e58:	08 95       	ret

00002e5a <close>:
   while(getSn_SR(sn) == SOCK_CLOSED);
   return (int8_t)sn;
}	   

int8_t close(uint8_t sn)
{
    2e5a:	8f 92       	push	r8
    2e5c:	9f 92       	push	r9
    2e5e:	af 92       	push	r10
    2e60:	bf 92       	push	r11
    2e62:	cf 92       	push	r12
    2e64:	df 92       	push	r13
    2e66:	ef 92       	push	r14
    2e68:	ff 92       	push	r15
    2e6a:	0f 93       	push	r16
    2e6c:	1f 93       	push	r17
    2e6e:	cf 93       	push	r28
    2e70:	df 93       	push	r29
	CHECK_SOCKNUM();
    2e72:	89 30       	cpi	r24, 0x09	; 9
    2e74:	08 f0       	brcs	.+2      	; 0x2e78 <close+0x1e>
    2e76:	59 c0       	rjmp	.+178    	; 0x2f2a <close+0xd0>
    2e78:	f8 2e       	mov	r15, r24
      while(getSn_CR(sn) != 0);
      while(getSn_SR(sn) != SOCK_UDP);
      sendto(sn,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
   };   
#endif 
	setSn_CR(sn,Sn_CR_CLOSE);
    2e7a:	08 2f       	mov	r16, r24
    2e7c:	10 e0       	ldi	r17, 0x00	; 0
    2e7e:	e8 01       	movw	r28, r16
    2e80:	95 e0       	ldi	r25, 0x05	; 5
    2e82:	cc 0f       	add	r28, r28
    2e84:	dd 1f       	adc	r29, r29
    2e86:	9a 95       	dec	r25
    2e88:	e1 f7       	brne	.-8      	; 0x2e82 <close+0x28>
    2e8a:	28 96       	adiw	r28, 0x08	; 8
    2e8c:	4e 01       	movw	r8, r28
    2e8e:	93 94       	inc	r9
    2e90:	09 2c       	mov	r0, r9
    2e92:	00 0c       	add	r0, r0
    2e94:	aa 08       	sbc	r10, r10
    2e96:	bb 08       	sbc	r11, r11
    2e98:	40 e1       	ldi	r20, 0x10	; 16
    2e9a:	c5 01       	movw	r24, r10
    2e9c:	b4 01       	movw	r22, r8
    2e9e:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   /* wait to process the command... */
	while( getSn_CR(sn) );
    2ea2:	c5 01       	movw	r24, r10
    2ea4:	b4 01       	movw	r22, r8
    2ea6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    2eaa:	81 11       	cpse	r24, r1
    2eac:	fa cf       	rjmp	.-12     	; 0x2ea2 <close+0x48>
	/* clear all interrupt of the socket. */
	setSn_IR(sn, 0xFF);
    2eae:	be 01       	movw	r22, r28
    2eb0:	7e 5f       	subi	r23, 0xFE	; 254
    2eb2:	07 2e       	mov	r0, r23
    2eb4:	00 0c       	add	r0, r0
    2eb6:	88 0b       	sbc	r24, r24
    2eb8:	99 0b       	sbc	r25, r25
    2eba:	4f e1       	ldi	r20, 0x1F	; 31
    2ebc:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
	//A20150401 : Release the sock_io_mode of socket n.
	sock_io_mode &= ~(1<<sn);
    2ec0:	81 e0       	ldi	r24, 0x01	; 1
    2ec2:	90 e0       	ldi	r25, 0x00	; 0
    2ec4:	02 c0       	rjmp	.+4      	; 0x2eca <close+0x70>
    2ec6:	88 0f       	add	r24, r24
    2ec8:	99 1f       	adc	r25, r25
    2eca:	fa 94       	dec	r15
    2ecc:	e2 f7       	brpl	.-8      	; 0x2ec6 <close+0x6c>
    2ece:	80 95       	com	r24
    2ed0:	90 95       	com	r25
    2ed2:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <sock_io_mode>
    2ed6:	30 91 28 08 	lds	r19, 0x0828	; 0x800828 <sock_io_mode+0x1>
    2eda:	28 23       	and	r18, r24
    2edc:	39 23       	and	r19, r25
    2ede:	30 93 28 08 	sts	0x0828, r19	; 0x800828 <sock_io_mode+0x1>
    2ee2:	20 93 27 08 	sts	0x0827, r18	; 0x800827 <sock_io_mode>
	//
	sock_is_sending &= ~(1<<sn);
    2ee6:	20 91 25 08 	lds	r18, 0x0825	; 0x800825 <sock_is_sending>
    2eea:	30 91 26 08 	lds	r19, 0x0826	; 0x800826 <sock_is_sending+0x1>
    2eee:	82 23       	and	r24, r18
    2ef0:	93 23       	and	r25, r19
    2ef2:	90 93 26 08 	sts	0x0826, r25	; 0x800826 <sock_is_sending+0x1>
    2ef6:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <sock_is_sending>
	sock_remained_size[sn] = 0;
    2efa:	f8 01       	movw	r30, r16
    2efc:	ee 0f       	add	r30, r30
    2efe:	ff 1f       	adc	r31, r31
    2f00:	eb 5e       	subi	r30, 0xEB	; 235
    2f02:	f7 4f       	sbci	r31, 0xF7	; 247
    2f04:	11 82       	std	Z+1, r1	; 0x01
    2f06:	10 82       	st	Z, r1
	sock_pack_info[sn] = 0;
    2f08:	f8 01       	movw	r30, r16
    2f0a:	e3 5f       	subi	r30, 0xF3	; 243
    2f0c:	f7 4f       	sbci	r31, 0xF7	; 247
    2f0e:	10 82       	st	Z, r1
	while(getSn_SR(sn) != SOCK_CLOSED);
    2f10:	dd 5f       	subi	r29, 0xFD	; 253
    2f12:	6e 01       	movw	r12, r28
    2f14:	dd 0f       	add	r29, r29
    2f16:	ee 08       	sbc	r14, r14
    2f18:	ff 08       	sbc	r15, r15
    2f1a:	c7 01       	movw	r24, r14
    2f1c:	b6 01       	movw	r22, r12
    2f1e:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    2f22:	81 11       	cpse	r24, r1
    2f24:	fa cf       	rjmp	.-12     	; 0x2f1a <close+0xc0>
	return SOCK_OK;
    2f26:	81 e0       	ldi	r24, 0x01	; 1
    2f28:	01 c0       	rjmp	.+2      	; 0x2f2c <close+0xd2>
   return (int8_t)sn;
}	   

int8_t close(uint8_t sn)
{
	CHECK_SOCKNUM();
    2f2a:	8f ef       	ldi	r24, 0xFF	; 255
	sock_is_sending &= ~(1<<sn);
	sock_remained_size[sn] = 0;
	sock_pack_info[sn] = 0;
	while(getSn_SR(sn) != SOCK_CLOSED);
	return SOCK_OK;
}
    2f2c:	df 91       	pop	r29
    2f2e:	cf 91       	pop	r28
    2f30:	1f 91       	pop	r17
    2f32:	0f 91       	pop	r16
    2f34:	ff 90       	pop	r15
    2f36:	ef 90       	pop	r14
    2f38:	df 90       	pop	r13
    2f3a:	cf 90       	pop	r12
    2f3c:	bf 90       	pop	r11
    2f3e:	af 90       	pop	r10
    2f40:	9f 90       	pop	r9
    2f42:	8f 90       	pop	r8
    2f44:	08 95       	ret

00002f46 <socket>:
   }while(0);              \



int8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag)
{
    2f46:	4f 92       	push	r4
    2f48:	5f 92       	push	r5
    2f4a:	6f 92       	push	r6
    2f4c:	7f 92       	push	r7
    2f4e:	8f 92       	push	r8
    2f50:	9f 92       	push	r9
    2f52:	af 92       	push	r10
    2f54:	bf 92       	push	r11
    2f56:	cf 92       	push	r12
    2f58:	df 92       	push	r13
    2f5a:	ef 92       	push	r14
    2f5c:	ff 92       	push	r15
    2f5e:	0f 93       	push	r16
    2f60:	1f 93       	push	r17
    2f62:	cf 93       	push	r28
    2f64:	df 93       	push	r29
    2f66:	00 d0       	rcall	.+0      	; 0x2f68 <socket+0x22>
    2f68:	00 d0       	rcall	.+0      	; 0x2f6a <socket+0x24>
    2f6a:	cd b7       	in	r28, 0x3d	; 61
    2f6c:	de b7       	in	r29, 0x3e	; 62
    2f6e:	18 2f       	mov	r17, r24
    2f70:	76 2e       	mov	r7, r22
    2f72:	4a 01       	movw	r8, r20
    2f74:	02 2f       	mov	r16, r18
	CHECK_SOCKNUM();
    2f76:	89 30       	cpi	r24, 0x09	; 9
    2f78:	08 f0       	brcs	.+2      	; 0x2f7c <socket+0x36>
    2f7a:	c7 c0       	rjmp	.+398    	; 0x310a <socket+0x1c4>
	switch(protocol)
    2f7c:	21 e0       	ldi	r18, 0x01	; 1
    2f7e:	62 17       	cp	r22, r18
    2f80:	39 f0       	breq	.+14     	; 0x2f90 <socket+0x4a>
    2f82:	62 17       	cp	r22, r18
    2f84:	08 f4       	brcc	.+2      	; 0x2f88 <socket+0x42>
    2f86:	c3 c0       	rjmp	.+390    	; 0x310e <socket+0x1c8>
    2f88:	34 e0       	ldi	r19, 0x04	; 4
    2f8a:	36 17       	cp	r19, r22
    2f8c:	b0 f4       	brcc	.+44     	; 0x2fba <socket+0x74>
    2f8e:	bf c0       	rjmp	.+382    	; 0x310e <socket+0x1c8>
		    /*
            uint8_t taddr[4];
            getSIPR(taddr);
            */
            uint32_t taddr;
            getSIPR((uint8_t*)&taddr);
    2f90:	24 e0       	ldi	r18, 0x04	; 4
    2f92:	30 e0       	ldi	r19, 0x00	; 0
    2f94:	ae 01       	movw	r20, r28
    2f96:	4f 5f       	subi	r20, 0xFF	; 255
    2f98:	5f 4f       	sbci	r21, 0xFF	; 255
    2f9a:	60 e0       	ldi	r22, 0x00	; 0
    2f9c:	7f e0       	ldi	r23, 0x0F	; 15
    2f9e:	80 e0       	ldi	r24, 0x00	; 0
    2fa0:	90 e0       	ldi	r25, 0x00	; 0
    2fa2:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
            if(taddr == 0) return SOCKERR_SOCKINIT;
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2faa:	ab 81       	ldd	r26, Y+3	; 0x03
    2fac:	bc 81       	ldd	r27, Y+4	; 0x04
    2fae:	89 2b       	or	r24, r25
    2fb0:	8a 2b       	or	r24, r26
    2fb2:	8b 2b       	or	r24, r27
    2fb4:	11 f4       	brne	.+4      	; 0x2fba <socket+0x74>
    2fb6:	8d ef       	ldi	r24, 0xFD	; 253
    2fb8:	ad c0       	rjmp	.+346    	; 0x3114 <socket+0x1ce>
      default :
         return SOCKERR_SOCKMODE;
	}
	//M20150601 : For SF_TCP_ALIGN & W5300
	//if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
    2fba:	02 fd       	sbrc	r16, 2
    2fbc:	aa c0       	rjmp	.+340    	; 0x3112 <socket+0x1cc>
#if _WIZCHIP_ == 5200
   if(flag & 0x10) return SOCKERR_SOCKFLAG;
#endif
	   
	if(flag != 0)
    2fbe:	00 23       	and	r16, r16
    2fc0:	99 f0       	breq	.+38     	; 0x2fe8 <socket+0xa2>
	{
   	switch(protocol)
    2fc2:	81 e0       	ldi	r24, 0x01	; 1
    2fc4:	78 16       	cp	r7, r24
    2fc6:	21 f0       	breq	.+8      	; 0x2fd0 <socket+0x8a>
    2fc8:	22 e0       	ldi	r18, 0x02	; 2
    2fca:	72 16       	cp	r7, r18
    2fcc:	29 f0       	breq	.+10     	; 0x2fd8 <socket+0x92>
    2fce:	0c c0       	rjmp	.+24     	; 0x2fe8 <socket+0xa2>
   	   case Sn_MR_TCP:
   		  //M20150601 :  For SF_TCP_ALIGN & W5300
          #if _WIZCHIP_ == 5300
   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK|SF_TCP_ALIGN))==0) return SOCKERR_SOCKFLAG;
          #else
   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
    2fd0:	80 2f       	mov	r24, r16
    2fd2:	81 72       	andi	r24, 0x21	; 33
    2fd4:	49 f4       	brne	.+18     	; 0x2fe8 <socket+0xa2>
    2fd6:	9d c0       	rjmp	.+314    	; 0x3112 <socket+0x1cc>
          #endif

   	      break;
   	   case Sn_MR_UDP:
   	      if(flag & SF_IGMP_VER2)
    2fd8:	05 ff       	sbrs	r16, 5
    2fda:	02 c0       	rjmp	.+4      	; 0x2fe0 <socket+0x9a>
   	      {
   	         if((flag & SF_MULTI_ENABLE)==0) return SOCKERR_SOCKFLAG;
    2fdc:	07 ff       	sbrs	r16, 7
    2fde:	99 c0       	rjmp	.+306    	; 0x3112 <socket+0x1cc>
   	      }
   	      #if _WIZCHIP_ == 5500
      	      if(flag & SF_UNI_BLOCK)
    2fe0:	04 ff       	sbrs	r16, 4
    2fe2:	02 c0       	rjmp	.+4      	; 0x2fe8 <socket+0xa2>
      	      {
      	         if((flag & SF_MULTI_ENABLE) == 0) return SOCKERR_SOCKFLAG;
    2fe4:	07 ff       	sbrs	r16, 7
    2fe6:	95 c0       	rjmp	.+298    	; 0x3112 <socket+0x1cc>
   	      break;
   	   default:
   	      break;
   	}
   }
	close(sn);
    2fe8:	81 2f       	mov	r24, r17
    2fea:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
	//M20150601
	#if _WIZCHIP_ == 5300
	   setSn_MR(sn, ((uint16_t)(protocol | (flag & 0xF0))) | (((uint16_t)(flag & 0x02)) << 7) );
    #else
	   setSn_MR(sn, (protocol | (flag & 0xF0)));
    2fee:	a1 2e       	mov	r10, r17
    2ff0:	b1 2c       	mov	r11, r1
    2ff2:	c5 01       	movw	r24, r10
    2ff4:	25 e0       	ldi	r18, 0x05	; 5
    2ff6:	88 0f       	add	r24, r24
    2ff8:	99 1f       	adc	r25, r25
    2ffa:	2a 95       	dec	r18
    2ffc:	e1 f7       	brne	.-8      	; 0x2ff6 <socket+0xb0>
    2ffe:	9c 01       	movw	r18, r24
    3000:	28 5f       	subi	r18, 0xF8	; 248
    3002:	3f 4f       	sbci	r19, 0xFF	; 255
    3004:	69 01       	movw	r12, r18
    3006:	40 2f       	mov	r20, r16
    3008:	40 7f       	andi	r20, 0xF0	; 240
    300a:	47 29       	or	r20, r7
    300c:	b9 01       	movw	r22, r18
    300e:	33 0f       	add	r19, r19
    3010:	88 0b       	sbc	r24, r24
    3012:	99 0b       	sbc	r25, r25
    3014:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    #endif
	if(!port)
    3018:	81 14       	cp	r8, r1
    301a:	91 04       	cpc	r9, r1
    301c:	81 f4       	brne	.+32     	; 0x303e <socket+0xf8>
	{
	   port = sock_any_port++;
    301e:	80 90 02 01 	lds	r8, 0x0102	; 0x800102 <sock_any_port>
    3022:	90 90 03 01 	lds	r9, 0x0103	; 0x800103 <sock_any_port+0x1>
    3026:	c4 01       	movw	r24, r8
    3028:	01 96       	adiw	r24, 0x01	; 1
	   if(sock_any_port == 0xFFF0) sock_any_port = SOCK_ANY_PORT_NUM;
    302a:	80 3f       	cpi	r24, 0xF0	; 240
    302c:	3f ef       	ldi	r19, 0xFF	; 255
    302e:	93 07       	cpc	r25, r19
    3030:	11 f4       	brne	.+4      	; 0x3036 <socket+0xf0>
    3032:	80 e0       	ldi	r24, 0x00	; 0
    3034:	90 ec       	ldi	r25, 0xC0	; 192
    3036:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <sock_any_port+0x1>
    303a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <sock_any_port>
	}
   setSn_PORT(sn,port);	
    303e:	b6 01       	movw	r22, r12
    3040:	7c 5f       	subi	r23, 0xFC	; 252
    3042:	07 2e       	mov	r0, r23
    3044:	00 0c       	add	r0, r0
    3046:	88 0b       	sbc	r24, r24
    3048:	99 0b       	sbc	r25, r25
    304a:	49 2d       	mov	r20, r9
    304c:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    3050:	b6 01       	movw	r22, r12
    3052:	7b 5f       	subi	r23, 0xFB	; 251
    3054:	07 2e       	mov	r0, r23
    3056:	00 0c       	add	r0, r0
    3058:	88 0b       	sbc	r24, r24
    305a:	99 0b       	sbc	r25, r25
    305c:	48 2d       	mov	r20, r8
    305e:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   setSn_CR(sn,Sn_CR_OPEN);
    3062:	26 01       	movw	r4, r12
    3064:	53 94       	inc	r5
    3066:	05 2c       	mov	r0, r5
    3068:	00 0c       	add	r0, r0
    306a:	66 08       	sbc	r6, r6
    306c:	77 08       	sbc	r7, r7
    306e:	41 e0       	ldi	r20, 0x01	; 1
    3070:	c3 01       	movw	r24, r6
    3072:	b2 01       	movw	r22, r4
    3074:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   while(getSn_CR(sn));
    3078:	c3 01       	movw	r24, r6
    307a:	b2 01       	movw	r22, r4
    307c:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3080:	81 11       	cpse	r24, r1
    3082:	fa cf       	rjmp	.-12     	; 0x3078 <socket+0x132>
   //A20150401 : For release the previous sock_io_mode
   sock_io_mode &= ~(1 <<sn);
    3084:	81 e0       	ldi	r24, 0x01	; 1
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	01 2e       	mov	r0, r17
    308a:	02 c0       	rjmp	.+4      	; 0x3090 <socket+0x14a>
    308c:	88 0f       	add	r24, r24
    308e:	99 1f       	adc	r25, r25
    3090:	0a 94       	dec	r0
    3092:	e2 f7       	brpl	.-8      	; 0x308c <socket+0x146>
    3094:	80 95       	com	r24
    3096:	90 95       	com	r25
   //
	sock_io_mode |= ((flag & SF_IO_NONBLOCK) << sn);   
    3098:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <sock_io_mode>
    309c:	30 91 28 08 	lds	r19, 0x0828	; 0x800828 <sock_io_mode+0x1>
    30a0:	28 23       	and	r18, r24
    30a2:	39 23       	and	r19, r25
    30a4:	00 fb       	bst	r16, 0
    30a6:	ee 24       	eor	r14, r14
    30a8:	e0 f8       	bld	r14, 0
    30aa:	f1 2c       	mov	r15, r1
    30ac:	01 2e       	mov	r0, r17
    30ae:	02 c0       	rjmp	.+4      	; 0x30b4 <socket+0x16e>
    30b0:	ee 0c       	add	r14, r14
    30b2:	ff 1c       	adc	r15, r15
    30b4:	0a 94       	dec	r0
    30b6:	e2 f7       	brpl	.-8      	; 0x30b0 <socket+0x16a>
    30b8:	e2 2a       	or	r14, r18
    30ba:	f3 2a       	or	r15, r19
    30bc:	f0 92 28 08 	sts	0x0828, r15	; 0x800828 <sock_io_mode+0x1>
    30c0:	e0 92 27 08 	sts	0x0827, r14	; 0x800827 <sock_io_mode>
   sock_is_sending &= ~(1<<sn);
    30c4:	20 91 25 08 	lds	r18, 0x0825	; 0x800825 <sock_is_sending>
    30c8:	30 91 26 08 	lds	r19, 0x0826	; 0x800826 <sock_is_sending+0x1>
    30cc:	82 23       	and	r24, r18
    30ce:	93 23       	and	r25, r19
    30d0:	90 93 26 08 	sts	0x0826, r25	; 0x800826 <sock_is_sending+0x1>
    30d4:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <sock_is_sending>
   sock_remained_size[sn] = 0;
    30d8:	f5 01       	movw	r30, r10
    30da:	ee 0f       	add	r30, r30
    30dc:	ff 1f       	adc	r31, r31
    30de:	eb 5e       	subi	r30, 0xEB	; 235
    30e0:	f7 4f       	sbci	r31, 0xF7	; 247
    30e2:	11 82       	std	Z+1, r1	; 0x01
    30e4:	10 82       	st	Z, r1
   //M20150601 : repalce 0 with PACK_COMPLETED
   //sock_pack_info[sn] = 0;
   sock_pack_info[sn] = PACK_COMPLETED;
    30e6:	f5 01       	movw	r30, r10
    30e8:	e3 5f       	subi	r30, 0xF3	; 243
    30ea:	f7 4f       	sbci	r31, 0xF7	; 247
    30ec:	10 82       	st	Z, r1
   //
   while(getSn_SR(sn) == SOCK_CLOSED);
    30ee:	2d ef       	ldi	r18, 0xFD	; 253
    30f0:	d2 1a       	sub	r13, r18
    30f2:	0d 2c       	mov	r0, r13
    30f4:	00 0c       	add	r0, r0
    30f6:	ee 08       	sbc	r14, r14
    30f8:	ff 08       	sbc	r15, r15
    30fa:	c7 01       	movw	r24, r14
    30fc:	b6 01       	movw	r22, r12
    30fe:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3102:	88 23       	and	r24, r24
    3104:	d1 f3       	breq	.-12     	; 0x30fa <socket+0x1b4>
   return (int8_t)sn;
    3106:	81 2f       	mov	r24, r17
    3108:	05 c0       	rjmp	.+10     	; 0x3114 <socket+0x1ce>



int8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag)
{
	CHECK_SOCKNUM();
    310a:	8f ef       	ldi	r24, 0xFF	; 255
    310c:	03 c0       	rjmp	.+6      	; 0x3114 <socket+0x1ce>
   #if ( _WIZCHIP_ < 5200 )
      case Sn_MR_PPPoE :
         break;
   #endif
      default :
         return SOCKERR_SOCKMODE;
    310e:	8b ef       	ldi	r24, 0xFB	; 251
    3110:	01 c0       	rjmp	.+2      	; 0x3114 <socket+0x1ce>
	}
	//M20150601 : For SF_TCP_ALIGN & W5300
	//if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
    3112:	8a ef       	ldi	r24, 0xFA	; 250
   //sock_pack_info[sn] = 0;
   sock_pack_info[sn] = PACK_COMPLETED;
   //
   while(getSn_SR(sn) == SOCK_CLOSED);
   return (int8_t)sn;
}	   
    3114:	0f 90       	pop	r0
    3116:	0f 90       	pop	r0
    3118:	0f 90       	pop	r0
    311a:	0f 90       	pop	r0
    311c:	df 91       	pop	r29
    311e:	cf 91       	pop	r28
    3120:	1f 91       	pop	r17
    3122:	0f 91       	pop	r16
    3124:	ff 90       	pop	r15
    3126:	ef 90       	pop	r14
    3128:	df 90       	pop	r13
    312a:	cf 90       	pop	r12
    312c:	bf 90       	pop	r11
    312e:	af 90       	pop	r10
    3130:	9f 90       	pop	r9
    3132:	8f 90       	pop	r8
    3134:	7f 90       	pop	r7
    3136:	6f 90       	pop	r6
    3138:	5f 90       	pop	r5
    313a:	4f 90       	pop	r4
    313c:	08 95       	ret

0000313e <listen>:
	while(getSn_SR(sn) != SOCK_CLOSED);
	return SOCK_OK;
}

int8_t listen(uint8_t sn)
{
    313e:	8f 92       	push	r8
    3140:	9f 92       	push	r9
    3142:	af 92       	push	r10
    3144:	bf 92       	push	r11
    3146:	cf 92       	push	r12
    3148:	df 92       	push	r13
    314a:	ef 92       	push	r14
    314c:	ff 92       	push	r15
    314e:	cf 93       	push	r28
	CHECK_SOCKNUM();
    3150:	89 30       	cpi	r24, 0x09	; 9
    3152:	08 f0       	brcs	.+2      	; 0x3156 <listen+0x18>
    3154:	41 c0       	rjmp	.+130    	; 0x31d8 <listen+0x9a>
    3156:	c8 2f       	mov	r28, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    3158:	84 e0       	ldi	r24, 0x04	; 4
    315a:	c8 9f       	mul	r28, r24
    315c:	60 01       	movw	r12, r0
    315e:	11 24       	eor	r1, r1
    3160:	8f ef       	ldi	r24, 0xFF	; 255
    3162:	c8 1a       	sub	r12, r24
    3164:	d8 0a       	sbc	r13, r24
    3166:	83 e0       	ldi	r24, 0x03	; 3
    3168:	cc 0c       	add	r12, r12
    316a:	dd 1c       	adc	r13, r13
    316c:	8a 95       	dec	r24
    316e:	e1 f7       	brne	.-8      	; 0x3168 <listen+0x2a>
    3170:	b6 01       	movw	r22, r12
    3172:	0d 2c       	mov	r0, r13
    3174:	00 0c       	add	r0, r0
    3176:	88 0b       	sbc	r24, r24
    3178:	99 0b       	sbc	r25, r25
    317a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    317e:	8f 70       	andi	r24, 0x0F	; 15
    3180:	81 30       	cpi	r24, 0x01	; 1
    3182:	61 f5       	brne	.+88     	; 0x31dc <listen+0x9e>
	CHECK_SOCKINIT();
    3184:	46 01       	movw	r8, r12
    3186:	8d ef       	ldi	r24, 0xFD	; 253
    3188:	98 1a       	sub	r9, r24
    318a:	09 2c       	mov	r0, r9
    318c:	00 0c       	add	r0, r0
    318e:	aa 08       	sbc	r10, r10
    3190:	bb 08       	sbc	r11, r11
    3192:	c5 01       	movw	r24, r10
    3194:	b4 01       	movw	r22, r8
    3196:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    319a:	83 31       	cpi	r24, 0x13	; 19
    319c:	09 f5       	brne	.+66     	; 0x31e0 <listen+0xa2>
	setSn_CR(sn,Sn_CR_LISTEN);
    319e:	d3 94       	inc	r13
    31a0:	0d 2c       	mov	r0, r13
    31a2:	00 0c       	add	r0, r0
    31a4:	ee 08       	sbc	r14, r14
    31a6:	ff 08       	sbc	r15, r15
    31a8:	42 e0       	ldi	r20, 0x02	; 2
    31aa:	c7 01       	movw	r24, r14
    31ac:	b6 01       	movw	r22, r12
    31ae:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
	while(getSn_CR(sn));
    31b2:	c7 01       	movw	r24, r14
    31b4:	b6 01       	movw	r22, r12
    31b6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    31ba:	81 11       	cpse	r24, r1
    31bc:	fa cf       	rjmp	.-12     	; 0x31b2 <listen+0x74>
   while(getSn_SR(sn) != SOCK_LISTEN)
    31be:	c5 01       	movw	r24, r10
    31c0:	b4 01       	movw	r22, r8
    31c2:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    31c6:	84 31       	cpi	r24, 0x14	; 20
    31c8:	29 f0       	breq	.+10     	; 0x31d4 <listen+0x96>
   {
         close(sn);
    31ca:	8c 2f       	mov	r24, r28
    31cc:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
         return SOCKERR_SOCKCLOSED;
    31d0:	8c ef       	ldi	r24, 0xFC	; 252
    31d2:	07 c0       	rjmp	.+14     	; 0x31e2 <listen+0xa4>
   }
   return SOCK_OK;
    31d4:	81 e0       	ldi	r24, 0x01	; 1
    31d6:	05 c0       	rjmp	.+10     	; 0x31e2 <listen+0xa4>
	return SOCK_OK;
}

int8_t listen(uint8_t sn)
{
	CHECK_SOCKNUM();
    31d8:	8f ef       	ldi	r24, 0xFF	; 255
    31da:	03 c0       	rjmp	.+6      	; 0x31e2 <listen+0xa4>
   CHECK_SOCKMODE(Sn_MR_TCP);
    31dc:	8b ef       	ldi	r24, 0xFB	; 251
    31de:	01 c0       	rjmp	.+2      	; 0x31e2 <listen+0xa4>
	CHECK_SOCKINIT();
    31e0:	8d ef       	ldi	r24, 0xFD	; 253
   {
         close(sn);
         return SOCKERR_SOCKCLOSED;
   }
   return SOCK_OK;
}
    31e2:	cf 91       	pop	r28
    31e4:	ff 90       	pop	r15
    31e6:	ef 90       	pop	r14
    31e8:	df 90       	pop	r13
    31ea:	cf 90       	pop	r12
    31ec:	bf 90       	pop	r11
    31ee:	af 90       	pop	r10
    31f0:	9f 90       	pop	r9
    31f2:	8f 90       	pop	r8
    31f4:	08 95       	ret

000031f6 <connect>:


int8_t connect(uint8_t sn, uint8_t * addr, uint16_t port)
{
    31f6:	7f 92       	push	r7
    31f8:	8f 92       	push	r8
    31fa:	9f 92       	push	r9
    31fc:	af 92       	push	r10
    31fe:	bf 92       	push	r11
    3200:	cf 92       	push	r12
    3202:	df 92       	push	r13
    3204:	ef 92       	push	r14
    3206:	ff 92       	push	r15
    3208:	0f 93       	push	r16
    320a:	1f 93       	push	r17
    320c:	cf 93       	push	r28
    320e:	df 93       	push	r29
   CHECK_SOCKNUM();
    3210:	89 30       	cpi	r24, 0x09	; 9
    3212:	08 f0       	brcs	.+2      	; 0x3216 <connect+0x20>
    3214:	b5 c0       	rjmp	.+362    	; 0x3380 <connect+0x18a>
    3216:	6a 01       	movw	r12, r20
    3218:	7b 01       	movw	r14, r22
    321a:	78 2e       	mov	r7, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    321c:	84 e0       	ldi	r24, 0x04	; 4
    321e:	78 9e       	mul	r7, r24
    3220:	e0 01       	movw	r28, r0
    3222:	11 24       	eor	r1, r1
    3224:	21 96       	adiw	r28, 0x01	; 1
    3226:	53 e0       	ldi	r21, 0x03	; 3
    3228:	cc 0f       	add	r28, r28
    322a:	dd 1f       	adc	r29, r29
    322c:	5a 95       	dec	r21
    322e:	e1 f7       	brne	.-8      	; 0x3228 <connect+0x32>
    3230:	be 01       	movw	r22, r28
    3232:	0d 2e       	mov	r0, r29
    3234:	00 0c       	add	r0, r0
    3236:	88 0b       	sbc	r24, r24
    3238:	99 0b       	sbc	r25, r25
    323a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    323e:	8f 70       	andi	r24, 0x0F	; 15
    3240:	81 30       	cpi	r24, 0x01	; 1
    3242:	09 f0       	breq	.+2      	; 0x3246 <connect+0x50>
    3244:	9f c0       	rjmp	.+318    	; 0x3384 <connect+0x18e>
   CHECK_SOCKINIT();
    3246:	4e 01       	movw	r8, r28
    3248:	ed ef       	ldi	r30, 0xFD	; 253
    324a:	9e 1a       	sub	r9, r30
    324c:	09 2c       	mov	r0, r9
    324e:	00 0c       	add	r0, r0
    3250:	aa 08       	sbc	r10, r10
    3252:	bb 08       	sbc	r11, r11
    3254:	c5 01       	movw	r24, r10
    3256:	b4 01       	movw	r22, r8
    3258:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    325c:	83 31       	cpi	r24, 0x13	; 19
    325e:	09 f0       	breq	.+2      	; 0x3262 <connect+0x6c>
    3260:	93 c0       	rjmp	.+294    	; 0x3388 <connect+0x192>
   //M20140501 : For avoiding fatal error on memory align mismatched
   //if( *((uint32_t*)addr) == 0xFFFFFFFF || *((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   {
      uint32_t taddr;
      taddr = ((uint32_t)addr[0] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
    3262:	f7 01       	movw	r30, r14
    3264:	00 81       	ld	r16, Z
    3266:	10 e0       	ldi	r17, 0x00	; 0
    3268:	20 e0       	ldi	r18, 0x00	; 0
    326a:	30 e0       	ldi	r19, 0x00	; 0
    326c:	32 2f       	mov	r19, r18
    326e:	21 2f       	mov	r18, r17
    3270:	10 2f       	mov	r17, r16
    3272:	00 27       	eor	r16, r16
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
    3274:	81 81       	ldd	r24, Z+1	; 0x01
    3276:	08 0f       	add	r16, r24
    3278:	11 1d       	adc	r17, r1
    327a:	21 1d       	adc	r18, r1
    327c:	31 1d       	adc	r19, r1
    327e:	32 2f       	mov	r19, r18
    3280:	21 2f       	mov	r18, r17
    3282:	10 2f       	mov	r17, r16
    3284:	00 27       	eor	r16, r16
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
      if( taddr == 0xFFFFFFFF || taddr == 0) return SOCKERR_IPINVALID;
    3286:	82 81       	ldd	r24, Z+2	; 0x02
    3288:	08 0f       	add	r16, r24
    328a:	11 1d       	adc	r17, r1
    328c:	21 1d       	adc	r18, r1
    328e:	31 1d       	adc	r19, r1
    3290:	32 2f       	mov	r19, r18
    3292:	21 2f       	mov	r18, r17
    3294:	10 2f       	mov	r17, r16
    3296:	00 27       	eor	r16, r16
    3298:	83 81       	ldd	r24, Z+3	; 0x03
    329a:	90 e0       	ldi	r25, 0x00	; 0
    329c:	a0 e0       	ldi	r26, 0x00	; 0
    329e:	b0 e0       	ldi	r27, 0x00	; 0
    32a0:	01 97       	sbiw	r24, 0x01	; 1
    32a2:	a1 09       	sbc	r26, r1
    32a4:	b1 09       	sbc	r27, r1
    32a6:	08 0f       	add	r16, r24
    32a8:	19 1f       	adc	r17, r25
    32aa:	2a 1f       	adc	r18, r26
    32ac:	3b 1f       	adc	r19, r27
    32ae:	0e 3f       	cpi	r16, 0xFE	; 254
    32b0:	1f 4f       	sbci	r17, 0xFF	; 255
    32b2:	2f 4f       	sbci	r18, 0xFF	; 255
    32b4:	3f 4f       	sbci	r19, 0xFF	; 255
    32b6:	08 f0       	brcs	.+2      	; 0x32ba <connect+0xc4>
    32b8:	69 c0       	rjmp	.+210    	; 0x338c <connect+0x196>
   }
   //
	
	if(port == 0) return SOCKERR_PORTZERO;
    32ba:	c1 14       	cp	r12, r1
    32bc:	d1 04       	cpc	r13, r1
    32be:	09 f4       	brne	.+2      	; 0x32c2 <connect+0xcc>
    32c0:	67 c0       	rjmp	.+206    	; 0x3390 <connect+0x19a>
	setSn_DIPR(sn,addr);
    32c2:	be 01       	movw	r22, r28
    32c4:	74 5f       	subi	r23, 0xF4	; 244
    32c6:	07 2e       	mov	r0, r23
    32c8:	00 0c       	add	r0, r0
    32ca:	88 0b       	sbc	r24, r24
    32cc:	99 0b       	sbc	r25, r25
    32ce:	24 e0       	ldi	r18, 0x04	; 4
    32d0:	30 e0       	ldi	r19, 0x00	; 0
    32d2:	a7 01       	movw	r20, r14
    32d4:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
	setSn_DPORT(sn,port);
    32d8:	be 01       	movw	r22, r28
    32da:	70 5f       	subi	r23, 0xF0	; 240
    32dc:	07 2e       	mov	r0, r23
    32de:	00 0c       	add	r0, r0
    32e0:	88 0b       	sbc	r24, r24
    32e2:	99 0b       	sbc	r25, r25
    32e4:	4d 2d       	mov	r20, r13
    32e6:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    32ea:	be 01       	movw	r22, r28
    32ec:	7f 5e       	subi	r23, 0xEF	; 239
    32ee:	07 2e       	mov	r0, r23
    32f0:	00 0c       	add	r0, r0
    32f2:	88 0b       	sbc	r24, r24
    32f4:	99 0b       	sbc	r25, r25
    32f6:	4c 2d       	mov	r20, r12
    32f8:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
	setSn_CR(sn,Sn_CR_CONNECT);
    32fc:	6e 01       	movw	r12, r28
    32fe:	d3 94       	inc	r13
    3300:	0d 2c       	mov	r0, r13
    3302:	00 0c       	add	r0, r0
    3304:	ee 08       	sbc	r14, r14
    3306:	ff 08       	sbc	r15, r15
    3308:	44 e0       	ldi	r20, 0x04	; 4
    330a:	c7 01       	movw	r24, r14
    330c:	b6 01       	movw	r22, r12
    330e:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   while(getSn_CR(sn));
    3312:	c7 01       	movw	r24, r14
    3314:	b6 01       	movw	r22, r12
    3316:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    331a:	81 11       	cpse	r24, r1
    331c:	fa cf       	rjmp	.-12     	; 0x3312 <connect+0x11c>
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    331e:	81 e0       	ldi	r24, 0x01	; 1
    3320:	90 e0       	ldi	r25, 0x00	; 0
    3322:	02 c0       	rjmp	.+4      	; 0x3328 <connect+0x132>
    3324:	88 0f       	add	r24, r24
    3326:	99 1f       	adc	r25, r25
    3328:	7a 94       	dec	r7
    332a:	e2 f7       	brpl	.-8      	; 0x3324 <connect+0x12e>
    332c:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <sock_io_mode>
    3330:	30 91 28 08 	lds	r19, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3334:	82 23       	and	r24, r18
    3336:	93 23       	and	r25, r19
    3338:	89 2b       	or	r24, r25
    333a:	61 f5       	brne	.+88     	; 0x3394 <connect+0x19e>
   while(getSn_SR(sn) != SOCK_ESTABLISHED)
   {
		if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    333c:	de 5f       	subi	r29, 0xFE	; 254
    333e:	6e 01       	movw	r12, r28
    3340:	dd 0f       	add	r29, r29
    3342:	ee 08       	sbc	r14, r14
    3344:	ff 08       	sbc	r15, r15
	setSn_DIPR(sn,addr);
	setSn_DPORT(sn,port);
	setSn_CR(sn,Sn_CR_CONNECT);
   while(getSn_CR(sn));
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
   while(getSn_SR(sn) != SOCK_ESTABLISHED)
    3346:	c5 01       	movw	r24, r10
    3348:	b4 01       	movw	r22, r8
    334a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    334e:	87 31       	cpi	r24, 0x17	; 23
    3350:	a9 f0       	breq	.+42     	; 0x337c <connect+0x186>
   {
		if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    3352:	c7 01       	movw	r24, r14
    3354:	b6 01       	movw	r22, r12
    3356:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    335a:	83 ff       	sbrs	r24, 3
    335c:	07 c0       	rjmp	.+14     	; 0x336c <connect+0x176>
		{
			setSn_IR(sn, Sn_IR_TIMEOUT);
    335e:	48 e0       	ldi	r20, 0x08	; 8
    3360:	c7 01       	movw	r24, r14
    3362:	b6 01       	movw	r22, r12
    3364:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
            return SOCKERR_TIMEOUT;
    3368:	83 ef       	ldi	r24, 0xF3	; 243
    336a:	15 c0       	rjmp	.+42     	; 0x3396 <connect+0x1a0>
		}

		if (getSn_SR(sn) == SOCK_CLOSED)
    336c:	c5 01       	movw	r24, r10
    336e:	b4 01       	movw	r22, r8
    3370:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3374:	81 11       	cpse	r24, r1
    3376:	e7 cf       	rjmp	.-50     	; 0x3346 <connect+0x150>
		{
			return SOCKERR_SOCKCLOSED;
    3378:	8c ef       	ldi	r24, 0xFC	; 252
    337a:	0d c0       	rjmp	.+26     	; 0x3396 <connect+0x1a0>
		}
	}
   
   return SOCK_OK;
    337c:	81 e0       	ldi	r24, 0x01	; 1
    337e:	0b c0       	rjmp	.+22     	; 0x3396 <connect+0x1a0>
}


int8_t connect(uint8_t sn, uint8_t * addr, uint16_t port)
{
   CHECK_SOCKNUM();
    3380:	8f ef       	ldi	r24, 0xFF	; 255
    3382:	09 c0       	rjmp	.+18     	; 0x3396 <connect+0x1a0>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3384:	8b ef       	ldi	r24, 0xFB	; 251
    3386:	07 c0       	rjmp	.+14     	; 0x3396 <connect+0x1a0>
   CHECK_SOCKINIT();
    3388:	8d ef       	ldi	r24, 0xFD	; 253
    338a:	05 c0       	rjmp	.+10     	; 0x3396 <connect+0x1a0>
      uint32_t taddr;
      taddr = ((uint32_t)addr[0] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
      if( taddr == 0xFFFFFFFF || taddr == 0) return SOCKERR_IPINVALID;
    338c:	84 ef       	ldi	r24, 0xF4	; 244
    338e:	03 c0       	rjmp	.+6      	; 0x3396 <connect+0x1a0>
   }
   //
	
	if(port == 0) return SOCKERR_PORTZERO;
    3390:	85 ef       	ldi	r24, 0xF5	; 245
    3392:	01 c0       	rjmp	.+2      	; 0x3396 <connect+0x1a0>
	setSn_DIPR(sn,addr);
	setSn_DPORT(sn,port);
	setSn_CR(sn,Sn_CR_CONNECT);
   while(getSn_CR(sn));
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    3394:	80 e0       	ldi	r24, 0x00	; 0
			return SOCKERR_SOCKCLOSED;
		}
	}
   
   return SOCK_OK;
}
    3396:	df 91       	pop	r29
    3398:	cf 91       	pop	r28
    339a:	1f 91       	pop	r17
    339c:	0f 91       	pop	r16
    339e:	ff 90       	pop	r15
    33a0:	ef 90       	pop	r14
    33a2:	df 90       	pop	r13
    33a4:	cf 90       	pop	r12
    33a6:	bf 90       	pop	r11
    33a8:	af 90       	pop	r10
    33aa:	9f 90       	pop	r9
    33ac:	8f 90       	pop	r8
    33ae:	7f 90       	pop	r7
    33b0:	08 95       	ret

000033b2 <disconnect>:

int8_t disconnect(uint8_t sn)
{
    33b2:	8f 92       	push	r8
    33b4:	9f 92       	push	r9
    33b6:	af 92       	push	r10
    33b8:	bf 92       	push	r11
    33ba:	cf 92       	push	r12
    33bc:	df 92       	push	r13
    33be:	ef 92       	push	r14
    33c0:	ff 92       	push	r15
    33c2:	cf 93       	push	r28
   CHECK_SOCKNUM();
    33c4:	89 30       	cpi	r24, 0x09	; 9
    33c6:	08 f0       	brcs	.+2      	; 0x33ca <disconnect+0x18>
    33c8:	66 c0       	rjmp	.+204    	; 0x3496 <disconnect+0xe4>
    33ca:	c8 2f       	mov	r28, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    33cc:	84 e0       	ldi	r24, 0x04	; 4
    33ce:	c8 9f       	mul	r28, r24
    33d0:	60 01       	movw	r12, r0
    33d2:	11 24       	eor	r1, r1
    33d4:	8f ef       	ldi	r24, 0xFF	; 255
    33d6:	c8 1a       	sub	r12, r24
    33d8:	d8 0a       	sbc	r13, r24
    33da:	83 e0       	ldi	r24, 0x03	; 3
    33dc:	cc 0c       	add	r12, r12
    33de:	dd 1c       	adc	r13, r13
    33e0:	8a 95       	dec	r24
    33e2:	e1 f7       	brne	.-8      	; 0x33dc <disconnect+0x2a>
    33e4:	b6 01       	movw	r22, r12
    33e6:	0d 2c       	mov	r0, r13
    33e8:	00 0c       	add	r0, r0
    33ea:	88 0b       	sbc	r24, r24
    33ec:	99 0b       	sbc	r25, r25
    33ee:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    33f2:	8f 70       	andi	r24, 0x0F	; 15
    33f4:	81 30       	cpi	r24, 0x01	; 1
    33f6:	09 f0       	breq	.+2      	; 0x33fa <disconnect+0x48>
    33f8:	50 c0       	rjmp	.+160    	; 0x349a <disconnect+0xe8>
	setSn_CR(sn,Sn_CR_DISCON);
    33fa:	46 01       	movw	r8, r12
    33fc:	93 94       	inc	r9
    33fe:	09 2c       	mov	r0, r9
    3400:	00 0c       	add	r0, r0
    3402:	aa 08       	sbc	r10, r10
    3404:	bb 08       	sbc	r11, r11
    3406:	48 e0       	ldi	r20, 0x08	; 8
    3408:	c5 01       	movw	r24, r10
    340a:	b4 01       	movw	r22, r8
    340c:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
	/* wait to process the command... */
	while(getSn_CR(sn));
    3410:	c5 01       	movw	r24, r10
    3412:	b4 01       	movw	r22, r8
    3414:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3418:	81 11       	cpse	r24, r1
    341a:	fa cf       	rjmp	.-12     	; 0x3410 <disconnect+0x5e>
	sock_is_sending &= ~(1<<sn);
    341c:	81 e0       	ldi	r24, 0x01	; 1
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	0c 2e       	mov	r0, r28
    3422:	02 c0       	rjmp	.+4      	; 0x3428 <disconnect+0x76>
    3424:	88 0f       	add	r24, r24
    3426:	99 1f       	adc	r25, r25
    3428:	0a 94       	dec	r0
    342a:	e2 f7       	brpl	.-8      	; 0x3424 <disconnect+0x72>
    342c:	9c 01       	movw	r18, r24
    342e:	20 95       	com	r18
    3430:	30 95       	com	r19
    3432:	40 91 25 08 	lds	r20, 0x0825	; 0x800825 <sock_is_sending>
    3436:	50 91 26 08 	lds	r21, 0x0826	; 0x800826 <sock_is_sending+0x1>
    343a:	24 23       	and	r18, r20
    343c:	35 23       	and	r19, r21
    343e:	30 93 26 08 	sts	0x0826, r19	; 0x800826 <sock_is_sending+0x1>
    3442:	20 93 25 08 	sts	0x0825, r18	; 0x800825 <sock_is_sending>
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    3446:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <sock_io_mode>
    344a:	30 91 28 08 	lds	r19, 0x0828	; 0x800828 <sock_io_mode+0x1>
    344e:	82 23       	and	r24, r18
    3450:	93 23       	and	r25, r19
    3452:	89 2b       	or	r24, r25
    3454:	21 f5       	brne	.+72     	; 0x349e <disconnect+0xec>
	while(getSn_SR(sn) != SOCK_CLOSED)
    3456:	46 01       	movw	r8, r12
    3458:	8d ef       	ldi	r24, 0xFD	; 253
    345a:	98 1a       	sub	r9, r24
    345c:	09 2c       	mov	r0, r9
    345e:	00 0c       	add	r0, r0
    3460:	aa 08       	sbc	r10, r10
    3462:	bb 08       	sbc	r11, r11
	{
	   if(getSn_IR(sn) & Sn_IR_TIMEOUT)
    3464:	8e ef       	ldi	r24, 0xFE	; 254
    3466:	d8 1a       	sub	r13, r24
    3468:	0d 2c       	mov	r0, r13
    346a:	00 0c       	add	r0, r0
    346c:	ee 08       	sbc	r14, r14
    346e:	ff 08       	sbc	r15, r15
	setSn_CR(sn,Sn_CR_DISCON);
	/* wait to process the command... */
	while(getSn_CR(sn));
	sock_is_sending &= ~(1<<sn);
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
	while(getSn_SR(sn) != SOCK_CLOSED)
    3470:	c5 01       	movw	r24, r10
    3472:	b4 01       	movw	r22, r8
    3474:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3478:	88 23       	and	r24, r24
    347a:	59 f0       	breq	.+22     	; 0x3492 <disconnect+0xe0>
	{
	   if(getSn_IR(sn) & Sn_IR_TIMEOUT)
    347c:	c7 01       	movw	r24, r14
    347e:	b6 01       	movw	r22, r12
    3480:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3484:	83 ff       	sbrs	r24, 3
    3486:	f4 cf       	rjmp	.-24     	; 0x3470 <disconnect+0xbe>
	   {
	      close(sn);
    3488:	8c 2f       	mov	r24, r28
    348a:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
	      return SOCKERR_TIMEOUT;
    348e:	83 ef       	ldi	r24, 0xF3	; 243
    3490:	07 c0       	rjmp	.+14     	; 0x34a0 <disconnect+0xee>
	   }
	}
	return SOCK_OK;
    3492:	81 e0       	ldi	r24, 0x01	; 1
    3494:	05 c0       	rjmp	.+10     	; 0x34a0 <disconnect+0xee>
   return SOCK_OK;
}

int8_t disconnect(uint8_t sn)
{
   CHECK_SOCKNUM();
    3496:	8f ef       	ldi	r24, 0xFF	; 255
    3498:	03 c0       	rjmp	.+6      	; 0x34a0 <disconnect+0xee>
   CHECK_SOCKMODE(Sn_MR_TCP);
    349a:	8b ef       	ldi	r24, 0xFB	; 251
    349c:	01 c0       	rjmp	.+2      	; 0x34a0 <disconnect+0xee>
	setSn_CR(sn,Sn_CR_DISCON);
	/* wait to process the command... */
	while(getSn_CR(sn));
	sock_is_sending &= ~(1<<sn);
   if(sock_io_mode & (1<<sn)) return SOCK_BUSY;
    349e:	80 e0       	ldi	r24, 0x00	; 0
	      close(sn);
	      return SOCKERR_TIMEOUT;
	   }
	}
	return SOCK_OK;
}
    34a0:	cf 91       	pop	r28
    34a2:	ff 90       	pop	r15
    34a4:	ef 90       	pop	r14
    34a6:	df 90       	pop	r13
    34a8:	cf 90       	pop	r12
    34aa:	bf 90       	pop	r11
    34ac:	af 90       	pop	r10
    34ae:	9f 90       	pop	r9
    34b0:	8f 90       	pop	r8
    34b2:	08 95       	ret

000034b4 <send>:

int32_t send(uint8_t sn, uint8_t * buf, uint16_t len)
{
    34b4:	2f 92       	push	r2
    34b6:	3f 92       	push	r3
    34b8:	4f 92       	push	r4
    34ba:	5f 92       	push	r5
    34bc:	7f 92       	push	r7
    34be:	8f 92       	push	r8
    34c0:	9f 92       	push	r9
    34c2:	af 92       	push	r10
    34c4:	bf 92       	push	r11
    34c6:	cf 92       	push	r12
    34c8:	df 92       	push	r13
    34ca:	ef 92       	push	r14
    34cc:	ff 92       	push	r15
    34ce:	0f 93       	push	r16
    34d0:	1f 93       	push	r17
    34d2:	cf 93       	push	r28
    34d4:	df 93       	push	r29
    34d6:	00 d0       	rcall	.+0      	; 0x34d8 <send+0x24>
    34d8:	00 d0       	rcall	.+0      	; 0x34da <send+0x26>
    34da:	cd b7       	in	r28, 0x3d	; 61
    34dc:	de b7       	in	r29, 0x3e	; 62
   uint8_t tmp=0;
   uint16_t freesize=0;
   
   CHECK_SOCKNUM();
    34de:	89 30       	cpi	r24, 0x09	; 9
    34e0:	08 f0       	brcs	.+2      	; 0x34e4 <send+0x30>
    34e2:	ce c0       	rjmp	.+412    	; 0x3680 <send+0x1cc>
    34e4:	5c 83       	std	Y+4, r21	; 0x04
    34e6:	4b 83       	std	Y+3, r20	; 0x03
    34e8:	7a 83       	std	Y+2, r23	; 0x02
    34ea:	69 83       	std	Y+1, r22	; 0x01
    34ec:	78 2e       	mov	r7, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    34ee:	24 e0       	ldi	r18, 0x04	; 4
    34f0:	82 9f       	mul	r24, r18
    34f2:	80 01       	movw	r16, r0
    34f4:	11 24       	eor	r1, r1
    34f6:	0f 5f       	subi	r16, 0xFF	; 255
    34f8:	1f 4f       	sbci	r17, 0xFF	; 255
    34fa:	33 e0       	ldi	r19, 0x03	; 3
    34fc:	00 0f       	add	r16, r16
    34fe:	11 1f       	adc	r17, r17
    3500:	3a 95       	dec	r19
    3502:	e1 f7       	brne	.-8      	; 0x34fc <send+0x48>
    3504:	b8 01       	movw	r22, r16
    3506:	01 2e       	mov	r0, r17
    3508:	00 0c       	add	r0, r0
    350a:	88 0b       	sbc	r24, r24
    350c:	99 0b       	sbc	r25, r25
    350e:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3512:	8f 70       	andi	r24, 0x0F	; 15
    3514:	81 30       	cpi	r24, 0x01	; 1
    3516:	09 f0       	breq	.+2      	; 0x351a <send+0x66>
    3518:	b7 c0       	rjmp	.+366    	; 0x3688 <send+0x1d4>
   CHECK_SOCKDATA();
    351a:	8b 81       	ldd	r24, Y+3	; 0x03
    351c:	9c 81       	ldd	r25, Y+4	; 0x04
    351e:	89 2b       	or	r24, r25
    3520:	09 f4       	brne	.+2      	; 0x3524 <send+0x70>
    3522:	b7 c0       	rjmp	.+366    	; 0x3692 <send+0x1de>
   tmp = getSn_SR(sn);
    3524:	48 01       	movw	r8, r16
    3526:	9d ef       	ldi	r25, 0xFD	; 253
    3528:	99 1a       	sub	r9, r25
    352a:	09 2c       	mov	r0, r9
    352c:	00 0c       	add	r0, r0
    352e:	aa 08       	sbc	r10, r10
    3530:	bb 08       	sbc	r11, r11
    3532:	c5 01       	movw	r24, r10
    3534:	b4 01       	movw	r22, r8
    3536:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
    353a:	87 31       	cpi	r24, 0x17	; 23
    353c:	19 f0       	breq	.+6      	; 0x3544 <send+0x90>
    353e:	8c 31       	cpi	r24, 0x1C	; 28
    3540:	09 f0       	breq	.+2      	; 0x3544 <send+0x90>
    3542:	ac c0       	rjmp	.+344    	; 0x369c <send+0x1e8>
   if( sock_is_sending & (1<<sn) )
    3544:	81 e0       	ldi	r24, 0x01	; 1
    3546:	90 e0       	ldi	r25, 0x00	; 0
    3548:	7c 01       	movw	r14, r24
    354a:	07 2c       	mov	r0, r7
    354c:	02 c0       	rjmp	.+4      	; 0x3552 <send+0x9e>
    354e:	ee 0c       	add	r14, r14
    3550:	ff 1c       	adc	r15, r15
    3552:	0a 94       	dec	r0
    3554:	e2 f7       	brpl	.-8      	; 0x354e <send+0x9a>
    3556:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <sock_is_sending>
    355a:	90 91 26 08 	lds	r25, 0x0826	; 0x800826 <sock_is_sending+0x1>
    355e:	8e 21       	and	r24, r14
    3560:	9f 21       	and	r25, r15
    3562:	89 2b       	or	r24, r25
    3564:	71 f1       	breq	.+92     	; 0x35c2 <send+0x10e>
   {
      tmp = getSn_IR(sn);
    3566:	18 01       	movw	r2, r16
    3568:	2e ef       	ldi	r18, 0xFE	; 254
    356a:	32 1a       	sub	r3, r18
    356c:	03 2c       	mov	r0, r3
    356e:	00 0c       	add	r0, r0
    3570:	44 08       	sbc	r4, r4
    3572:	55 08       	sbc	r5, r5
    3574:	c2 01       	movw	r24, r4
    3576:	b1 01       	movw	r22, r2
    3578:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
      if(tmp & Sn_IR_SENDOK)
    357c:	84 ff       	sbrs	r24, 4
    357e:	13 c0       	rjmp	.+38     	; 0x35a6 <send+0xf2>
      {
         setSn_IR(sn, Sn_IR_SENDOK);
    3580:	40 e1       	ldi	r20, 0x10	; 16
    3582:	c2 01       	movw	r24, r4
    3584:	b1 01       	movw	r22, r2
    3586:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
               setSn_CR(sn,Sn_CR_SEND);
               while(getSn_CR(sn));
               return SOCK_BUSY;
            }
         #endif
         sock_is_sending &= ~(1<<sn);         
    358a:	20 91 25 08 	lds	r18, 0x0825	; 0x800825 <sock_is_sending>
    358e:	30 91 26 08 	lds	r19, 0x0826	; 0x800826 <sock_is_sending+0x1>
    3592:	c7 01       	movw	r24, r14
    3594:	80 95       	com	r24
    3596:	90 95       	com	r25
    3598:	82 23       	and	r24, r18
    359a:	93 23       	and	r25, r19
    359c:	90 93 26 08 	sts	0x0826, r25	; 0x800826 <sock_is_sending+0x1>
    35a0:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <sock_is_sending>
    35a4:	0e c0       	rjmp	.+28     	; 0x35c2 <send+0x10e>
      }
      else if(tmp & Sn_IR_TIMEOUT)
    35a6:	83 fd       	sbrc	r24, 3
    35a8:	04 c0       	rjmp	.+8      	; 0x35b2 <send+0xfe>
      {
         close(sn);
         return SOCKERR_TIMEOUT;
      }
      else return SOCK_BUSY;
    35aa:	60 e0       	ldi	r22, 0x00	; 0
    35ac:	70 e0       	ldi	r23, 0x00	; 0
    35ae:	cb 01       	movw	r24, r22
    35b0:	79 c0       	rjmp	.+242    	; 0x36a4 <send+0x1f0>
         #endif
         sock_is_sending &= ~(1<<sn);         
      }
      else if(tmp & Sn_IR_TIMEOUT)
      {
         close(sn);
    35b2:	87 2d       	mov	r24, r7
    35b4:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
         return SOCKERR_TIMEOUT;
    35b8:	63 ef       	ldi	r22, 0xF3	; 243
    35ba:	7f ef       	ldi	r23, 0xFF	; 255
    35bc:	8f ef       	ldi	r24, 0xFF	; 255
    35be:	9f ef       	ldi	r25, 0xFF	; 255
    35c0:	71 c0       	rjmp	.+226    	; 0x36a4 <send+0x1f0>
      }
      else return SOCK_BUSY;
   }
   freesize = getSn_TxMAX(sn);
    35c2:	b8 01       	movw	r22, r16
    35c4:	71 5e       	subi	r23, 0xE1	; 225
    35c6:	07 2e       	mov	r0, r23
    35c8:	00 0c       	add	r0, r0
    35ca:	88 0b       	sbc	r24, r24
    35cc:	99 0b       	sbc	r25, r25
    35ce:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    35d2:	90 e0       	ldi	r25, 0x00	; 0
    35d4:	98 2f       	mov	r25, r24
    35d6:	88 27       	eor	r24, r24
    35d8:	99 0f       	add	r25, r25
    35da:	99 0f       	add	r25, r25
    35dc:	2b 81       	ldd	r18, Y+3	; 0x03
    35de:	3c 81       	ldd	r19, Y+4	; 0x04
    35e0:	82 17       	cp	r24, r18
    35e2:	93 07       	cpc	r25, r19
    35e4:	10 f4       	brcc	.+4      	; 0x35ea <send+0x136>
    35e6:	9c 83       	std	Y+4, r25	; 0x04
    35e8:	8b 83       	std	Y+3, r24	; 0x03
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
    35ea:	87 2d       	mov	r24, r7
    35ec:	0e 94 82 27 	call	0x4f04	; 0x4f04 <getSn_TX_FSR>
    35f0:	6c 01       	movw	r12, r24
      tmp = getSn_SR(sn);
    35f2:	c5 01       	movw	r24, r10
    35f4:	b4 01       	movw	r22, r8
    35f6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
      if ((tmp != SOCK_ESTABLISHED) && (tmp != SOCK_CLOSE_WAIT))
    35fa:	87 31       	cpi	r24, 0x17	; 23
    35fc:	31 f0       	breq	.+12     	; 0x360a <send+0x156>
    35fe:	8c 31       	cpi	r24, 0x1C	; 28
    3600:	21 f0       	breq	.+8      	; 0x360a <send+0x156>
      {
         close(sn);
    3602:	87 2d       	mov	r24, r7
    3604:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
    3608:	49 c0       	rjmp	.+146    	; 0x369c <send+0x1e8>
         return SOCKERR_SOCKSTATUS;
      }
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    360a:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <sock_io_mode>
    360e:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3612:	8e 21       	and	r24, r14
    3614:	9f 21       	and	r25, r15
    3616:	89 2b       	or	r24, r25
    3618:	31 f0       	breq	.+12     	; 0x3626 <send+0x172>
    361a:	8b 81       	ldd	r24, Y+3	; 0x03
    361c:	9c 81       	ldd	r25, Y+4	; 0x04
    361e:	c8 16       	cp	r12, r24
    3620:	d9 06       	cpc	r13, r25
    3622:	30 f4       	brcc	.+12     	; 0x3630 <send+0x17c>
    3624:	c2 cf       	rjmp	.-124    	; 0x35aa <send+0xf6>
      if(len <= freesize) break;
    3626:	2b 81       	ldd	r18, Y+3	; 0x03
    3628:	3c 81       	ldd	r19, Y+4	; 0x04
    362a:	c2 16       	cp	r12, r18
    362c:	d3 06       	cpc	r13, r19
    362e:	e8 f2       	brcs	.-70     	; 0x35ea <send+0x136>
   }
   wiz_send_data(sn, buf, len);
    3630:	4b 81       	ldd	r20, Y+3	; 0x03
    3632:	5c 81       	ldd	r21, Y+4	; 0x04
    3634:	69 81       	ldd	r22, Y+1	; 0x01
    3636:	7a 81       	ldd	r23, Y+2	; 0x02
    3638:	87 2d       	mov	r24, r7
    363a:	0e 94 32 28 	call	0x5064	; 0x5064 <wiz_send_data>

   #if _WIZCHIP_ == 5300
      setSn_TX_WRSR(sn,len);
   #endif
   
   setSn_CR(sn,Sn_CR_SEND);
    363e:	48 01       	movw	r8, r16
    3640:	93 94       	inc	r9
    3642:	09 2c       	mov	r0, r9
    3644:	00 0c       	add	r0, r0
    3646:	aa 08       	sbc	r10, r10
    3648:	bb 08       	sbc	r11, r11
    364a:	40 e2       	ldi	r20, 0x20	; 32
    364c:	c5 01       	movw	r24, r10
    364e:	b4 01       	movw	r22, r8
    3650:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   /* wait to process the command... */
   while(getSn_CR(sn));
    3654:	c5 01       	movw	r24, r10
    3656:	b4 01       	movw	r22, r8
    3658:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    365c:	81 11       	cpse	r24, r1
    365e:	fa cf       	rjmp	.-12     	; 0x3654 <send+0x1a0>
   sock_is_sending |= (1 << sn);
    3660:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <sock_is_sending>
    3664:	90 91 26 08 	lds	r25, 0x0826	; 0x800826 <sock_is_sending+0x1>
    3668:	e8 2a       	or	r14, r24
    366a:	f9 2a       	or	r15, r25
    366c:	f0 92 26 08 	sts	0x0826, r15	; 0x800826 <sock_is_sending+0x1>
    3670:	e0 92 25 08 	sts	0x0825, r14	; 0x800825 <sock_is_sending>
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    3674:	2b 81       	ldd	r18, Y+3	; 0x03
    3676:	3c 81       	ldd	r19, Y+4	; 0x04
    3678:	b9 01       	movw	r22, r18
    367a:	80 e0       	ldi	r24, 0x00	; 0
    367c:	90 e0       	ldi	r25, 0x00	; 0
    367e:	12 c0       	rjmp	.+36     	; 0x36a4 <send+0x1f0>
int32_t send(uint8_t sn, uint8_t * buf, uint16_t len)
{
   uint8_t tmp=0;
   uint16_t freesize=0;
   
   CHECK_SOCKNUM();
    3680:	6f ef       	ldi	r22, 0xFF	; 255
    3682:	7f ef       	ldi	r23, 0xFF	; 255
    3684:	cb 01       	movw	r24, r22
    3686:	0e c0       	rjmp	.+28     	; 0x36a4 <send+0x1f0>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3688:	6b ef       	ldi	r22, 0xFB	; 251
    368a:	7f ef       	ldi	r23, 0xFF	; 255
    368c:	8f ef       	ldi	r24, 0xFF	; 255
    368e:	9f ef       	ldi	r25, 0xFF	; 255
    3690:	09 c0       	rjmp	.+18     	; 0x36a4 <send+0x1f0>
   CHECK_SOCKDATA();
    3692:	62 ef       	ldi	r22, 0xF2	; 242
    3694:	7f ef       	ldi	r23, 0xFF	; 255
    3696:	8f ef       	ldi	r24, 0xFF	; 255
    3698:	9f ef       	ldi	r25, 0xFF	; 255
    369a:	04 c0       	rjmp	.+8      	; 0x36a4 <send+0x1f0>
   tmp = getSn_SR(sn);
   if(tmp != SOCK_ESTABLISHED && tmp != SOCK_CLOSE_WAIT) return SOCKERR_SOCKSTATUS;
    369c:	69 ef       	ldi	r22, 0xF9	; 249
    369e:	7f ef       	ldi	r23, 0xFF	; 255
    36a0:	8f ef       	ldi	r24, 0xFF	; 255
    36a2:	9f ef       	ldi	r25, 0xFF	; 255
   while(getSn_CR(sn));
   sock_is_sending |= (1 << sn);
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    36a4:	0f 90       	pop	r0
    36a6:	0f 90       	pop	r0
    36a8:	0f 90       	pop	r0
    36aa:	0f 90       	pop	r0
    36ac:	df 91       	pop	r29
    36ae:	cf 91       	pop	r28
    36b0:	1f 91       	pop	r17
    36b2:	0f 91       	pop	r16
    36b4:	ff 90       	pop	r15
    36b6:	ef 90       	pop	r14
    36b8:	df 90       	pop	r13
    36ba:	cf 90       	pop	r12
    36bc:	bf 90       	pop	r11
    36be:	af 90       	pop	r10
    36c0:	9f 90       	pop	r9
    36c2:	8f 90       	pop	r8
    36c4:	7f 90       	pop	r7
    36c6:	5f 90       	pop	r5
    36c8:	4f 90       	pop	r4
    36ca:	3f 90       	pop	r3
    36cc:	2f 90       	pop	r2
    36ce:	08 95       	ret

000036d0 <recv>:


int32_t recv(uint8_t sn, uint8_t * buf, uint16_t len)
{
    36d0:	2f 92       	push	r2
    36d2:	3f 92       	push	r3
    36d4:	4f 92       	push	r4
    36d6:	5f 92       	push	r5
    36d8:	6f 92       	push	r6
    36da:	7f 92       	push	r7
    36dc:	8f 92       	push	r8
    36de:	9f 92       	push	r9
    36e0:	af 92       	push	r10
    36e2:	bf 92       	push	r11
    36e4:	cf 92       	push	r12
    36e6:	df 92       	push	r13
    36e8:	ef 92       	push	r14
    36ea:	ff 92       	push	r15
    36ec:	0f 93       	push	r16
    36ee:	1f 93       	push	r17
    36f0:	cf 93       	push	r28
    36f2:	df 93       	push	r29
    36f4:	00 d0       	rcall	.+0      	; 0x36f6 <recv+0x26>
    36f6:	00 d0       	rcall	.+0      	; 0x36f8 <recv+0x28>
    36f8:	00 d0       	rcall	.+0      	; 0x36fa <recv+0x2a>
    36fa:	cd b7       	in	r28, 0x3d	; 61
    36fc:	de b7       	in	r29, 0x3e	; 62
#if   _WIZCHIP_ == 5300
   uint8_t head[2];
   uint16_t mr;
#endif
//
   CHECK_SOCKNUM();
    36fe:	89 30       	cpi	r24, 0x09	; 9
    3700:	08 f0       	brcs	.+2      	; 0x3704 <recv+0x34>
    3702:	b5 c0       	rjmp	.+362    	; 0x386e <recv+0x19e>
    3704:	2a 01       	movw	r4, r20
    3706:	7c 83       	std	Y+4, r23	; 0x04
    3708:	6b 83       	std	Y+3, r22	; 0x03
    370a:	38 2e       	mov	r3, r24
   CHECK_SOCKMODE(Sn_MR_TCP);
    370c:	24 e0       	ldi	r18, 0x04	; 4
    370e:	82 9f       	mul	r24, r18
    3710:	80 01       	movw	r16, r0
    3712:	11 24       	eor	r1, r1
    3714:	0f 5f       	subi	r16, 0xFF	; 255
    3716:	1f 4f       	sbci	r17, 0xFF	; 255
    3718:	43 e0       	ldi	r20, 0x03	; 3
    371a:	00 0f       	add	r16, r16
    371c:	11 1f       	adc	r17, r17
    371e:	4a 95       	dec	r20
    3720:	e1 f7       	brne	.-8      	; 0x371a <recv+0x4a>
    3722:	b8 01       	movw	r22, r16
    3724:	01 2e       	mov	r0, r17
    3726:	00 0c       	add	r0, r0
    3728:	88 0b       	sbc	r24, r24
    372a:	99 0b       	sbc	r25, r25
    372c:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3730:	8f 70       	andi	r24, 0x0F	; 15
    3732:	81 30       	cpi	r24, 0x01	; 1
    3734:	09 f0       	breq	.+2      	; 0x3738 <recv+0x68>
    3736:	9f c0       	rjmp	.+318    	; 0x3876 <recv+0x1a6>
   CHECK_SOCKDATA();
    3738:	41 14       	cp	r4, r1
    373a:	51 04       	cpc	r5, r1
    373c:	09 f4       	brne	.+2      	; 0x3740 <recv+0x70>
    373e:	a0 c0       	rjmp	.+320    	; 0x3880 <recv+0x1b0>
   
   recvsize = getSn_RxMAX(sn);
    3740:	b8 01       	movw	r22, r16
    3742:	72 5e       	subi	r23, 0xE2	; 226
    3744:	07 2e       	mov	r0, r23
    3746:	00 0c       	add	r0, r0
    3748:	88 0b       	sbc	r24, r24
    374a:	99 0b       	sbc	r25, r25
    374c:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3750:	28 2e       	mov	r2, r24
            {
               close(sn);
               return SOCKERR_SOCKSTATUS;
            }
         }
         if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
    3752:	81 e0       	ldi	r24, 0x01	; 1
    3754:	90 e0       	ldi	r25, 0x00	; 0
    3756:	9c 01       	movw	r18, r24
    3758:	03 2c       	mov	r0, r3
    375a:	02 c0       	rjmp	.+4      	; 0x3760 <recv+0x90>
    375c:	22 0f       	add	r18, r18
    375e:	33 1f       	adc	r19, r19
    3760:	0a 94       	dec	r0
    3762:	e2 f7       	brpl	.-8      	; 0x375c <recv+0x8c>
    3764:	3a 83       	std	Y+2, r19	; 0x02
    3766:	29 83       	std	Y+1, r18	; 0x01
#endif
//
      while(1)
      {
         recvsize = getSn_RX_RSR(sn);
         tmp = getSn_SR(sn);
    3768:	68 01       	movw	r12, r16
    376a:	3d ef       	ldi	r19, 0xFD	; 253
    376c:	d3 1a       	sub	r13, r19
    376e:	0d 2c       	mov	r0, r13
    3770:	00 0c       	add	r0, r0
    3772:	ee 08       	sbc	r14, r14
    3774:	ff 08       	sbc	r15, r15
         if (tmp != SOCK_ESTABLISHED)
         {
            if(tmp == SOCK_CLOSE_WAIT)
            {
               if(recvsize != 0) break;
               else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
    3776:	48 01       	movw	r8, r16
    3778:	81 ee       	ldi	r24, 0xE1	; 225
    377a:	98 1a       	sub	r9, r24
    377c:	09 2c       	mov	r0, r9
    377e:	00 0c       	add	r0, r0
    3780:	aa 08       	sbc	r10, r10
    3782:	bb 08       	sbc	r11, r11
   {
#endif
//
      while(1)
      {
         recvsize = getSn_RX_RSR(sn);
    3784:	83 2d       	mov	r24, r3
    3786:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <getSn_RX_RSR>
    378a:	9e 83       	std	Y+6, r25	; 0x06
    378c:	8d 83       	std	Y+5, r24	; 0x05
         tmp = getSn_SR(sn);
    378e:	c7 01       	movw	r24, r14
    3790:	b6 01       	movw	r22, r12
    3792:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
         if (tmp != SOCK_ESTABLISHED)
    3796:	87 31       	cpi	r24, 0x17	; 23
    3798:	09 f4       	brne	.+2      	; 0x379c <recv+0xcc>
    379a:	44 c0       	rjmp	.+136    	; 0x3824 <recv+0x154>
         {
            if(tmp == SOCK_CLOSE_WAIT)
    379c:	8c 31       	cpi	r24, 0x1C	; 28
    379e:	d1 f5       	brne	.+116    	; 0x3814 <recv+0x144>
            {
               if(recvsize != 0) break;
    37a0:	2d 81       	ldd	r18, Y+5	; 0x05
    37a2:	3e 81       	ldd	r19, Y+6	; 0x06
    37a4:	23 2b       	or	r18, r19
    37a6:	31 f1       	breq	.+76     	; 0x37f4 <recv+0x124>
//
   CHECK_SOCKNUM();
   CHECK_SOCKMODE(Sn_MR_TCP);
   CHECK_SOCKDATA();
   
   recvsize = getSn_RxMAX(sn);
    37a8:	82 2d       	mov	r24, r2
    37aa:	90 e0       	ldi	r25, 0x00	; 0
    37ac:	98 2f       	mov	r25, r24
    37ae:	88 27       	eor	r24, r24
    37b0:	99 0f       	add	r25, r25
    37b2:	99 0f       	add	r25, r25
    37b4:	84 15       	cp	r24, r4
    37b6:	95 05       	cpc	r25, r5
    37b8:	08 f4       	brcc	.+2      	; 0x37bc <recv+0xec>
    37ba:	2c 01       	movw	r4, r24
    37bc:	8d 81       	ldd	r24, Y+5	; 0x05
    37be:	9e 81       	ldd	r25, Y+6	; 0x06
    37c0:	9a 83       	std	Y+2, r25	; 0x02
    37c2:	89 83       	std	Y+1, r24	; 0x01
    37c4:	48 16       	cp	r4, r24
    37c6:	59 06       	cpc	r5, r25
    37c8:	10 f4       	brcc	.+4      	; 0x37ce <recv+0xfe>
    37ca:	5a 82       	std	Y+2, r5	; 0x02
    37cc:	49 82       	std	Y+1, r4	; 0x01
   else sock_pack_info[sn] = PACK_COMPLETED;
   if(getSn_MR(sn) & Sn_MR_ALIGN) sock_remained_size[sn] = 0;
   //len = recvsize;
#else   
   if(recvsize < len) len = recvsize;   
   wiz_recv_data(sn, buf, len);
    37ce:	49 81       	ldd	r20, Y+1	; 0x01
    37d0:	5a 81       	ldd	r21, Y+2	; 0x02
    37d2:	6b 81       	ldd	r22, Y+3	; 0x03
    37d4:	7c 81       	ldd	r23, Y+4	; 0x04
    37d6:	83 2d       	mov	r24, r3
    37d8:	0e 94 c2 28 	call	0x5184	; 0x5184 <wiz_recv_data>
   setSn_CR(sn,Sn_CR_RECV);
    37dc:	68 01       	movw	r12, r16
    37de:	d3 94       	inc	r13
    37e0:	0d 2c       	mov	r0, r13
    37e2:	00 0c       	add	r0, r0
    37e4:	ee 08       	sbc	r14, r14
    37e6:	ff 08       	sbc	r15, r15
    37e8:	40 e4       	ldi	r20, 0x40	; 64
    37ea:	c7 01       	movw	r24, r14
    37ec:	b6 01       	movw	r22, r12
    37ee:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   while(getSn_CR(sn));
    37f2:	31 c0       	rjmp	.+98     	; 0x3856 <recv+0x186>
         if (tmp != SOCK_ESTABLISHED)
         {
            if(tmp == SOCK_CLOSE_WAIT)
            {
               if(recvsize != 0) break;
               else if(getSn_TX_FSR(sn) == getSn_TxMAX(sn))
    37f4:	83 2d       	mov	r24, r3
    37f6:	0e 94 82 27 	call	0x4f04	; 0x4f04 <getSn_TX_FSR>
    37fa:	3c 01       	movw	r6, r24
    37fc:	c5 01       	movw	r24, r10
    37fe:	b4 01       	movw	r22, r8
    3800:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3804:	90 e0       	ldi	r25, 0x00	; 0
    3806:	98 2f       	mov	r25, r24
    3808:	88 27       	eor	r24, r24
    380a:	99 0f       	add	r25, r25
    380c:	99 0f       	add	r25, r25
    380e:	68 16       	cp	r6, r24
    3810:	79 06       	cpc	r7, r25
    3812:	41 f4       	brne	.+16     	; 0x3824 <recv+0x154>
               {
                  close(sn);
    3814:	83 2d       	mov	r24, r3
    3816:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
                  return SOCKERR_SOCKSTATUS;
    381a:	69 ef       	ldi	r22, 0xF9	; 249
    381c:	7f ef       	ldi	r23, 0xFF	; 255
    381e:	8f ef       	ldi	r24, 0xFF	; 255
    3820:	9f ef       	ldi	r25, 0xFF	; 255
    3822:	32 c0       	rjmp	.+100    	; 0x3888 <recv+0x1b8>
            {
               close(sn);
               return SOCKERR_SOCKSTATUS;
            }
         }
         if((sock_io_mode & (1<<sn)) && (recvsize == 0)) return SOCK_BUSY;
    3824:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <sock_io_mode>
    3828:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <sock_io_mode+0x1>
    382c:	29 81       	ldd	r18, Y+1	; 0x01
    382e:	3a 81       	ldd	r19, Y+2	; 0x02
    3830:	82 23       	and	r24, r18
    3832:	93 23       	and	r25, r19
    3834:	89 2b       	or	r24, r25
    3836:	49 f0       	breq	.+18     	; 0x384a <recv+0x17a>
    3838:	8d 81       	ldd	r24, Y+5	; 0x05
    383a:	9e 81       	ldd	r25, Y+6	; 0x06
    383c:	89 2b       	or	r24, r25
    383e:	09 f0       	breq	.+2      	; 0x3842 <recv+0x172>
    3840:	b3 cf       	rjmp	.-154    	; 0x37a8 <recv+0xd8>
    3842:	60 e0       	ldi	r22, 0x00	; 0
    3844:	70 e0       	ldi	r23, 0x00	; 0
    3846:	cb 01       	movw	r24, r22
    3848:	1f c0       	rjmp	.+62     	; 0x3888 <recv+0x1b8>
         if(recvsize != 0) break;
    384a:	2d 81       	ldd	r18, Y+5	; 0x05
    384c:	3e 81       	ldd	r19, Y+6	; 0x06
    384e:	23 2b       	or	r18, r19
    3850:	09 f4       	brne	.+2      	; 0x3854 <recv+0x184>
    3852:	98 cf       	rjmp	.-208    	; 0x3784 <recv+0xb4>
    3854:	a9 cf       	rjmp	.-174    	; 0x37a8 <recv+0xd8>
   //len = recvsize;
#else   
   if(recvsize < len) len = recvsize;   
   wiz_recv_data(sn, buf, len);
   setSn_CR(sn,Sn_CR_RECV);
   while(getSn_CR(sn));
    3856:	c7 01       	movw	r24, r14
    3858:	b6 01       	movw	r22, r12
    385a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    385e:	81 11       	cpse	r24, r1
    3860:	fa cf       	rjmp	.-12     	; 0x3856 <recv+0x186>
#endif
     
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    3862:	29 81       	ldd	r18, Y+1	; 0x01
    3864:	3a 81       	ldd	r19, Y+2	; 0x02
    3866:	b9 01       	movw	r22, r18
    3868:	80 e0       	ldi	r24, 0x00	; 0
    386a:	90 e0       	ldi	r25, 0x00	; 0
    386c:	0d c0       	rjmp	.+26     	; 0x3888 <recv+0x1b8>
#if   _WIZCHIP_ == 5300
   uint8_t head[2];
   uint16_t mr;
#endif
//
   CHECK_SOCKNUM();
    386e:	6f ef       	ldi	r22, 0xFF	; 255
    3870:	7f ef       	ldi	r23, 0xFF	; 255
    3872:	cb 01       	movw	r24, r22
    3874:	09 c0       	rjmp	.+18     	; 0x3888 <recv+0x1b8>
   CHECK_SOCKMODE(Sn_MR_TCP);
    3876:	6b ef       	ldi	r22, 0xFB	; 251
    3878:	7f ef       	ldi	r23, 0xFF	; 255
    387a:	8f ef       	ldi	r24, 0xFF	; 255
    387c:	9f ef       	ldi	r25, 0xFF	; 255
    387e:	04 c0       	rjmp	.+8      	; 0x3888 <recv+0x1b8>
   CHECK_SOCKDATA();
    3880:	62 ef       	ldi	r22, 0xF2	; 242
    3882:	7f ef       	ldi	r23, 0xFF	; 255
    3884:	8f ef       	ldi	r24, 0xFF	; 255
    3886:	9f ef       	ldi	r25, 0xFF	; 255
#endif
     
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    3888:	26 96       	adiw	r28, 0x06	; 6
    388a:	0f b6       	in	r0, 0x3f	; 63
    388c:	f8 94       	cli
    388e:	de bf       	out	0x3e, r29	; 62
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	cd bf       	out	0x3d, r28	; 61
    3894:	df 91       	pop	r29
    3896:	cf 91       	pop	r28
    3898:	1f 91       	pop	r17
    389a:	0f 91       	pop	r16
    389c:	ff 90       	pop	r15
    389e:	ef 90       	pop	r14
    38a0:	df 90       	pop	r13
    38a2:	cf 90       	pop	r12
    38a4:	bf 90       	pop	r11
    38a6:	af 90       	pop	r10
    38a8:	9f 90       	pop	r9
    38aa:	8f 90       	pop	r8
    38ac:	7f 90       	pop	r7
    38ae:	6f 90       	pop	r6
    38b0:	5f 90       	pop	r5
    38b2:	4f 90       	pop	r4
    38b4:	3f 90       	pop	r3
    38b6:	2f 90       	pop	r2
    38b8:	08 95       	ret

000038ba <sendto>:

int32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port)
{
    38ba:	4f 92       	push	r4
    38bc:	5f 92       	push	r5
    38be:	6f 92       	push	r6
    38c0:	7f 92       	push	r7
    38c2:	8f 92       	push	r8
    38c4:	9f 92       	push	r9
    38c6:	af 92       	push	r10
    38c8:	bf 92       	push	r11
    38ca:	cf 92       	push	r12
    38cc:	df 92       	push	r13
    38ce:	ff 92       	push	r15
    38d0:	0f 93       	push	r16
    38d2:	1f 93       	push	r17
    38d4:	cf 93       	push	r28
    38d6:	df 93       	push	r29
   uint8_t tmp = 0;
   uint16_t freesize = 0;
   uint32_t taddr;

   CHECK_SOCKNUM();
    38d8:	89 30       	cpi	r24, 0x09	; 9
    38da:	08 f0       	brcs	.+2      	; 0x38de <sendto+0x24>
    38dc:	f8 c0       	rjmp	.+496    	; 0x3ace <sendto+0x214>
    38de:	58 01       	movw	r10, r16
    38e0:	69 01       	movw	r12, r18
    38e2:	8a 01       	movw	r16, r20
    38e4:	4b 01       	movw	r8, r22
    38e6:	f8 2e       	mov	r15, r24
   switch(getSn_MR(sn) & 0x0F)
    38e8:	84 e0       	ldi	r24, 0x04	; 4
    38ea:	f8 9e       	mul	r15, r24
    38ec:	e0 01       	movw	r28, r0
    38ee:	11 24       	eor	r1, r1
    38f0:	21 96       	adiw	r28, 0x01	; 1
    38f2:	63 e0       	ldi	r22, 0x03	; 3
    38f4:	cc 0f       	add	r28, r28
    38f6:	dd 1f       	adc	r29, r29
    38f8:	6a 95       	dec	r22
    38fa:	e1 f7       	brne	.-8      	; 0x38f4 <sendto+0x3a>
    38fc:	2e 01       	movw	r4, r28
    38fe:	0d 2e       	mov	r0, r29
    3900:	00 0c       	add	r0, r0
    3902:	66 08       	sbc	r6, r6
    3904:	77 08       	sbc	r7, r7
    3906:	c3 01       	movw	r24, r6
    3908:	b2 01       	movw	r22, r4
    390a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    390e:	8f 70       	andi	r24, 0x0F	; 15
    3910:	82 50       	subi	r24, 0x02	; 2
    3912:	83 30       	cpi	r24, 0x03	; 3
    3914:	08 f0       	brcs	.+2      	; 0x3918 <sendto+0x5e>
    3916:	df c0       	rjmp	.+446    	; 0x3ad6 <sendto+0x21c>
         break;
//   #endif
      default:
         return SOCKERR_SOCKMODE;
   }
   CHECK_SOCKDATA();
    3918:	01 15       	cp	r16, r1
    391a:	11 05       	cpc	r17, r1
    391c:	09 f4       	brne	.+2      	; 0x3920 <sendto+0x66>
    391e:	e0 c0       	rjmp	.+448    	; 0x3ae0 <sendto+0x226>
   //M20140501 : For avoiding fatal error on memory align mismatched
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   //{
      //uint32_t taddr;
      taddr = ((uint32_t)addr[0]) & 0x000000FF;
      taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
    3920:	f6 01       	movw	r30, r12
    3922:	80 81       	ld	r24, Z
    3924:	90 e0       	ldi	r25, 0x00	; 0
    3926:	a0 e0       	ldi	r26, 0x00	; 0
    3928:	b0 e0       	ldi	r27, 0x00	; 0
    392a:	ba 2f       	mov	r27, r26
    392c:	a9 2f       	mov	r26, r25
    392e:	98 2f       	mov	r25, r24
    3930:	88 27       	eor	r24, r24
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
    3932:	21 81       	ldd	r18, Z+1	; 0x01
    3934:	82 0f       	add	r24, r18
    3936:	91 1d       	adc	r25, r1
    3938:	a1 1d       	adc	r26, r1
    393a:	b1 1d       	adc	r27, r1
    393c:	ba 2f       	mov	r27, r26
    393e:	a9 2f       	mov	r26, r25
    3940:	98 2f       	mov	r25, r24
    3942:	88 27       	eor	r24, r24
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
    3944:	22 81       	ldd	r18, Z+2	; 0x02
    3946:	82 0f       	add	r24, r18
    3948:	91 1d       	adc	r25, r1
    394a:	a1 1d       	adc	r26, r1
    394c:	b1 1d       	adc	r27, r1
    394e:	ba 2f       	mov	r27, r26
    3950:	a9 2f       	mov	r26, r25
    3952:	98 2f       	mov	r25, r24
    3954:	88 27       	eor	r24, r24
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
    3956:	23 81       	ldd	r18, Z+3	; 0x03
    3958:	82 0f       	add	r24, r18
    395a:	91 1d       	adc	r25, r1
    395c:	a1 1d       	adc	r26, r1
    395e:	b1 1d       	adc	r27, r1
    3960:	89 2b       	or	r24, r25
    3962:	8a 2b       	or	r24, r26
    3964:	8b 2b       	or	r24, r27
    3966:	21 f0       	breq	.+8      	; 0x3970 <sendto+0xb6>
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    3968:	a1 14       	cp	r10, r1
    396a:	b1 04       	cpc	r11, r1
    396c:	d1 f0       	breq	.+52     	; 0x39a2 <sendto+0xe8>
    396e:	0b c0       	rjmp	.+22     	; 0x3986 <sendto+0xcc>
      taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
    3970:	c3 01       	movw	r24, r6
    3972:	b2 01       	movw	r22, r4
    3974:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3978:	82 fd       	sbrc	r24, 2
    397a:	f6 cf       	rjmp	.-20     	; 0x3968 <sendto+0xae>
    397c:	64 ef       	ldi	r22, 0xF4	; 244
    397e:	7f ef       	ldi	r23, 0xFF	; 255
    3980:	8f ef       	ldi	r24, 0xFF	; 255
    3982:	9f ef       	ldi	r25, 0xFF	; 255
    3984:	bf c0       	rjmp	.+382    	; 0x3b04 <sendto+0x24a>
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
   tmp = getSn_SR(sn);
    3986:	2e 01       	movw	r4, r28
    3988:	fd ef       	ldi	r31, 0xFD	; 253
    398a:	5f 1a       	sub	r5, r31
    398c:	05 2c       	mov	r0, r5
    398e:	00 0c       	add	r0, r0
    3990:	66 08       	sbc	r6, r6
    3992:	77 08       	sbc	r7, r7
    3994:	c3 01       	movw	r24, r6
    3996:	b2 01       	movw	r22, r4
    3998:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    399c:	82 34       	cpi	r24, 0x42	; 66
    399e:	61 f4       	brne	.+24     	; 0x39b8 <sendto+0xfe>
    39a0:	0f c0       	rjmp	.+30     	; 0x39c0 <sendto+0x106>
      taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
   //}
   //
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    39a2:	c3 01       	movw	r24, r6
    39a4:	b2 01       	movw	r22, r4
    39a6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    39aa:	82 fd       	sbrc	r24, 2
    39ac:	ec cf       	rjmp	.-40     	; 0x3986 <sendto+0xcc>
    39ae:	65 ef       	ldi	r22, 0xF5	; 245
    39b0:	7f ef       	ldi	r23, 0xFF	; 255
    39b2:	8f ef       	ldi	r24, 0xFF	; 255
    39b4:	9f ef       	ldi	r25, 0xFF	; 255
    39b6:	a6 c0       	rjmp	.+332    	; 0x3b04 <sendto+0x24a>
   tmp = getSn_SR(sn);
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    39b8:	8f 7e       	andi	r24, 0xEF	; 239
    39ba:	82 32       	cpi	r24, 0x22	; 34
    39bc:	09 f0       	breq	.+2      	; 0x39c0 <sendto+0x106>
    39be:	95 c0       	rjmp	.+298    	; 0x3aea <sendto+0x230>
//#else
//   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
//#endif
      
   setSn_DIPR(sn,addr);
    39c0:	be 01       	movw	r22, r28
    39c2:	74 5f       	subi	r23, 0xF4	; 244
    39c4:	07 2e       	mov	r0, r23
    39c6:	00 0c       	add	r0, r0
    39c8:	88 0b       	sbc	r24, r24
    39ca:	99 0b       	sbc	r25, r25
    39cc:	24 e0       	ldi	r18, 0x04	; 4
    39ce:	30 e0       	ldi	r19, 0x00	; 0
    39d0:	a6 01       	movw	r20, r12
    39d2:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setSn_DPORT(sn,port);      
    39d6:	be 01       	movw	r22, r28
    39d8:	70 5f       	subi	r23, 0xF0	; 240
    39da:	07 2e       	mov	r0, r23
    39dc:	00 0c       	add	r0, r0
    39de:	88 0b       	sbc	r24, r24
    39e0:	99 0b       	sbc	r25, r25
    39e2:	4b 2d       	mov	r20, r11
    39e4:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    39e8:	be 01       	movw	r22, r28
    39ea:	7f 5e       	subi	r23, 0xEF	; 239
    39ec:	07 2e       	mov	r0, r23
    39ee:	00 0c       	add	r0, r0
    39f0:	88 0b       	sbc	r24, r24
    39f2:	99 0b       	sbc	r25, r25
    39f4:	4a 2d       	mov	r20, r10
    39f6:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   freesize = getSn_TxMAX(sn);
    39fa:	be 01       	movw	r22, r28
    39fc:	71 5e       	subi	r23, 0xE1	; 225
    39fe:	07 2e       	mov	r0, r23
    3a00:	00 0c       	add	r0, r0
    3a02:	88 0b       	sbc	r24, r24
    3a04:	99 0b       	sbc	r25, r25
    3a06:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3a0a:	90 e0       	ldi	r25, 0x00	; 0
    3a0c:	98 2f       	mov	r25, r24
    3a0e:	88 27       	eor	r24, r24
    3a10:	99 0f       	add	r25, r25
    3a12:	99 0f       	add	r25, r25
    3a14:	80 17       	cp	r24, r16
    3a16:	91 07       	cpc	r25, r17
    3a18:	08 f4       	brcc	.+2      	; 0x3a1c <sendto+0x162>
    3a1a:	8c 01       	movw	r16, r24
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	90 e0       	ldi	r25, 0x00	; 0
    3a20:	5c 01       	movw	r10, r24
    3a22:	0f 2c       	mov	r0, r15
    3a24:	02 c0       	rjmp	.+4      	; 0x3a2a <sendto+0x170>
    3a26:	aa 0c       	add	r10, r10
    3a28:	bb 1c       	adc	r11, r11
    3a2a:	0a 94       	dec	r0
    3a2c:	e2 f7       	brpl	.-8      	; 0x3a26 <sendto+0x16c>
   setSn_DPORT(sn,port);      
   freesize = getSn_TxMAX(sn);
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
    3a2e:	8f 2d       	mov	r24, r15
    3a30:	0e 94 82 27 	call	0x4f04	; 0x4f04 <getSn_TX_FSR>
    3a34:	6c 01       	movw	r12, r24
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    3a36:	c3 01       	movw	r24, r6
    3a38:	b2 01       	movw	r22, r4
    3a3a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3a3e:	88 23       	and	r24, r24
    3a40:	09 f4       	brne	.+2      	; 0x3a44 <sendto+0x18a>
    3a42:	58 c0       	rjmp	.+176    	; 0x3af4 <sendto+0x23a>
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    3a44:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <sock_io_mode>
    3a48:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3a4c:	8a 21       	and	r24, r10
    3a4e:	9b 21       	and	r25, r11
    3a50:	89 2b       	or	r24, r25
    3a52:	21 f0       	breq	.+8      	; 0x3a5c <sendto+0x1a2>
    3a54:	c0 16       	cp	r12, r16
    3a56:	d1 06       	cpc	r13, r17
    3a58:	20 f4       	brcc	.+8      	; 0x3a62 <sendto+0x1a8>
    3a5a:	51 c0       	rjmp	.+162    	; 0x3afe <sendto+0x244>
      if(len <= freesize) break;
    3a5c:	c0 16       	cp	r12, r16
    3a5e:	d1 06       	cpc	r13, r17
    3a60:	30 f3       	brcs	.-52     	; 0x3a2e <sendto+0x174>
   };
	wiz_send_data(sn, buf, len);
    3a62:	a8 01       	movw	r20, r16
    3a64:	b4 01       	movw	r22, r8
    3a66:	8f 2d       	mov	r24, r15
    3a68:	0e 94 32 28 	call	0x5064	; 0x5064 <wiz_send_data>
//A20150601 : For W5300
#if _WIZCHIP_ == 5300
   setSn_TX_WRSR(sn, len);
#endif
//   
	setSn_CR(sn,Sn_CR_SEND);
    3a6c:	4e 01       	movw	r8, r28
    3a6e:	93 94       	inc	r9
    3a70:	09 2c       	mov	r0, r9
    3a72:	00 0c       	add	r0, r0
    3a74:	aa 08       	sbc	r10, r10
    3a76:	bb 08       	sbc	r11, r11
    3a78:	40 e2       	ldi	r20, 0x20	; 32
    3a7a:	c5 01       	movw	r24, r10
    3a7c:	b4 01       	movw	r22, r8
    3a7e:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
	/* wait to process the command... */
	while(getSn_CR(sn));
    3a82:	c5 01       	movw	r24, r10
    3a84:	b4 01       	movw	r22, r8
    3a86:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3a8a:	81 11       	cpse	r24, r1
    3a8c:	fa cf       	rjmp	.-12     	; 0x3a82 <sendto+0x1c8>
   while(1)
   {
      tmp = getSn_IR(sn);
    3a8e:	de 5f       	subi	r29, 0xFE	; 254
    3a90:	4e 01       	movw	r8, r28
    3a92:	dd 0f       	add	r29, r29
    3a94:	aa 08       	sbc	r10, r10
    3a96:	bb 08       	sbc	r11, r11
    3a98:	c5 01       	movw	r24, r10
    3a9a:	b4 01       	movw	r22, r8
    3a9c:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
      if(tmp & Sn_IR_SENDOK)
    3aa0:	84 ff       	sbrs	r24, 4
    3aa2:	09 c0       	rjmp	.+18     	; 0x3ab6 <sendto+0x1fc>
      {
         setSn_IR(sn, Sn_IR_SENDOK);
    3aa4:	40 e1       	ldi	r20, 0x10	; 16
    3aa6:	c5 01       	movw	r24, r10
    3aa8:	b4 01       	movw	r22, r8
    3aaa:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
      if(taddr) setSUBR((uint8_t*)&taddr);
   #endif
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
    3aae:	b8 01       	movw	r22, r16
    3ab0:	80 e0       	ldi	r24, 0x00	; 0
    3ab2:	90 e0       	ldi	r25, 0x00	; 0
    3ab4:	27 c0       	rjmp	.+78     	; 0x3b04 <sendto+0x24a>
         setSn_IR(sn, Sn_IR_SENDOK);
         break;
      }
      //M:20131104
      //else if(tmp & Sn_IR_TIMEOUT) return SOCKERR_TIMEOUT;
      else if(tmp & Sn_IR_TIMEOUT)
    3ab6:	83 ff       	sbrs	r24, 3
    3ab8:	ef cf       	rjmp	.-34     	; 0x3a98 <sendto+0x1de>
      {
         setSn_IR(sn, Sn_IR_TIMEOUT);
    3aba:	48 e0       	ldi	r20, 0x08	; 8
    3abc:	c5 01       	movw	r24, r10
    3abe:	b4 01       	movw	r22, r8
    3ac0:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
         //len = (uint16_t)SOCKERR_TIMEOUT;
         //break;
         #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
            if(taddr) setSUBR((uint8_t*)&taddr);
         #endif
         return SOCKERR_TIMEOUT;
    3ac4:	63 ef       	ldi	r22, 0xF3	; 243
    3ac6:	7f ef       	ldi	r23, 0xFF	; 255
    3ac8:	8f ef       	ldi	r24, 0xFF	; 255
    3aca:	9f ef       	ldi	r25, 0xFF	; 255
    3acc:	1b c0       	rjmp	.+54     	; 0x3b04 <sendto+0x24a>
{
   uint8_t tmp = 0;
   uint16_t freesize = 0;
   uint32_t taddr;

   CHECK_SOCKNUM();
    3ace:	6f ef       	ldi	r22, 0xFF	; 255
    3ad0:	7f ef       	ldi	r23, 0xFF	; 255
    3ad2:	cb 01       	movw	r24, r22
    3ad4:	17 c0       	rjmp	.+46     	; 0x3b04 <sendto+0x24a>
//   #if ( _WIZCHIP_ < 5200 )
      case Sn_MR_IPRAW:
         break;
//   #endif
      default:
         return SOCKERR_SOCKMODE;
    3ad6:	6b ef       	ldi	r22, 0xFB	; 251
    3ad8:	7f ef       	ldi	r23, 0xFF	; 255
    3ada:	8f ef       	ldi	r24, 0xFF	; 255
    3adc:	9f ef       	ldi	r25, 0xFF	; 255
    3ade:	12 c0       	rjmp	.+36     	; 0x3b04 <sendto+0x24a>
   }
   CHECK_SOCKDATA();
    3ae0:	62 ef       	ldi	r22, 0xF2	; 242
    3ae2:	7f ef       	ldi	r23, 0xFF	; 255
    3ae4:	8f ef       	ldi	r24, 0xFF	; 255
    3ae6:	9f ef       	ldi	r25, 0xFF	; 255
    3ae8:	0d c0       	rjmp	.+26     	; 0x3b04 <sendto+0x24a>
   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
   tmp = getSn_SR(sn);
//#if ( _WIZCHIP_ < 5200 )
   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
    3aea:	69 ef       	ldi	r22, 0xF9	; 249
    3aec:	7f ef       	ldi	r23, 0xFF	; 255
    3aee:	8f ef       	ldi	r24, 0xFF	; 255
    3af0:	9f ef       	ldi	r25, 0xFF	; 255
    3af2:	08 c0       	rjmp	.+16     	; 0x3b04 <sendto+0x24a>
   freesize = getSn_TxMAX(sn);
   if (len > freesize) len = freesize; // check size not to exceed MAX size.
   while(1)
   {
      freesize = getSn_TX_FSR(sn);
      if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    3af4:	6c ef       	ldi	r22, 0xFC	; 252
    3af6:	7f ef       	ldi	r23, 0xFF	; 255
    3af8:	8f ef       	ldi	r24, 0xFF	; 255
    3afa:	9f ef       	ldi	r25, 0xFF	; 255
    3afc:	03 c0       	rjmp	.+6      	; 0x3b04 <sendto+0x24a>
      if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
    3afe:	60 e0       	ldi	r22, 0x00	; 0
    3b00:	70 e0       	ldi	r23, 0x00	; 0
    3b02:	cb 01       	movw	r24, r22
      if(taddr) setSUBR((uint8_t*)&taddr);
   #endif
   //M20150409 : Explicit Type Casting
   //return len;
   return (int32_t)len;
}
    3b04:	df 91       	pop	r29
    3b06:	cf 91       	pop	r28
    3b08:	1f 91       	pop	r17
    3b0a:	0f 91       	pop	r16
    3b0c:	ff 90       	pop	r15
    3b0e:	df 90       	pop	r13
    3b10:	cf 90       	pop	r12
    3b12:	bf 90       	pop	r11
    3b14:	af 90       	pop	r10
    3b16:	9f 90       	pop	r9
    3b18:	8f 90       	pop	r8
    3b1a:	7f 90       	pop	r7
    3b1c:	6f 90       	pop	r6
    3b1e:	5f 90       	pop	r5
    3b20:	4f 90       	pop	r4
    3b22:	08 95       	ret

00003b24 <recvfrom>:



int32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port)
{
    3b24:	2f 92       	push	r2
    3b26:	3f 92       	push	r3
    3b28:	4f 92       	push	r4
    3b2a:	5f 92       	push	r5
    3b2c:	6f 92       	push	r6
    3b2e:	7f 92       	push	r7
    3b30:	8f 92       	push	r8
    3b32:	9f 92       	push	r9
    3b34:	af 92       	push	r10
    3b36:	bf 92       	push	r11
    3b38:	cf 92       	push	r12
    3b3a:	df 92       	push	r13
    3b3c:	ef 92       	push	r14
    3b3e:	ff 92       	push	r15
    3b40:	0f 93       	push	r16
    3b42:	1f 93       	push	r17
    3b44:	cf 93       	push	r28
    3b46:	df 93       	push	r29
    3b48:	cd b7       	in	r28, 0x3d	; 61
    3b4a:	de b7       	in	r29, 0x3e	; 62
    3b4c:	60 97       	sbiw	r28, 0x10	; 16
    3b4e:	0f b6       	in	r0, 0x3f	; 63
    3b50:	f8 94       	cli
    3b52:	de bf       	out	0x3e, r29	; 62
    3b54:	0f be       	out	0x3f, r0	; 63
    3b56:	cd bf       	out	0x3d, r28	; 61
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;

   CHECK_SOCKNUM();
    3b58:	89 30       	cpi	r24, 0x09	; 9
    3b5a:	08 f0       	brcs	.+2      	; 0x3b5e <recvfrom+0x3a>
    3b5c:	65 c1       	rjmp	.+714    	; 0x3e28 <recvfrom+0x304>
    3b5e:	18 8b       	std	Y+16, r17	; 0x10
    3b60:	0f 87       	std	Y+15, r16	; 0x0f
    3b62:	59 01       	movw	r10, r18
    3b64:	4a 01       	movw	r8, r20
    3b66:	7e 87       	std	Y+14, r23	; 0x0e
    3b68:	6d 87       	std	Y+13, r22	; 0x0d
    3b6a:	78 2e       	mov	r7, r24
//A20150601
#if _WIZCHIP_ == 5300
   mr1 = getMR();
#endif   

   switch((mr=getSn_MR(sn)) & 0x0F)
    3b6c:	c8 2e       	mov	r12, r24
    3b6e:	d1 2c       	mov	r13, r1
    3b70:	c6 01       	movw	r24, r12
    3b72:	75 e0       	ldi	r23, 0x05	; 5
    3b74:	88 0f       	add	r24, r24
    3b76:	99 1f       	adc	r25, r25
    3b78:	7a 95       	dec	r23
    3b7a:	e1 f7       	brne	.-8      	; 0x3b74 <recvfrom+0x50>
    3b7c:	9c 01       	movw	r18, r24
    3b7e:	28 5f       	subi	r18, 0xF8	; 248
    3b80:	3f 4f       	sbci	r19, 0xFF	; 255
    3b82:	3a 87       	std	Y+10, r19	; 0x0a
    3b84:	29 87       	std	Y+9, r18	; 0x09
    3b86:	b9 01       	movw	r22, r18
    3b88:	33 0f       	add	r19, r19
    3b8a:	88 0b       	sbc	r24, r24
    3b8c:	99 0b       	sbc	r25, r25
    3b8e:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3b92:	68 2e       	mov	r6, r24
    3b94:	8f 70       	andi	r24, 0x0F	; 15
    3b96:	82 50       	subi	r24, 0x02	; 2
    3b98:	83 30       	cpi	r24, 0x03	; 3
    3b9a:	08 f0       	brcs	.+2      	; 0x3b9e <recvfrom+0x7a>
    3b9c:	49 c1       	rjmp	.+658    	; 0x3e30 <recvfrom+0x30c>
         break;
   #endif
      default:
         return SOCKERR_SOCKMODE;
   }
   CHECK_SOCKDATA();
    3b9e:	81 14       	cp	r8, r1
    3ba0:	91 04       	cpc	r9, r1
    3ba2:	09 f4       	brne	.+2      	; 0x3ba6 <recvfrom+0x82>
    3ba4:	4a c1       	rjmp	.+660    	; 0x3e3a <recvfrom+0x316>
   if(sock_remained_size[sn] == 0)
    3ba6:	76 01       	movw	r14, r12
    3ba8:	ee 0c       	add	r14, r14
    3baa:	ff 1c       	adc	r15, r15
    3bac:	f7 01       	movw	r30, r14
    3bae:	eb 5e       	subi	r30, 0xEB	; 235
    3bb0:	f7 4f       	sbci	r31, 0xF7	; 247
    3bb2:	80 81       	ld	r24, Z
    3bb4:	91 81       	ldd	r25, Z+1	; 0x01
    3bb6:	89 2b       	or	r24, r25
    3bb8:	81 f5       	brne	.+96     	; 0x3c1a <recvfrom+0xf6>
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    3bba:	81 e0       	ldi	r24, 0x01	; 1
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	07 2c       	mov	r0, r7
    3bc2:	02 c0       	rjmp	.+4      	; 0x3bc8 <recvfrom+0xa4>
    3bc4:	ee 0f       	add	r30, r30
    3bc6:	ff 1f       	adc	r31, r31
    3bc8:	0a 94       	dec	r0
    3bca:	e2 f7       	brpl	.-8      	; 0x3bc4 <recvfrom+0xa0>
    3bcc:	fc 87       	std	Y+12, r31	; 0x0c
    3bce:	eb 87       	std	Y+11, r30	; 0x0b
   if(sock_remained_size[sn] == 0)
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    3bd0:	29 84       	ldd	r2, Y+9	; 0x09
    3bd2:	3a 84       	ldd	r3, Y+10	; 0x0a
    3bd4:	fd ef       	ldi	r31, 0xFD	; 253
    3bd6:	3f 1a       	sub	r3, r31
    3bd8:	03 2c       	mov	r0, r3
    3bda:	00 0c       	add	r0, r0
    3bdc:	44 08       	sbc	r4, r4
    3bde:	55 08       	sbc	r5, r5
   CHECK_SOCKDATA();
   if(sock_remained_size[sn] == 0)
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
    3be0:	87 2d       	mov	r24, r7
    3be2:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <getSn_RX_RSR>
    3be6:	8c 01       	movw	r16, r24
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    3be8:	c2 01       	movw	r24, r4
    3bea:	b1 01       	movw	r22, r2
    3bec:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3bf0:	88 23       	and	r24, r24
    3bf2:	09 f4       	brne	.+2      	; 0x3bf6 <recvfrom+0xd2>
    3bf4:	27 c1       	rjmp	.+590    	; 0x3e44 <recvfrom+0x320>
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    3bf6:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <sock_io_mode>
    3bfa:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3bfe:	2b 85       	ldd	r18, Y+11	; 0x0b
    3c00:	3c 85       	ldd	r19, Y+12	; 0x0c
    3c02:	82 23       	and	r24, r18
    3c04:	93 23       	and	r25, r19
    3c06:	89 2b       	or	r24, r25
    3c08:	21 f0       	breq	.+8      	; 0x3c12 <recvfrom+0xee>
    3c0a:	01 15       	cp	r16, r1
    3c0c:	11 05       	cpc	r17, r1
    3c0e:	39 f4       	brne	.+14     	; 0x3c1e <recvfrom+0xfa>
    3c10:	1e c1       	rjmp	.+572    	; 0x3e4e <recvfrom+0x32a>
         if(pack_len != 0) break;
    3c12:	01 15       	cp	r16, r1
    3c14:	11 05       	cpc	r17, r1
    3c16:	21 f3       	breq	.-56     	; 0x3be0 <recvfrom+0xbc>
    3c18:	02 c0       	rjmp	.+4      	; 0x3c1e <recvfrom+0xfa>
#else   
   uint8_t  mr;
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;
    3c1a:	00 e0       	ldi	r16, 0x00	; 0
    3c1c:	10 e0       	ldi	r17, 0x00	; 0
         if(pack_len != 0) break;
      };
   }
//D20150601 : Move it to bottom
// sock_pack_info[sn] = PACK_COMPLETED;
	switch (mr & 0x07)
    3c1e:	86 2d       	mov	r24, r6
    3c20:	87 70       	andi	r24, 0x07	; 7
    3c22:	e9 85       	ldd	r30, Y+9	; 0x09
    3c24:	fa 85       	ldd	r31, Y+10	; 0x0a
    3c26:	f3 95       	inc	r31
    3c28:	fa 87       	std	Y+10, r31	; 0x0a
    3c2a:	e9 87       	std	Y+9, r30	; 0x09
    3c2c:	83 30       	cpi	r24, 0x03	; 3
    3c2e:	09 f4       	brne	.+2      	; 0x3c32 <recvfrom+0x10e>
    3c30:	7f c0       	rjmp	.+254    	; 0x3d30 <recvfrom+0x20c>
    3c32:	84 30       	cpi	r24, 0x04	; 4
    3c34:	09 f4       	brne	.+2      	; 0x3c38 <recvfrom+0x114>
    3c36:	41 c0       	rjmp	.+130    	; 0x3cba <recvfrom+0x196>
    3c38:	82 30       	cpi	r24, 0x02	; 2
    3c3a:	09 f0       	breq	.+2      	; 0x3c3e <recvfrom+0x11a>
    3c3c:	c4 c0       	rjmp	.+392    	; 0x3dc6 <recvfrom+0x2a2>
	{
	   case Sn_MR_UDP :
	      if(sock_remained_size[sn] == 0)
    3c3e:	f7 01       	movw	r30, r14
    3c40:	eb 5e       	subi	r30, 0xEB	; 235
    3c42:	f7 4f       	sbci	r31, 0xF7	; 247
    3c44:	80 81       	ld	r24, Z
    3c46:	91 81       	ldd	r25, Z+1	; 0x01
    3c48:	89 2b       	or	r24, r25
    3c4a:	09 f0       	breq	.+2      	; 0x3c4e <recvfrom+0x12a>
    3c4c:	ab c0       	rjmp	.+342    	; 0x3da4 <recvfrom+0x280>
	      {
   			wiz_recv_data(sn, head, 8);
    3c4e:	48 e0       	ldi	r20, 0x08	; 8
    3c50:	50 e0       	ldi	r21, 0x00	; 0
    3c52:	be 01       	movw	r22, r28
    3c54:	6f 5f       	subi	r22, 0xFF	; 255
    3c56:	7f 4f       	sbci	r23, 0xFF	; 255
    3c58:	87 2d       	mov	r24, r7
    3c5a:	0e 94 c2 28 	call	0x5184	; 0x5184 <wiz_recv_data>
   			setSn_CR(sn,Sn_CR_RECV);
    3c5e:	29 85       	ldd	r18, Y+9	; 0x09
    3c60:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c62:	19 01       	movw	r2, r18
    3c64:	33 0f       	add	r19, r19
    3c66:	44 08       	sbc	r4, r4
    3c68:	55 08       	sbc	r5, r5
    3c6a:	40 e4       	ldi	r20, 0x40	; 64
    3c6c:	c2 01       	movw	r24, r4
    3c6e:	b1 01       	movw	r22, r2
    3c70:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   			while(getSn_CR(sn));
    3c74:	c2 01       	movw	r24, r4
    3c76:	b1 01       	movw	r22, r2
    3c78:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3c7c:	81 11       	cpse	r24, r1
    3c7e:	fa cf       	rjmp	.-12     	; 0x3c74 <recvfrom+0x150>
      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[6];
   		   }
            else
            {
         #endif
               addr[0] = head[0];
    3c80:	89 81       	ldd	r24, Y+1	; 0x01
    3c82:	f5 01       	movw	r30, r10
    3c84:	80 83       	st	Z, r24
      			addr[1] = head[1];
    3c86:	8a 81       	ldd	r24, Y+2	; 0x02
    3c88:	81 83       	std	Z+1, r24	; 0x01
      			addr[2] = head[2];
    3c8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c8c:	82 83       	std	Z+2, r24	; 0x02
      			addr[3] = head[3];
    3c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    3c90:	83 83       	std	Z+3, r24	; 0x03
      			*port = head[4];
      			*port = (*port << 8) + head[5];
    3c92:	8d 81       	ldd	r24, Y+5	; 0x05
    3c94:	90 e0       	ldi	r25, 0x00	; 0
    3c96:	98 2f       	mov	r25, r24
    3c98:	88 27       	eor	r24, r24
    3c9a:	2e 81       	ldd	r18, Y+6	; 0x06
    3c9c:	82 0f       	add	r24, r18
    3c9e:	91 1d       	adc	r25, r1
    3ca0:	ef 85       	ldd	r30, Y+15	; 0x0f
    3ca2:	f8 89       	ldd	r31, Y+16	; 0x10
    3ca4:	91 83       	std	Z+1, r25	; 0x01
    3ca6:	80 83       	st	Z, r24
      			sock_remained_size[sn] = head[6];
      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[7];
    3ca8:	f7 01       	movw	r30, r14
    3caa:	eb 5e       	subi	r30, 0xEB	; 235
    3cac:	f7 4f       	sbci	r31, 0xF7	; 247
    3cae:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb0:	90 e0       	ldi	r25, 0x00	; 0
    3cb2:	98 2f       	mov	r25, r24
    3cb4:	88 27       	eor	r24, r24
    3cb6:	28 85       	ldd	r18, Y+8	; 0x08
    3cb8:	6c c0       	rjmp	.+216    	; 0x3d92 <recvfrom+0x26e>
			// Need to packet length check (default 1472)
			//
   		wiz_recv_data(sn, buf, pack_len); // data copy.
			break;
	   case Sn_MR_MACRAW :
	      if(sock_remained_size[sn] == 0)
    3cba:	f7 01       	movw	r30, r14
    3cbc:	eb 5e       	subi	r30, 0xEB	; 235
    3cbe:	f7 4f       	sbci	r31, 0xF7	; 247
    3cc0:	80 81       	ld	r24, Z
    3cc2:	91 81       	ldd	r25, Z+1	; 0x01
    3cc4:	89 2b       	or	r24, r25
    3cc6:	09 f0       	breq	.+2      	; 0x3cca <recvfrom+0x1a6>
    3cc8:	6d c0       	rjmp	.+218    	; 0x3da4 <recvfrom+0x280>
	      {
   			wiz_recv_data(sn, head, 2);
    3cca:	42 e0       	ldi	r20, 0x02	; 2
    3ccc:	50 e0       	ldi	r21, 0x00	; 0
    3cce:	be 01       	movw	r22, r28
    3cd0:	6f 5f       	subi	r22, 0xFF	; 255
    3cd2:	7f 4f       	sbci	r23, 0xFF	; 255
    3cd4:	87 2d       	mov	r24, r7
    3cd6:	0e 94 c2 28 	call	0x5184	; 0x5184 <wiz_recv_data>
   			setSn_CR(sn,Sn_CR_RECV);
    3cda:	29 85       	ldd	r18, Y+9	; 0x09
    3cdc:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cde:	19 01       	movw	r2, r18
    3ce0:	33 0f       	add	r19, r19
    3ce2:	44 08       	sbc	r4, r4
    3ce4:	55 08       	sbc	r5, r5
    3ce6:	40 e4       	ldi	r20, 0x40	; 64
    3ce8:	c2 01       	movw	r24, r4
    3cea:	b1 01       	movw	r22, r2
    3cec:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   			while(getSn_CR(sn));
    3cf0:	c2 01       	movw	r24, r4
    3cf2:	b1 01       	movw	r22, r2
    3cf4:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3cf8:	81 11       	cpse	r24, r1
    3cfa:	fa cf       	rjmp	.-12     	; 0x3cf0 <recvfrom+0x1cc>
   			// read peer's IP address, port number & packet length
    			sock_remained_size[sn] = head[0];
   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1] -2;
    3cfc:	89 81       	ldd	r24, Y+1	; 0x01
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	38 2f       	mov	r19, r24
    3d02:	22 27       	eor	r18, r18
    3d04:	9a 81       	ldd	r25, Y+2	; 0x02
    3d06:	89 2f       	mov	r24, r25
    3d08:	90 e0       	ldi	r25, 0x00	; 0
    3d0a:	02 97       	sbiw	r24, 0x02	; 2
    3d0c:	82 0f       	add	r24, r18
    3d0e:	93 1f       	adc	r25, r19
    3d10:	f7 01       	movw	r30, r14
    3d12:	eb 5e       	subi	r30, 0xEB	; 235
    3d14:	f7 4f       	sbci	r31, 0xF7	; 247
    3d16:	91 83       	std	Z+1, r25	; 0x01
    3d18:	80 83       	st	Z, r24
   			if(sock_remained_size[sn] & 0x01)
   				sock_remained_size[sn] = sock_remained_size[sn] + 1 - 4;
   			else
   				sock_remained_size[sn] -= 4;
			#endif
   			if(sock_remained_size[sn] > 1514) 
    3d1a:	8b 3e       	cpi	r24, 0xEB	; 235
    3d1c:	95 40       	sbci	r25, 0x05	; 5
    3d1e:	e8 f1       	brcs	.+122    	; 0x3d9a <recvfrom+0x276>
   			{
   			   close(sn);
    3d20:	87 2d       	mov	r24, r7
    3d22:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <close>
   			   return SOCKFATAL_PACKLEN;
    3d26:	67 e1       	ldi	r22, 0x17	; 23
    3d28:	7c ef       	ldi	r23, 0xFC	; 252
    3d2a:	8f ef       	ldi	r24, 0xFF	; 255
    3d2c:	9f ef       	ldi	r25, 0xFF	; 255
    3d2e:	92 c0       	rjmp	.+292    	; 0x3e54 <recvfrom+0x330>
			else pack_len = sock_remained_size[sn];
			wiz_recv_data(sn,buf,pack_len);
		   break;
   //#if ( _WIZCHIP_ < 5200 )
		case Sn_MR_IPRAW:
		   if(sock_remained_size[sn] == 0)
    3d30:	f7 01       	movw	r30, r14
    3d32:	eb 5e       	subi	r30, 0xEB	; 235
    3d34:	f7 4f       	sbci	r31, 0xF7	; 247
    3d36:	80 81       	ld	r24, Z
    3d38:	91 81       	ldd	r25, Z+1	; 0x01
    3d3a:	89 2b       	or	r24, r25
    3d3c:	99 f5       	brne	.+102    	; 0x3da4 <recvfrom+0x280>
		   {
   			wiz_recv_data(sn, head, 6);
    3d3e:	46 e0       	ldi	r20, 0x06	; 6
    3d40:	50 e0       	ldi	r21, 0x00	; 0
    3d42:	be 01       	movw	r22, r28
    3d44:	6f 5f       	subi	r22, 0xFF	; 255
    3d46:	7f 4f       	sbci	r23, 0xFF	; 255
    3d48:	87 2d       	mov	r24, r7
    3d4a:	0e 94 c2 28 	call	0x5184	; 0x5184 <wiz_recv_data>
   			setSn_CR(sn,Sn_CR_RECV);
    3d4e:	89 85       	ldd	r24, Y+9	; 0x09
    3d50:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d52:	1c 01       	movw	r2, r24
    3d54:	99 0f       	add	r25, r25
    3d56:	44 08       	sbc	r4, r4
    3d58:	55 08       	sbc	r5, r5
    3d5a:	40 e4       	ldi	r20, 0x40	; 64
    3d5c:	c2 01       	movw	r24, r4
    3d5e:	b1 01       	movw	r22, r2
    3d60:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   			while(getSn_CR(sn));
    3d64:	c2 01       	movw	r24, r4
    3d66:	b1 01       	movw	r22, r2
    3d68:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3d6c:	81 11       	cpse	r24, r1
    3d6e:	fa cf       	rjmp	.-12     	; 0x3d64 <recvfrom+0x240>
   			addr[0] = head[0];
    3d70:	89 81       	ldd	r24, Y+1	; 0x01
    3d72:	f5 01       	movw	r30, r10
    3d74:	80 83       	st	Z, r24
   			addr[1] = head[1];
    3d76:	8a 81       	ldd	r24, Y+2	; 0x02
    3d78:	81 83       	std	Z+1, r24	; 0x01
   			addr[2] = head[2];
    3d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d7c:	82 83       	std	Z+2, r24	; 0x02
   			addr[3] = head[3];
    3d7e:	8c 81       	ldd	r24, Y+4	; 0x04
    3d80:	83 83       	std	Z+3, r24	; 0x03
   			sock_remained_size[sn] = head[4];
   			//M20150401 : For Typing Error
   			//sock_remaiend_size[sn] = (sock_remained_size[sn] << 8) + head[5];
   			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[5];
    3d82:	f7 01       	movw	r30, r14
    3d84:	eb 5e       	subi	r30, 0xEB	; 235
    3d86:	f7 4f       	sbci	r31, 0xF7	; 247
    3d88:	8d 81       	ldd	r24, Y+5	; 0x05
    3d8a:	90 e0       	ldi	r25, 0x00	; 0
    3d8c:	98 2f       	mov	r25, r24
    3d8e:	88 27       	eor	r24, r24
    3d90:	2e 81       	ldd	r18, Y+6	; 0x06
    3d92:	82 0f       	add	r24, r18
    3d94:	91 1d       	adc	r25, r1
    3d96:	91 83       	std	Z+1, r25	; 0x01
    3d98:	80 83       	st	Z, r24
   			sock_pack_info[sn] = PACK_FIRST;
    3d9a:	80 e8       	ldi	r24, 0x80	; 128
    3d9c:	f6 01       	movw	r30, r12
    3d9e:	e3 5f       	subi	r30, 0xF3	; 243
    3da0:	f7 4f       	sbci	r31, 0xF7	; 247
    3da2:	80 83       	st	Z, r24
         }
			//
			// Need to packet length check
			//
			if(len < sock_remained_size[sn]) pack_len = len;
    3da4:	f7 01       	movw	r30, r14
    3da6:	eb 5e       	subi	r30, 0xEB	; 235
    3da8:	f7 4f       	sbci	r31, 0xF7	; 247
    3daa:	80 81       	ld	r24, Z
    3dac:	91 81       	ldd	r25, Z+1	; 0x01
    3dae:	84 01       	movw	r16, r8
    3db0:	88 15       	cp	r24, r8
    3db2:	99 05       	cpc	r25, r9
    3db4:	08 f4       	brcc	.+2      	; 0x3db8 <recvfrom+0x294>
    3db6:	8c 01       	movw	r16, r24
			else pack_len = sock_remained_size[sn];
   		wiz_recv_data(sn, buf, pack_len); // data copy.
    3db8:	a8 01       	movw	r20, r16
    3dba:	6d 85       	ldd	r22, Y+13	; 0x0d
    3dbc:	7e 85       	ldd	r23, Y+14	; 0x0e
    3dbe:	87 2d       	mov	r24, r7
    3dc0:	0e 94 c2 28 	call	0x5184	; 0x5184 <wiz_recv_data>
			break;
    3dc4:	09 c0       	rjmp	.+18     	; 0x3dd8 <recvfrom+0x2b4>
   //#endif
      default:
         wiz_recv_ignore(sn, pack_len); // data copy.
    3dc6:	b8 01       	movw	r22, r16
    3dc8:	87 2d       	mov	r24, r7
    3dca:	0e 94 52 29 	call	0x52a4	; 0x52a4 <wiz_recv_ignore>
         sock_remained_size[sn] = pack_len;
    3dce:	f7 01       	movw	r30, r14
    3dd0:	eb 5e       	subi	r30, 0xEB	; 235
    3dd2:	f7 4f       	sbci	r31, 0xF7	; 247
    3dd4:	11 83       	std	Z+1, r17	; 0x01
    3dd6:	00 83       	st	Z, r16
         break;
   }
	setSn_CR(sn,Sn_CR_RECV);
    3dd8:	29 85       	ldd	r18, Y+9	; 0x09
    3dda:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ddc:	49 01       	movw	r8, r18
    3dde:	33 0f       	add	r19, r19
    3de0:	aa 08       	sbc	r10, r10
    3de2:	bb 08       	sbc	r11, r11
    3de4:	40 e4       	ldi	r20, 0x40	; 64
    3de6:	c5 01       	movw	r24, r10
    3de8:	b4 01       	movw	r22, r8
    3dea:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
	/* wait to process the command... */
	while(getSn_CR(sn)) ;
    3dee:	c5 01       	movw	r24, r10
    3df0:	b4 01       	movw	r22, r8
    3df2:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3df6:	81 11       	cpse	r24, r1
    3df8:	fa cf       	rjmp	.-12     	; 0x3dee <recvfrom+0x2ca>
	sock_remained_size[sn] -= pack_len;
    3dfa:	f7 01       	movw	r30, r14
    3dfc:	eb 5e       	subi	r30, 0xEB	; 235
    3dfe:	f7 4f       	sbci	r31, 0xF7	; 247
    3e00:	80 81       	ld	r24, Z
    3e02:	91 81       	ldd	r25, Z+1	; 0x01
    3e04:	80 1b       	sub	r24, r16
    3e06:	91 0b       	sbc	r25, r17
    3e08:	91 83       	std	Z+1, r25	; 0x01
    3e0a:	80 83       	st	Z, r24
    3e0c:	f6 01       	movw	r30, r12
    3e0e:	e3 5f       	subi	r30, 0xF3	; 243
    3e10:	f7 4f       	sbci	r31, 0xF7	; 247
	//M20150601 : 
	//if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= 0x01;
	if(sock_remained_size[sn] != 0)
    3e12:	89 2b       	or	r24, r25
    3e14:	21 f0       	breq	.+8      	; 0x3e1e <recvfrom+0x2fa>
	{
	   sock_pack_info[sn] |= PACK_REMAINED;
    3e16:	80 81       	ld	r24, Z
    3e18:	81 60       	ori	r24, 0x01	; 1
    3e1a:	80 83       	st	Z, r24
    3e1c:	01 c0       	rjmp	.+2      	; 0x3e20 <recvfrom+0x2fc>
   #if _WIZCHIP_ == 5300	   
	   if(pack_len & 0x01) sock_pack_info[sn] |= PACK_FIFOBYTE;
   #endif	      
	}
	else sock_pack_info[sn] = PACK_COMPLETED;
    3e1e:	10 82       	st	Z, r1
   pack_len = len;
#endif
   //
   //M20150409 : Explicit Type Casting
   //return pack_len;
   return (int32_t)pack_len;
    3e20:	b8 01       	movw	r22, r16
    3e22:	80 e0       	ldi	r24, 0x00	; 0
    3e24:	90 e0       	ldi	r25, 0x00	; 0
    3e26:	16 c0       	rjmp	.+44     	; 0x3e54 <recvfrom+0x330>
#endif
//   
   uint8_t  head[8];
	uint16_t pack_len=0;

   CHECK_SOCKNUM();
    3e28:	6f ef       	ldi	r22, 0xFF	; 255
    3e2a:	7f ef       	ldi	r23, 0xFF	; 255
    3e2c:	cb 01       	movw	r24, r22
    3e2e:	12 c0       	rjmp	.+36     	; 0x3e54 <recvfrom+0x330>
   #if ( _WIZCHIP_ < 5200 )         
      case Sn_MR_PPPoE:
         break;
   #endif
      default:
         return SOCKERR_SOCKMODE;
    3e30:	6b ef       	ldi	r22, 0xFB	; 251
    3e32:	7f ef       	ldi	r23, 0xFF	; 255
    3e34:	8f ef       	ldi	r24, 0xFF	; 255
    3e36:	9f ef       	ldi	r25, 0xFF	; 255
    3e38:	0d c0       	rjmp	.+26     	; 0x3e54 <recvfrom+0x330>
   }
   CHECK_SOCKDATA();
    3e3a:	62 ef       	ldi	r22, 0xF2	; 242
    3e3c:	7f ef       	ldi	r23, 0xFF	; 255
    3e3e:	8f ef       	ldi	r24, 0xFF	; 255
    3e40:	9f ef       	ldi	r25, 0xFF	; 255
    3e42:	08 c0       	rjmp	.+16     	; 0x3e54 <recvfrom+0x330>
   if(sock_remained_size[sn] == 0)
   {
      while(1)
      {
         pack_len = getSn_RX_RSR(sn);
         if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
    3e44:	6c ef       	ldi	r22, 0xFC	; 252
    3e46:	7f ef       	ldi	r23, 0xFF	; 255
    3e48:	8f ef       	ldi	r24, 0xFF	; 255
    3e4a:	9f ef       	ldi	r25, 0xFF	; 255
    3e4c:	03 c0       	rjmp	.+6      	; 0x3e54 <recvfrom+0x330>
         if( (sock_io_mode & (1<<sn)) && (pack_len == 0) ) return SOCK_BUSY;
    3e4e:	60 e0       	ldi	r22, 0x00	; 0
    3e50:	70 e0       	ldi	r23, 0x00	; 0
    3e52:	cb 01       	movw	r24, r22
#endif
   //
   //M20150409 : Explicit Type Casting
   //return pack_len;
   return (int32_t)pack_len;
}
    3e54:	60 96       	adiw	r28, 0x10	; 16
    3e56:	0f b6       	in	r0, 0x3f	; 63
    3e58:	f8 94       	cli
    3e5a:	de bf       	out	0x3e, r29	; 62
    3e5c:	0f be       	out	0x3f, r0	; 63
    3e5e:	cd bf       	out	0x3d, r28	; 61
    3e60:	df 91       	pop	r29
    3e62:	cf 91       	pop	r28
    3e64:	1f 91       	pop	r17
    3e66:	0f 91       	pop	r16
    3e68:	ff 90       	pop	r15
    3e6a:	ef 90       	pop	r14
    3e6c:	df 90       	pop	r13
    3e6e:	cf 90       	pop	r12
    3e70:	bf 90       	pop	r11
    3e72:	af 90       	pop	r10
    3e74:	9f 90       	pop	r9
    3e76:	8f 90       	pop	r8
    3e78:	7f 90       	pop	r7
    3e7a:	6f 90       	pop	r6
    3e7c:	5f 90       	pop	r5
    3e7e:	4f 90       	pop	r4
    3e80:	3f 90       	pop	r3
    3e82:	2f 90       	pop	r2
    3e84:	08 95       	ret

00003e86 <ctlsocket>:


int8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg)
{
    3e86:	0f 93       	push	r16
    3e88:	1f 93       	push	r17
    3e8a:	cf 93       	push	r28
    3e8c:	df 93       	push	r29
   uint8_t tmp = 0;
   CHECK_SOCKNUM();
    3e8e:	89 30       	cpi	r24, 0x09	; 9
    3e90:	08 f0       	brcs	.+2      	; 0x3e94 <ctlsocket+0xe>
    3e92:	88 c0       	rjmp	.+272    	; 0x3fa4 <ctlsocket+0x11e>
   switch(cstype)
    3e94:	06 2f       	mov	r16, r22
    3e96:	10 e0       	ldi	r17, 0x00	; 0
    3e98:	08 30       	cpi	r16, 0x08	; 8
    3e9a:	11 05       	cpc	r17, r1
    3e9c:	08 f0       	brcs	.+2      	; 0x3ea0 <ctlsocket+0x1a>
    3e9e:	84 c0       	rjmp	.+264    	; 0x3fa8 <ctlsocket+0x122>
    3ea0:	ea 01       	movw	r28, r20
    3ea2:	68 2f       	mov	r22, r24
    3ea4:	f8 01       	movw	r30, r16
    3ea6:	ec 5c       	subi	r30, 0xCC	; 204
    3ea8:	ff 4f       	sbci	r31, 0xFF	; 255
    3eaa:	0c 94 24 2a 	jmp	0x5448	; 0x5448 <__tablejump2__>
   {
      case CS_SET_IOMODE:
         tmp = *((uint8_t*)arg);
    3eae:	88 81       	ld	r24, Y
         if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
    3eb0:	81 30       	cpi	r24, 0x01	; 1
    3eb2:	71 f4       	brne	.+28     	; 0x3ed0 <ctlsocket+0x4a>
    3eb4:	81 e0       	ldi	r24, 0x01	; 1
    3eb6:	90 e0       	ldi	r25, 0x00	; 0
    3eb8:	02 c0       	rjmp	.+4      	; 0x3ebe <ctlsocket+0x38>
    3eba:	88 0f       	add	r24, r24
    3ebc:	99 1f       	adc	r25, r25
    3ebe:	6a 95       	dec	r22
    3ec0:	e2 f7       	brpl	.-8      	; 0x3eba <ctlsocket+0x34>
    3ec2:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <sock_io_mode>
    3ec6:	30 91 28 08 	lds	r19, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3eca:	82 2b       	or	r24, r18
    3ecc:	93 2b       	or	r25, r19
    3ece:	11 c0       	rjmp	.+34     	; 0x3ef2 <ctlsocket+0x6c>
         else if(tmp == SOCK_IO_BLOCK) sock_io_mode &= ~(1<<sn);
    3ed0:	81 11       	cpse	r24, r1
    3ed2:	6a c0       	rjmp	.+212    	; 0x3fa8 <ctlsocket+0x122>
    3ed4:	81 e0       	ldi	r24, 0x01	; 1
    3ed6:	90 e0       	ldi	r25, 0x00	; 0
    3ed8:	02 c0       	rjmp	.+4      	; 0x3ede <ctlsocket+0x58>
    3eda:	88 0f       	add	r24, r24
    3edc:	99 1f       	adc	r25, r25
    3ede:	6a 95       	dec	r22
    3ee0:	e2 f7       	brpl	.-8      	; 0x3eda <ctlsocket+0x54>
    3ee2:	80 95       	com	r24
    3ee4:	90 95       	com	r25
    3ee6:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <sock_io_mode>
    3eea:	30 91 28 08 	lds	r19, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3eee:	82 23       	and	r24, r18
    3ef0:	93 23       	and	r25, r19
    3ef2:	90 93 28 08 	sts	0x0828, r25	; 0x800828 <sock_io_mode+0x1>
    3ef6:	80 93 27 08 	sts	0x0827, r24	; 0x800827 <sock_io_mode>
    3efa:	1b c0       	rjmp	.+54     	; 0x3f32 <ctlsocket+0xac>
         else return SOCKERR_ARG;
         break;
      case CS_GET_IOMODE:   
         //M20140501 : implict type casting -> explict type casting
         //*((uint8_t*)arg) = (sock_io_mode >> sn) & 0x0001;
         *((uint8_t*)arg) = (uint8_t)((sock_io_mode >> sn) & 0x0001);
    3efc:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <sock_io_mode>
    3f00:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <sock_io_mode+0x1>
    3f04:	02 c0       	rjmp	.+4      	; 0x3f0a <ctlsocket+0x84>
    3f06:	96 95       	lsr	r25
    3f08:	87 95       	ror	r24
    3f0a:	6a 95       	dec	r22
    3f0c:	e2 f7       	brpl	.-8      	; 0x3f06 <ctlsocket+0x80>
    3f0e:	81 70       	andi	r24, 0x01	; 1
    3f10:	47 c0       	rjmp	.+142    	; 0x3fa0 <ctlsocket+0x11a>
         //
         break;
      case CS_GET_MAXTXBUF:
         *((uint16_t*)arg) = getSn_TxMAX(sn);
    3f12:	80 e2       	ldi	r24, 0x20	; 32
    3f14:	68 9f       	mul	r22, r24
    3f16:	b0 01       	movw	r22, r0
    3f18:	11 24       	eor	r1, r1
    3f1a:	68 5f       	subi	r22, 0xF8	; 248
    3f1c:	70 4e       	sbci	r23, 0xE0	; 224
    3f1e:	07 2e       	mov	r0, r23
    3f20:	00 0c       	add	r0, r0
    3f22:	88 0b       	sbc	r24, r24
    3f24:	99 0b       	sbc	r25, r25
    3f26:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3f2a:	88 0f       	add	r24, r24
    3f2c:	88 0f       	add	r24, r24
    3f2e:	18 82       	st	Y, r1
    3f30:	89 83       	std	Y+1, r24	; 0x01
         break;
   #endif
      default:
         return SOCKERR_ARG;
   }
   return SOCK_OK;
    3f32:	81 e0       	ldi	r24, 0x01	; 1
         *((uint8_t*)arg) = (uint8_t)((sock_io_mode >> sn) & 0x0001);
         //
         break;
      case CS_GET_MAXTXBUF:
         *((uint16_t*)arg) = getSn_TxMAX(sn);
         break;
    3f34:	3a c0       	rjmp	.+116    	; 0x3faa <ctlsocket+0x124>
      case CS_GET_MAXRXBUF:    
         *((uint16_t*)arg) = getSn_RxMAX(sn);
    3f36:	80 e2       	ldi	r24, 0x20	; 32
    3f38:	68 9f       	mul	r22, r24
    3f3a:	b0 01       	movw	r22, r0
    3f3c:	11 24       	eor	r1, r1
    3f3e:	68 5f       	subi	r22, 0xF8	; 248
    3f40:	71 4e       	sbci	r23, 0xE1	; 225
    3f42:	ed cf       	rjmp	.-38     	; 0x3f1e <ctlsocket+0x98>
         break;
      case CS_CLR_INTERRUPT:
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    3f44:	48 81       	ld	r20, Y
    3f46:	40 32       	cpi	r20, 0x20	; 32
    3f48:	78 f5       	brcc	.+94     	; 0x3fa8 <ctlsocket+0x122>
         setSn_IR(sn,*(uint8_t*)arg);
    3f4a:	80 e2       	ldi	r24, 0x20	; 32
    3f4c:	68 9f       	mul	r22, r24
    3f4e:	b0 01       	movw	r22, r0
    3f50:	11 24       	eor	r1, r1
    3f52:	68 5f       	subi	r22, 0xF8	; 248
    3f54:	7d 4f       	sbci	r23, 0xFD	; 253
    3f56:	10 c0       	rjmp	.+32     	; 0x3f78 <ctlsocket+0xf2>
         break;
      case CS_GET_INTERRUPT:
         *((uint8_t*)arg) = getSn_IR(sn);
    3f58:	80 e2       	ldi	r24, 0x20	; 32
    3f5a:	68 9f       	mul	r22, r24
    3f5c:	b0 01       	movw	r22, r0
    3f5e:	11 24       	eor	r1, r1
    3f60:	68 5f       	subi	r22, 0xF8	; 248
    3f62:	7d 4f       	sbci	r23, 0xFD	; 253
    3f64:	16 c0       	rjmp	.+44     	; 0x3f92 <ctlsocket+0x10c>
         break;
   #if _WIZCHIP_ != 5100
      case CS_SET_INTMASK:  
         if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
    3f66:	48 81       	ld	r20, Y
    3f68:	40 32       	cpi	r20, 0x20	; 32
    3f6a:	f0 f4       	brcc	.+60     	; 0x3fa8 <ctlsocket+0x122>
         setSn_IMR(sn,*(uint8_t*)arg);
    3f6c:	80 e2       	ldi	r24, 0x20	; 32
    3f6e:	68 9f       	mul	r22, r24
    3f70:	b0 01       	movw	r22, r0
    3f72:	11 24       	eor	r1, r1
    3f74:	68 5f       	subi	r22, 0xF8	; 248
    3f76:	73 4d       	sbci	r23, 0xD3	; 211
    3f78:	07 2e       	mov	r0, r23
    3f7a:	00 0c       	add	r0, r0
    3f7c:	88 0b       	sbc	r24, r24
    3f7e:	99 0b       	sbc	r25, r25
    3f80:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    3f84:	d6 cf       	rjmp	.-84     	; 0x3f32 <ctlsocket+0xac>
         break;
      case CS_GET_INTMASK:   
         *((uint8_t*)arg) = getSn_IMR(sn);
    3f86:	80 e2       	ldi	r24, 0x20	; 32
    3f88:	68 9f       	mul	r22, r24
    3f8a:	b0 01       	movw	r22, r0
    3f8c:	11 24       	eor	r1, r1
    3f8e:	68 5f       	subi	r22, 0xF8	; 248
    3f90:	73 4d       	sbci	r23, 0xD3	; 211
    3f92:	07 2e       	mov	r0, r23
    3f94:	00 0c       	add	r0, r0
    3f96:	88 0b       	sbc	r24, r24
    3f98:	99 0b       	sbc	r25, r25
    3f9a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    3f9e:	8f 71       	andi	r24, 0x1F	; 31
    3fa0:	88 83       	st	Y, r24
    3fa2:	c7 cf       	rjmp	.-114    	; 0x3f32 <ctlsocket+0xac>


int8_t  ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg)
{
   uint8_t tmp = 0;
   CHECK_SOCKNUM();
    3fa4:	8f ef       	ldi	r24, 0xFF	; 255
    3fa6:	01 c0       	rjmp	.+2      	; 0x3faa <ctlsocket+0x124>
   {
      case CS_SET_IOMODE:
         tmp = *((uint8_t*)arg);
         if(tmp == SOCK_IO_NONBLOCK)  sock_io_mode |= (1<<sn);
         else if(tmp == SOCK_IO_BLOCK) sock_io_mode &= ~(1<<sn);
         else return SOCKERR_ARG;
    3fa8:	86 ef       	ldi	r24, 0xF6	; 246
   #endif
      default:
         return SOCKERR_ARG;
   }
   return SOCK_OK;
}
    3faa:	df 91       	pop	r29
    3fac:	cf 91       	pop	r28
    3fae:	1f 91       	pop	r17
    3fb0:	0f 91       	pop	r16
    3fb2:	08 95       	ret

00003fb4 <setsockopt>:

int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
    3fb4:	8f 92       	push	r8
    3fb6:	9f 92       	push	r9
    3fb8:	af 92       	push	r10
    3fba:	bf 92       	push	r11
    3fbc:	cf 92       	push	r12
    3fbe:	df 92       	push	r13
    3fc0:	ef 92       	push	r14
    3fc2:	ff 92       	push	r15
    3fc4:	0f 93       	push	r16
    3fc6:	1f 93       	push	r17
    3fc8:	cf 93       	push	r28
    3fca:	df 93       	push	r29
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
    3fcc:	89 30       	cpi	r24, 0x09	; 9
    3fce:	08 f0       	brcs	.+2      	; 0x3fd2 <setsockopt+0x1e>
    3fd0:	98 c0       	rjmp	.+304    	; 0x4102 <setsockopt+0x14e>
   switch(sotype)
    3fd2:	06 2f       	mov	r16, r22
    3fd4:	10 e0       	ldi	r17, 0x00	; 0
    3fd6:	f8 01       	movw	r30, r16
    3fd8:	31 97       	sbiw	r30, 0x01	; 1
    3fda:	e7 30       	cpi	r30, 0x07	; 7
    3fdc:	f1 05       	cpc	r31, r1
    3fde:	08 f0       	brcs	.+2      	; 0x3fe2 <setsockopt+0x2e>
    3fe0:	92 c0       	rjmp	.+292    	; 0x4106 <setsockopt+0x152>
    3fe2:	ea 01       	movw	r28, r20
    3fe4:	e4 5c       	subi	r30, 0xC4	; 196
    3fe6:	ff 4f       	sbci	r31, 0xFF	; 255
    3fe8:	68 2f       	mov	r22, r24
    3fea:	70 e0       	ldi	r23, 0x00	; 0
         		}
            }
         break;
   #if _WIZCHIP_ > 5100
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
    3fec:	85 e0       	ldi	r24, 0x05	; 5
    3fee:	66 0f       	add	r22, r22
    3ff0:	77 1f       	adc	r23, r23
    3ff2:	8a 95       	dec	r24
    3ff4:	e1 f7       	brne	.-8      	; 0x3fee <setsockopt+0x3a>
int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
   switch(sotype)
    3ff6:	0c 94 24 2a 	jmp	0x5448	; 0x5448 <__tablejump2__>
   {
      case SO_TTL:
         setSn_TTL(sn,*(uint8_t*)arg);
    3ffa:	68 5f       	subi	r22, 0xF8	; 248
    3ffc:	79 4e       	sbci	r23, 0xE9	; 233
    3ffe:	78 c0       	rjmp	.+240    	; 0x40f0 <setsockopt+0x13c>
         break;
      case SO_TOS:
         setSn_TOS(sn,*(uint8_t*)arg);
    4000:	68 5f       	subi	r22, 0xF8	; 248
    4002:	7a 4e       	sbci	r23, 0xEA	; 234
    4004:	75 c0       	rjmp	.+234    	; 0x40f0 <setsockopt+0x13c>
         break;
      case SO_MSS:
         setSn_MSSR(sn,*(uint16_t*)arg);
    4006:	8b 01       	movw	r16, r22
    4008:	08 5f       	subi	r16, 0xF8	; 248
    400a:	1f 4f       	sbci	r17, 0xFF	; 255
    400c:	49 81       	ldd	r20, Y+1	; 0x01
    400e:	68 5f       	subi	r22, 0xF8	; 248
    4010:	7d 4e       	sbci	r23, 0xED	; 237
    4012:	07 2e       	mov	r0, r23
    4014:	00 0c       	add	r0, r0
    4016:	88 0b       	sbc	r24, r24
    4018:	99 0b       	sbc	r25, r25
    401a:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    401e:	b8 01       	movw	r22, r16
    4020:	7d 5e       	subi	r23, 0xED	; 237
    4022:	66 c0       	rjmp	.+204    	; 0x40f0 <setsockopt+0x13c>
         break;
      case SO_DESTIP:
         setSn_DIPR(sn, (uint8_t*)arg);
    4024:	68 5f       	subi	r22, 0xF8	; 248
    4026:	73 4f       	sbci	r23, 0xF3	; 243
    4028:	07 2e       	mov	r0, r23
    402a:	00 0c       	add	r0, r0
    402c:	88 0b       	sbc	r24, r24
    402e:	99 0b       	sbc	r25, r25
    4030:	24 e0       	ldi	r18, 0x04	; 4
    4032:	30 e0       	ldi	r19, 0x00	; 0
    4034:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
    4038:	62 c0       	rjmp	.+196    	; 0x40fe <setsockopt+0x14a>
         break;
      case SO_DESTPORT:
         setSn_DPORT(sn, *(uint16_t*)arg);
    403a:	8b 01       	movw	r16, r22
    403c:	08 5f       	subi	r16, 0xF8	; 248
    403e:	1f 4f       	sbci	r17, 0xFF	; 255
    4040:	49 81       	ldd	r20, Y+1	; 0x01
    4042:	68 5f       	subi	r22, 0xF8	; 248
    4044:	7f 4e       	sbci	r23, 0xEF	; 239
    4046:	07 2e       	mov	r0, r23
    4048:	00 0c       	add	r0, r0
    404a:	88 0b       	sbc	r24, r24
    404c:	99 0b       	sbc	r25, r25
    404e:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    4052:	b8 01       	movw	r22, r16
    4054:	7f 5e       	subi	r23, 0xEF	; 239
    4056:	4c c0       	rjmp	.+152    	; 0x40f0 <setsockopt+0x13c>
         break;
#if _WIZCHIP_ != 5100
      case SO_KEEPALIVESEND:
         CHECK_SOCKMODE(Sn_MR_TCP);
    4058:	eb 01       	movw	r28, r22
    405a:	28 96       	adiw	r28, 0x08	; 8
    405c:	be 01       	movw	r22, r28
    405e:	0d 2e       	mov	r0, r29
    4060:	00 0c       	add	r0, r0
    4062:	88 0b       	sbc	r24, r24
    4064:	99 0b       	sbc	r25, r25
    4066:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    406a:	8f 70       	andi	r24, 0x0F	; 15
    406c:	81 30       	cpi	r24, 0x01	; 1
    406e:	11 f0       	breq	.+4      	; 0x4074 <setsockopt+0xc0>
    4070:	8b ef       	ldi	r24, 0xFB	; 251
    4072:	4c c0       	rjmp	.+152    	; 0x410c <setsockopt+0x158>
         #if _WIZCHIP_ > 5200
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
    4074:	be 01       	movw	r22, r28
    4076:	71 5d       	subi	r23, 0xD1	; 209
    4078:	07 2e       	mov	r0, r23
    407a:	00 0c       	add	r0, r0
    407c:	88 0b       	sbc	r24, r24
    407e:	99 0b       	sbc	r25, r25
    4080:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4084:	81 11       	cpse	r24, r1
    4086:	41 c0       	rjmp	.+130    	; 0x410a <setsockopt+0x156>
         #endif
            setSn_CR(sn,Sn_CR_SEND_KEEP);
    4088:	4e 01       	movw	r8, r28
    408a:	93 94       	inc	r9
    408c:	09 2c       	mov	r0, r9
    408e:	00 0c       	add	r0, r0
    4090:	aa 08       	sbc	r10, r10
    4092:	bb 08       	sbc	r11, r11
    4094:	42 e2       	ldi	r20, 0x22	; 34
    4096:	c5 01       	movw	r24, r10
    4098:	b4 01       	movw	r22, r8
    409a:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
            while(getSn_CR(sn) != 0)
            {
               // M20131220
         		//if ((tmp = getSn_IR(sn)) & Sn_IR_TIMEOUT)
               if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    409e:	6e 01       	movw	r12, r28
    40a0:	8e ef       	ldi	r24, 0xFE	; 254
    40a2:	d8 1a       	sub	r13, r24
    40a4:	0d 2c       	mov	r0, r13
    40a6:	00 0c       	add	r0, r0
    40a8:	ee 08       	sbc	r14, r14
    40aa:	ff 08       	sbc	r15, r15
         CHECK_SOCKMODE(Sn_MR_TCP);
         #if _WIZCHIP_ > 5200
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
         #endif
            setSn_CR(sn,Sn_CR_SEND_KEEP);
            while(getSn_CR(sn) != 0)
    40ac:	c5 01       	movw	r24, r10
    40ae:	b4 01       	movw	r22, r8
    40b0:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    40b4:	88 23       	and	r24, r24
    40b6:	19 f1       	breq	.+70     	; 0x40fe <setsockopt+0x14a>
            {
               // M20131220
         		//if ((tmp = getSn_IR(sn)) & Sn_IR_TIMEOUT)
               if (getSn_IR(sn) & Sn_IR_TIMEOUT)
    40b8:	c7 01       	movw	r24, r14
    40ba:	b6 01       	movw	r22, r12
    40bc:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    40c0:	83 ff       	sbrs	r24, 3
    40c2:	f4 cf       	rjmp	.-24     	; 0x40ac <setsockopt+0xf8>
         		{
         			setSn_IR(sn, Sn_IR_TIMEOUT);
    40c4:	48 e0       	ldi	r20, 0x08	; 8
    40c6:	c7 01       	movw	r24, r14
    40c8:	b6 01       	movw	r22, r12
    40ca:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
                  return SOCKERR_TIMEOUT;
    40ce:	83 ef       	ldi	r24, 0xF3	; 243
    40d0:	1d c0       	rjmp	.+58     	; 0x410c <setsockopt+0x158>
         		}
            }
         break;
   #if _WIZCHIP_ > 5100
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
    40d2:	8b 01       	movw	r16, r22
    40d4:	08 5f       	subi	r16, 0xF8	; 248
    40d6:	1f 4f       	sbci	r17, 0xFF	; 255
    40d8:	b8 01       	movw	r22, r16
    40da:	01 2e       	mov	r0, r17
    40dc:	00 0c       	add	r0, r0
    40de:	88 0b       	sbc	r24, r24
    40e0:	99 0b       	sbc	r25, r25
    40e2:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    40e6:	8f 70       	andi	r24, 0x0F	; 15
    40e8:	81 30       	cpi	r24, 0x01	; 1
    40ea:	11 f6       	brne	.-124    	; 0x4070 <setsockopt+0xbc>
         setSn_KPALVTR(sn,*(uint8_t*)arg);
    40ec:	b8 01       	movw	r22, r16
    40ee:	71 5d       	subi	r23, 0xD1	; 209
    40f0:	07 2e       	mov	r0, r23
    40f2:	00 0c       	add	r0, r0
    40f4:	88 0b       	sbc	r24, r24
    40f6:	99 0b       	sbc	r25, r25
    40f8:	48 81       	ld	r20, Y
    40fa:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   #endif      
#endif   
      default:
         return SOCKERR_ARG;
   }   
   return SOCK_OK;
    40fe:	81 e0       	ldi	r24, 0x01	; 1
         break;
   #if _WIZCHIP_ > 5100
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
         setSn_KPALVTR(sn,*(uint8_t*)arg);
         break;
    4100:	05 c0       	rjmp	.+10     	; 0x410c <setsockopt+0x158>

int8_t  setsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
 // M20131220 : Remove warning
 //uint8_t tmp;
   CHECK_SOCKNUM();
    4102:	8f ef       	ldi	r24, 0xFF	; 255
    4104:	03 c0       	rjmp	.+6      	; 0x410c <setsockopt+0x158>
         setSn_KPALVTR(sn,*(uint8_t*)arg);
         break;
   #endif      
#endif   
      default:
         return SOCKERR_ARG;
    4106:	86 ef       	ldi	r24, 0xF6	; 246
    4108:	01 c0       	rjmp	.+2      	; 0x410c <setsockopt+0x158>
         break;
#if _WIZCHIP_ != 5100
      case SO_KEEPALIVESEND:
         CHECK_SOCKMODE(Sn_MR_TCP);
         #if _WIZCHIP_ > 5200
            if(getSn_KPALVTR(sn) != 0) return SOCKERR_SOCKOPT;
    410a:	8e ef       	ldi	r24, 0xFE	; 254
#endif   
      default:
         return SOCKERR_ARG;
   }   
   return SOCK_OK;
}
    410c:	df 91       	pop	r29
    410e:	cf 91       	pop	r28
    4110:	1f 91       	pop	r17
    4112:	0f 91       	pop	r16
    4114:	ff 90       	pop	r15
    4116:	ef 90       	pop	r14
    4118:	df 90       	pop	r13
    411a:	cf 90       	pop	r12
    411c:	bf 90       	pop	r11
    411e:	af 90       	pop	r10
    4120:	9f 90       	pop	r9
    4122:	8f 90       	pop	r8
    4124:	08 95       	ret

00004126 <getsockopt>:

int8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
    4126:	ef 92       	push	r14
    4128:	ff 92       	push	r15
    412a:	0f 93       	push	r16
    412c:	1f 93       	push	r17
    412e:	cf 93       	push	r28
    4130:	df 93       	push	r29
    4132:	c8 2f       	mov	r28, r24
   CHECK_SOCKNUM();
    4134:	89 30       	cpi	r24, 0x09	; 9
    4136:	08 f0       	brcs	.+2      	; 0x413a <getsockopt+0x14>
    4138:	df c0       	rjmp	.+446    	; 0x42f8 <getsockopt+0x1d2>
   switch(sotype)
    413a:	86 2f       	mov	r24, r22
    413c:	90 e0       	ldi	r25, 0x00	; 0
    413e:	8d 30       	cpi	r24, 0x0D	; 13
    4140:	91 05       	cpc	r25, r1
    4142:	08 f0       	brcs	.+2      	; 0x4146 <getsockopt+0x20>
    4144:	db c0       	rjmp	.+438    	; 0x42fc <getsockopt+0x1d6>
    4146:	8a 01       	movw	r16, r20
    4148:	fc 01       	movw	r30, r24
    414a:	ed 5b       	subi	r30, 0xBD	; 189
    414c:	ff 4f       	sbci	r31, 0xFF	; 255
    414e:	0c 94 24 2a 	jmp	0x5448	; 0x5448 <__tablejump2__>
   {
      case SO_FLAG:
         *(uint8_t*)arg = getSn_MR(sn) & 0xF0;
    4152:	84 e0       	ldi	r24, 0x04	; 4
    4154:	c8 9f       	mul	r28, r24
    4156:	e0 01       	movw	r28, r0
    4158:	11 24       	eor	r1, r1
    415a:	21 96       	adiw	r28, 0x01	; 1
    415c:	73 e0       	ldi	r23, 0x03	; 3
    415e:	cc 0f       	add	r28, r28
    4160:	dd 1f       	adc	r29, r29
    4162:	7a 95       	dec	r23
    4164:	e1 f7       	brne	.-8      	; 0x415e <getsockopt+0x38>
    4166:	be 01       	movw	r22, r28
    4168:	dd 0f       	add	r29, r29
    416a:	88 0b       	sbc	r24, r24
    416c:	99 0b       	sbc	r25, r25
    416e:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4172:	80 7f       	andi	r24, 0xF0	; 240
    4174:	bd c0       	rjmp	.+378    	; 0x42f0 <getsockopt+0x1ca>
         break;
      case SO_TTL:
         *(uint8_t*) arg = getSn_TTL(sn);
    4176:	f0 e2       	ldi	r31, 0x20	; 32
    4178:	cf 9f       	mul	r28, r31
    417a:	e0 01       	movw	r28, r0
    417c:	11 24       	eor	r1, r1
    417e:	c8 5f       	subi	r28, 0xF8	; 248
    4180:	d9 4e       	sbci	r29, 0xE9	; 233
    4182:	06 c0       	rjmp	.+12     	; 0x4190 <getsockopt+0x6a>
         break;
      case SO_TOS:
         *(uint8_t*) arg = getSn_TOS(sn);
    4184:	f0 e2       	ldi	r31, 0x20	; 32
    4186:	cf 9f       	mul	r28, r31
    4188:	e0 01       	movw	r28, r0
    418a:	11 24       	eor	r1, r1
    418c:	c8 5f       	subi	r28, 0xF8	; 248
    418e:	da 4e       	sbci	r29, 0xEA	; 234
    4190:	be 01       	movw	r22, r28
    4192:	dd 0f       	add	r29, r29
    4194:	88 0b       	sbc	r24, r24
    4196:	99 0b       	sbc	r25, r25
    4198:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    419c:	a9 c0       	rjmp	.+338    	; 0x42f0 <getsockopt+0x1ca>
         break;
      case SO_MSS:   
         *(uint16_t*) arg = getSn_MSSR(sn);
    419e:	f4 e0       	ldi	r31, 0x04	; 4
    41a0:	cf 9f       	mul	r28, r31
    41a2:	e0 01       	movw	r28, r0
    41a4:	11 24       	eor	r1, r1
    41a6:	21 96       	adiw	r28, 0x01	; 1
    41a8:	63 e0       	ldi	r22, 0x03	; 3
    41aa:	cc 0f       	add	r28, r28
    41ac:	dd 1f       	adc	r29, r29
    41ae:	6a 95       	dec	r22
    41b0:	e1 f7       	brne	.-8      	; 0x41aa <getsockopt+0x84>
    41b2:	be 01       	movw	r22, r28
    41b4:	7e 5e       	subi	r23, 0xEE	; 238
    41b6:	07 2e       	mov	r0, r23
    41b8:	00 0c       	add	r0, r0
    41ba:	88 0b       	sbc	r24, r24
    41bc:	99 0b       	sbc	r25, r25
    41be:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    41c2:	f8 2e       	mov	r15, r24
    41c4:	dd 5e       	subi	r29, 0xED	; 237
    41c6:	23 c0       	rjmp	.+70     	; 0x420e <getsockopt+0xe8>
         break;
      case SO_DESTIP:
         getSn_DIPR(sn, (uint8_t*)arg);
    41c8:	f0 e2       	ldi	r31, 0x20	; 32
    41ca:	cf 9f       	mul	r28, r31
    41cc:	e0 01       	movw	r28, r0
    41ce:	11 24       	eor	r1, r1
    41d0:	c8 5f       	subi	r28, 0xF8	; 248
    41d2:	d3 4f       	sbci	r29, 0xF3	; 243
    41d4:	be 01       	movw	r22, r28
    41d6:	dd 0f       	add	r29, r29
    41d8:	88 0b       	sbc	r24, r24
    41da:	99 0b       	sbc	r25, r25
    41dc:	24 e0       	ldi	r18, 0x04	; 4
    41de:	30 e0       	ldi	r19, 0x00	; 0
    41e0:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
    41e4:	87 c0       	rjmp	.+270    	; 0x42f4 <getsockopt+0x1ce>
         break;
      case SO_DESTPORT:  
         *(uint16_t*) arg = getSn_DPORT(sn);
    41e6:	84 e0       	ldi	r24, 0x04	; 4
    41e8:	c8 9f       	mul	r28, r24
    41ea:	e0 01       	movw	r28, r0
    41ec:	11 24       	eor	r1, r1
    41ee:	21 96       	adiw	r28, 0x01	; 1
    41f0:	53 e0       	ldi	r21, 0x03	; 3
    41f2:	cc 0f       	add	r28, r28
    41f4:	dd 1f       	adc	r29, r29
    41f6:	5a 95       	dec	r21
    41f8:	e1 f7       	brne	.-8      	; 0x41f2 <getsockopt+0xcc>
    41fa:	be 01       	movw	r22, r28
    41fc:	70 5f       	subi	r23, 0xF0	; 240
    41fe:	07 2e       	mov	r0, r23
    4200:	00 0c       	add	r0, r0
    4202:	88 0b       	sbc	r24, r24
    4204:	99 0b       	sbc	r25, r25
    4206:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    420a:	f8 2e       	mov	r15, r24
    420c:	df 5e       	subi	r29, 0xEF	; 239
    420e:	be 01       	movw	r22, r28
    4210:	dd 0f       	add	r29, r29
    4212:	88 0b       	sbc	r24, r24
    4214:	99 0b       	sbc	r25, r25
    4216:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    421a:	2f 2d       	mov	r18, r15
    421c:	30 e0       	ldi	r19, 0x00	; 0
    421e:	32 2f       	mov	r19, r18
    4220:	22 27       	eor	r18, r18
    4222:	28 0f       	add	r18, r24
    4224:	31 1d       	adc	r19, r1
    4226:	f8 01       	movw	r30, r16
    4228:	31 83       	std	Z+1, r19	; 0x01
    422a:	20 83       	st	Z, r18
    422c:	63 c0       	rjmp	.+198    	; 0x42f4 <getsockopt+0x1ce>
         break;
   #if _WIZCHIP_ > 5200   
      case SO_KEEPALIVEAUTO:
         CHECK_SOCKMODE(Sn_MR_TCP);
    422e:	f4 e0       	ldi	r31, 0x04	; 4
    4230:	cf 9f       	mul	r28, r31
    4232:	e0 01       	movw	r28, r0
    4234:	11 24       	eor	r1, r1
    4236:	21 96       	adiw	r28, 0x01	; 1
    4238:	33 e0       	ldi	r19, 0x03	; 3
    423a:	cc 0f       	add	r28, r28
    423c:	dd 1f       	adc	r29, r29
    423e:	3a 95       	dec	r19
    4240:	e1 f7       	brne	.-8      	; 0x423a <getsockopt+0x114>
    4242:	be 01       	movw	r22, r28
    4244:	0d 2e       	mov	r0, r29
    4246:	00 0c       	add	r0, r0
    4248:	88 0b       	sbc	r24, r24
    424a:	99 0b       	sbc	r25, r25
    424c:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4250:	8f 70       	andi	r24, 0x0F	; 15
    4252:	81 30       	cpi	r24, 0x01	; 1
    4254:	11 f0       	breq	.+4      	; 0x425a <getsockopt+0x134>
    4256:	8b ef       	ldi	r24, 0xFB	; 251
    4258:	52 c0       	rjmp	.+164    	; 0x42fe <getsockopt+0x1d8>
         *(uint16_t*) arg = getSn_KPALVTR(sn);
    425a:	be 01       	movw	r22, r28
    425c:	71 5d       	subi	r23, 0xD1	; 209
    425e:	07 2e       	mov	r0, r23
    4260:	00 0c       	add	r0, r0
    4262:	88 0b       	sbc	r24, r24
    4264:	99 0b       	sbc	r25, r25
    4266:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    426a:	90 e0       	ldi	r25, 0x00	; 0
    426c:	28 c0       	rjmp	.+80     	; 0x42be <getsockopt+0x198>
         break;
   #endif      
      case SO_SENDBUF:
         *(uint16_t*) arg = getSn_TX_FSR(sn);
    426e:	8c 2f       	mov	r24, r28
    4270:	0e 94 82 27 	call	0x4f04	; 0x4f04 <getSn_TX_FSR>
    4274:	24 c0       	rjmp	.+72     	; 0x42be <getsockopt+0x198>
         break;
      case SO_RECVBUF:
         *(uint16_t*) arg = getSn_RX_RSR(sn);
         break;
      case SO_STATUS:
         *(uint8_t*) arg = getSn_SR(sn);
    4276:	f0 e2       	ldi	r31, 0x20	; 32
    4278:	cf 9f       	mul	r28, r31
    427a:	e0 01       	movw	r28, r0
    427c:	11 24       	eor	r1, r1
    427e:	c8 5f       	subi	r28, 0xF8	; 248
    4280:	dc 4f       	sbci	r29, 0xFC	; 252
    4282:	86 cf       	rjmp	.-244    	; 0x4190 <getsockopt+0x6a>
         break;
      case SO_REMAINSIZE:
         if(getSn_MR(sn) & Sn_MR_TCP)
    4284:	ec 2e       	mov	r14, r28
    4286:	f1 2c       	mov	r15, r1
    4288:	b7 01       	movw	r22, r14
    428a:	25 e0       	ldi	r18, 0x05	; 5
    428c:	66 0f       	add	r22, r22
    428e:	77 1f       	adc	r23, r23
    4290:	2a 95       	dec	r18
    4292:	e1 f7       	brne	.-8      	; 0x428c <getsockopt+0x166>
    4294:	68 5f       	subi	r22, 0xF8	; 248
    4296:	7f 4f       	sbci	r23, 0xFF	; 255
    4298:	07 2e       	mov	r0, r23
    429a:	00 0c       	add	r0, r0
    429c:	88 0b       	sbc	r24, r24
    429e:	99 0b       	sbc	r25, r25
    42a0:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    42a4:	80 ff       	sbrs	r24, 0
    42a6:	04 c0       	rjmp	.+8      	; 0x42b0 <getsockopt+0x18a>
            *(uint16_t*)arg = getSn_RX_RSR(sn);
    42a8:	8c 2f       	mov	r24, r28
    42aa:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <getSn_RX_RSR>
    42ae:	07 c0       	rjmp	.+14     	; 0x42be <getsockopt+0x198>
         else
            *(uint16_t*)arg = sock_remained_size[sn];
    42b0:	f7 01       	movw	r30, r14
    42b2:	ee 0f       	add	r30, r30
    42b4:	ff 1f       	adc	r31, r31
    42b6:	eb 5e       	subi	r30, 0xEB	; 235
    42b8:	f7 4f       	sbci	r31, 0xF7	; 247
    42ba:	80 81       	ld	r24, Z
    42bc:	91 81       	ldd	r25, Z+1	; 0x01
    42be:	f8 01       	movw	r30, r16
    42c0:	91 83       	std	Z+1, r25	; 0x01
    42c2:	80 83       	st	Z, r24
    42c4:	17 c0       	rjmp	.+46     	; 0x42f4 <getsockopt+0x1ce>
         break;
      case SO_PACKINFO:
         //CHECK_SOCKMODE(Sn_MR_TCP);
#if _WIZCHIP_ != 5300
         if((getSn_MR(sn) == Sn_MR_TCP))
    42c6:	d0 e0       	ldi	r29, 0x00	; 0
    42c8:	be 01       	movw	r22, r28
    42ca:	85 e0       	ldi	r24, 0x05	; 5
    42cc:	66 0f       	add	r22, r22
    42ce:	77 1f       	adc	r23, r23
    42d0:	8a 95       	dec	r24
    42d2:	e1 f7       	brne	.-8      	; 0x42cc <getsockopt+0x1a6>
    42d4:	68 5f       	subi	r22, 0xF8	; 248
    42d6:	7f 4f       	sbci	r23, 0xFF	; 255
    42d8:	07 2e       	mov	r0, r23
    42da:	00 0c       	add	r0, r0
    42dc:	88 0b       	sbc	r24, r24
    42de:	99 0b       	sbc	r25, r25
    42e0:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    42e4:	81 30       	cpi	r24, 0x01	; 1
    42e6:	09 f4       	brne	.+2      	; 0x42ea <getsockopt+0x1c4>
    42e8:	b6 cf       	rjmp	.-148    	; 0x4256 <getsockopt+0x130>
             return SOCKERR_SOCKMODE;
#endif
         *(uint8_t*)arg = sock_pack_info[sn];
    42ea:	c3 5f       	subi	r28, 0xF3	; 243
    42ec:	d7 4f       	sbci	r29, 0xF7	; 247
    42ee:	88 81       	ld	r24, Y
    42f0:	f8 01       	movw	r30, r16
    42f2:	80 83       	st	Z, r24
         break;
      default:
         return SOCKERR_SOCKOPT;
   }
   return SOCK_OK;
    42f4:	81 e0       	ldi	r24, 0x01	; 1
#if _WIZCHIP_ != 5300
         if((getSn_MR(sn) == Sn_MR_TCP))
             return SOCKERR_SOCKMODE;
#endif
         *(uint8_t*)arg = sock_pack_info[sn];
         break;
    42f6:	03 c0       	rjmp	.+6      	; 0x42fe <getsockopt+0x1d8>
   return SOCK_OK;
}

int8_t  getsockopt(uint8_t sn, sockopt_type sotype, void* arg)
{
   CHECK_SOCKNUM();
    42f8:	8f ef       	ldi	r24, 0xFF	; 255
    42fa:	01 c0       	rjmp	.+2      	; 0x42fe <getsockopt+0x1d8>
             return SOCKERR_SOCKMODE;
#endif
         *(uint8_t*)arg = sock_pack_info[sn];
         break;
      default:
         return SOCKERR_SOCKOPT;
    42fc:	8e ef       	ldi	r24, 0xFE	; 254
   }
   return SOCK_OK;
}
    42fe:	df 91       	pop	r29
    4300:	cf 91       	pop	r28
    4302:	1f 91       	pop	r17
    4304:	0f 91       	pop	r16
    4306:	ff 90       	pop	r15
    4308:	ef 90       	pop	r14
    430a:	08 95       	ret

0000430c <wizchip_cris_exit>:
 * @brief Default function to disable interrupt.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	  wizchip_cris_exit(void)          {};
void 	  wizchip_cris_exit(void)          {}
    430c:	08 95       	ret

0000430e <wizchip_cs_select>:
 * null function is called.
 */
//void 	wizchip_cs_select(void)            {};
void 	wizchip_cs_select(void)
{
    PORTB &= ~(1 << PB2); //pull SS low
    430e:	2a 98       	cbi	0x05, 2	; 5
    4310:	08 95       	ret

00004312 <wizchip_cs_deselect>:
 * null function is called.
 */
//void 	wizchip_cs_deselect(void)          {};
void 	wizchip_cs_deselect(void)
{
    PORTB |= (1 << PB2); //pull SS high 
    4312:	2a 9a       	sbi	0x05, 2	; 5
    4314:	08 95       	ret

00004316 <wizchip_bus_readdata>:
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
 //M20150601 : Rename the function for integrating with W5300
//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); }
iodata_t wizchip_bus_readdata(uint32_t AddrSel) { return * ((volatile iodata_t *)((ptrdiff_t) AddrSel)); }
    4316:	fb 01       	movw	r30, r22
    4318:	80 81       	ld	r24, Z
    431a:	08 95       	ret

0000431c <wizchip_bus_writedata>:
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//M20150601 : Rename the function for integrating with W5300
//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; }
void 	wizchip_bus_writedata(uint32_t AddrSel, iodata_t wb)  { *((volatile iodata_t*)((ptrdiff_t)AddrSel)) = wb; }
    431c:	fb 01       	movw	r30, r22
    431e:	40 83       	st	Z, r20
    4320:	08 95       	ret

00004322 <wizchip_spi_readbyte>:
 * null function is called.
 */
//uint8_t wizchip_spi_readbyte(void)        {return 0;};
uint8_t wizchip_spi_readbyte(void)        
{
    SPDR = 0x00; //get it to talk
    4322:	1e bc       	out	0x2e, r1	; 46
    while(bit_is_clear(SPSR, SPIF)) {} //spin until transfer complete
    4324:	0d b4       	in	r0, 0x2d	; 45
    4326:	07 fe       	sbrs	r0, 7
    4328:	fd cf       	rjmp	.-6      	; 0x4324 <wizchip_spi_readbyte+0x2>
    return SPDR;
    432a:	8e b5       	in	r24, 0x2e	; 46
}
    432c:	08 95       	ret

0000432e <wizchip_spi_writebyte>:
 * null function is called.
 */
//void 	wizchip_spi_writebyte(uint8_t wb) {};
void 	wizchip_spi_writebyte(uint8_t wb) 
{
    SPDR = wb;
    432e:	8e bd       	out	0x2e, r24	; 46
    while(bit_is_clear(SPSR, SPIF)) {} //spin until transfer complete
    4330:	0d b4       	in	r0, 0x2d	; 45
    4332:	07 fe       	sbrs	r0, 7
    4334:	fd cf       	rjmp	.-6      	; 0x4330 <wizchip_spi_writebyte+0x2>
}
    4336:	08 95       	ret

00004338 <wizchip_spi_writeburst>:
 * @brief Default function to burst write in SPI interface.
 * @note This function help not to access wrong address. If you do not describe this function or register any functions,
 * null function is called.
 */
//void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {};
void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {}
    4338:	08 95       	ret

0000433a <wizchip_spi_readburst>:
    433a:	08 95       	ret

0000433c <wizchip_cris_enter>:
    433c:	08 95       	ret

0000433e <reg_wizchip_cris_cbfunc>:
static uint8_t    _DNS_[4];      // DNS server ip address
static dhcp_mode  _DHCP_;        // DHCP mode

void reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void))
{
   if(!cris_en || !cris_ex)
    433e:	00 97       	sbiw	r24, 0x00	; 0
    4340:	19 f0       	breq	.+6      	; 0x4348 <reg_wizchip_cris_cbfunc+0xa>
    4342:	61 15       	cp	r22, r1
    4344:	71 05       	cpc	r23, r1
    4346:	69 f4       	brne	.+26     	; 0x4362 <reg_wizchip_cris_cbfunc+0x24>
   {
      WIZCHIP.CRIS._enter = wizchip_cris_enter;
    4348:	8e e9       	ldi	r24, 0x9E	; 158
    434a:	91 e2       	ldi	r25, 0x21	; 33
    434c:	90 93 0e 01 	sts	0x010E, r25	; 0x80010e <WIZCHIP+0xa>
    4350:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <WIZCHIP+0x9>
      WIZCHIP.CRIS._exit  = wizchip_cris_exit;
    4354:	86 e8       	ldi	r24, 0x86	; 134
    4356:	91 e2       	ldi	r25, 0x21	; 33
    4358:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <WIZCHIP+0xc>
    435c:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <WIZCHIP+0xb>
    4360:	08 95       	ret
   }
   else
   {
      WIZCHIP.CRIS._enter = cris_en;
    4362:	90 93 0e 01 	sts	0x010E, r25	; 0x80010e <WIZCHIP+0xa>
    4366:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <WIZCHIP+0x9>
      WIZCHIP.CRIS._exit  = cris_ex;
    436a:	70 93 10 01 	sts	0x0110, r23	; 0x800110 <WIZCHIP+0xc>
    436e:	60 93 0f 01 	sts	0x010F, r22	; 0x80010f <WIZCHIP+0xb>
    4372:	08 95       	ret

00004374 <reg_wizchip_cs_cbfunc>:
   }
}

void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void))
{
   if(!cs_sel || !cs_desel)
    4374:	00 97       	sbiw	r24, 0x00	; 0
    4376:	19 f0       	breq	.+6      	; 0x437e <reg_wizchip_cs_cbfunc+0xa>
    4378:	61 15       	cp	r22, r1
    437a:	71 05       	cpc	r23, r1
    437c:	69 f4       	brne	.+26     	; 0x4398 <reg_wizchip_cs_cbfunc+0x24>
   {
      WIZCHIP.CS._select   = wizchip_cs_select;
    437e:	87 e8       	ldi	r24, 0x87	; 135
    4380:	91 e2       	ldi	r25, 0x21	; 33
    4382:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <WIZCHIP+0xe>
    4386:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <WIZCHIP+0xd>
      WIZCHIP.CS._deselect = wizchip_cs_deselect;
    438a:	89 e8       	ldi	r24, 0x89	; 137
    438c:	91 e2       	ldi	r25, 0x21	; 33
    438e:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <WIZCHIP+0x10>
    4392:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <WIZCHIP+0xf>
    4396:	08 95       	ret
   }
   else
   {
      WIZCHIP.CS._select   = cs_sel;
    4398:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <WIZCHIP+0xe>
    439c:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <WIZCHIP+0xd>
      WIZCHIP.CS._deselect = cs_desel;
    43a0:	70 93 14 01 	sts	0x0114, r23	; 0x800114 <WIZCHIP+0x10>
    43a4:	60 93 13 01 	sts	0x0113, r22	; 0x800113 <WIZCHIP+0xf>
    43a8:	08 95       	ret

000043aa <reg_wizchip_bus_cbfunc>:

//M20150515 : For integrating with W5300
//void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
void reg_wizchip_bus_cbfunc(iodata_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, iodata_t wb))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_BUS_));
    43aa:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <WIZCHIP>
    43ae:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <WIZCHIP+0x1>
    43b2:	22 27       	eor	r18, r18
    43b4:	31 70       	andi	r19, 0x01	; 1
    43b6:	21 15       	cp	r18, r1
    43b8:	31 05       	cpc	r19, r1
    43ba:	e9 f3       	breq	.-6      	; 0x43b6 <reg_wizchip_bus_cbfunc+0xc>
   {
      WIZCHIP.IF.BUS._read_byte   = bus_rb;
      WIZCHIP.IF.BUS._write_byte  = bus_wb;
   }
   */
   if(!bus_rb || !bus_wb)
    43bc:	00 97       	sbiw	r24, 0x00	; 0
    43be:	19 f0       	breq	.+6      	; 0x43c6 <reg_wizchip_bus_cbfunc+0x1c>
    43c0:	61 15       	cp	r22, r1
    43c2:	71 05       	cpc	r23, r1
    43c4:	69 f4       	brne	.+26     	; 0x43e0 <reg_wizchip_bus_cbfunc+0x36>
   {
      WIZCHIP.IF.BUS._read_data   = wizchip_bus_readdata;
    43c6:	8b e8       	ldi	r24, 0x8B	; 139
    43c8:	91 e2       	ldi	r25, 0x21	; 33
    43ca:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    43ce:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.BUS._write_data  = wizchip_bus_writedata;
    43d2:	8e e8       	ldi	r24, 0x8E	; 142
    43d4:	91 e2       	ldi	r25, 0x21	; 33
    43d6:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <WIZCHIP+0x14>
    43da:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <WIZCHIP+0x13>
    43de:	08 95       	ret
   }
   else
   {
      WIZCHIP.IF.BUS._read_data   = bus_rb;
    43e0:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    43e4:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.BUS._write_data  = bus_wb;
    43e8:	70 93 18 01 	sts	0x0118, r23	; 0x800118 <WIZCHIP+0x14>
    43ec:	60 93 17 01 	sts	0x0117, r22	; 0x800117 <WIZCHIP+0x13>
    43f0:	08 95       	ret

000043f2 <reg_wizchip_spi_cbfunc>:
   }
}

void reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), void (*spi_wb)(uint8_t wb))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
    43f2:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <WIZCHIP>
    43f6:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <WIZCHIP+0x1>
    43fa:	22 27       	eor	r18, r18
    43fc:	32 70       	andi	r19, 0x02	; 2
    43fe:	21 15       	cp	r18, r1
    4400:	31 05       	cpc	r19, r1
    4402:	e9 f3       	breq	.-6      	; 0x43fe <reg_wizchip_spi_cbfunc+0xc>
   
   if(!spi_rb || !spi_wb)
    4404:	00 97       	sbiw	r24, 0x00	; 0
    4406:	19 f0       	breq	.+6      	; 0x440e <reg_wizchip_spi_cbfunc+0x1c>
    4408:	61 15       	cp	r22, r1
    440a:	71 05       	cpc	r23, r1
    440c:	69 f4       	brne	.+26     	; 0x4428 <reg_wizchip_spi_cbfunc+0x36>
   {
      WIZCHIP.IF.SPI._read_byte   = wizchip_spi_readbyte;
    440e:	81 e9       	ldi	r24, 0x91	; 145
    4410:	91 e2       	ldi	r25, 0x21	; 33
    4412:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    4416:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.SPI._write_byte  = wizchip_spi_writebyte;
    441a:	87 e9       	ldi	r24, 0x97	; 151
    441c:	91 e2       	ldi	r25, 0x21	; 33
    441e:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <WIZCHIP+0x14>
    4422:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <WIZCHIP+0x13>
    4426:	08 95       	ret
   }
   else
   {
      WIZCHIP.IF.SPI._read_byte   = spi_rb;
    4428:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <WIZCHIP+0x12>
    442c:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <WIZCHIP+0x11>
      WIZCHIP.IF.SPI._write_byte  = spi_wb;
    4430:	70 93 18 01 	sts	0x0118, r23	; 0x800118 <WIZCHIP+0x14>
    4434:	60 93 17 01 	sts	0x0117, r22	; 0x800117 <WIZCHIP+0x13>
    4438:	08 95       	ret

0000443a <reg_wizchip_spiburst_cbfunc>:
}

// 20140626 Eric Added for SPI burst operations
void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len))
{
   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
    443a:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <WIZCHIP>
    443e:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <WIZCHIP+0x1>
    4442:	22 27       	eor	r18, r18
    4444:	32 70       	andi	r19, 0x02	; 2
    4446:	21 15       	cp	r18, r1
    4448:	31 05       	cpc	r19, r1
    444a:	e9 f3       	breq	.-6      	; 0x4446 <reg_wizchip_spiburst_cbfunc+0xc>

   if(!spi_rb || !spi_wb)
    444c:	00 97       	sbiw	r24, 0x00	; 0
    444e:	19 f0       	breq	.+6      	; 0x4456 <reg_wizchip_spiburst_cbfunc+0x1c>
    4450:	61 15       	cp	r22, r1
    4452:	71 05       	cpc	r23, r1
    4454:	69 f4       	brne	.+26     	; 0x4470 <reg_wizchip_spiburst_cbfunc+0x36>
   {
      WIZCHIP.IF.SPI._read_burst   = wizchip_spi_readburst;
    4456:	8d e9       	ldi	r24, 0x9D	; 157
    4458:	91 e2       	ldi	r25, 0x21	; 33
    445a:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <WIZCHIP+0x16>
    445e:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <WIZCHIP+0x15>
      WIZCHIP.IF.SPI._write_burst  = wizchip_spi_writeburst;
    4462:	8c e9       	ldi	r24, 0x9C	; 156
    4464:	91 e2       	ldi	r25, 0x21	; 33
    4466:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <WIZCHIP+0x18>
    446a:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <WIZCHIP+0x17>
    446e:	08 95       	ret
   }
   else
   {
      WIZCHIP.IF.SPI._read_burst   = spi_rb;
    4470:	90 93 1a 01 	sts	0x011A, r25	; 0x80011a <WIZCHIP+0x16>
    4474:	80 93 19 01 	sts	0x0119, r24	; 0x800119 <WIZCHIP+0x15>
      WIZCHIP.IF.SPI._write_burst  = spi_wb;
    4478:	70 93 1c 01 	sts	0x011C, r23	; 0x80011c <WIZCHIP+0x18>
    447c:	60 93 1b 01 	sts	0x011B, r22	; 0x80011b <WIZCHIP+0x17>
    4480:	08 95       	ret

00004482 <wizchip_sw_reset>:
   }
   return 0;
}

void wizchip_sw_reset(void)
{
    4482:	cf 93       	push	r28
    4484:	df 93       	push	r29
    4486:	cd b7       	in	r28, 0x3d	; 61
    4488:	de b7       	in	r29, 0x3e	; 62
    448a:	62 97       	sbiw	r28, 0x12	; 18
    448c:	0f b6       	in	r0, 0x3f	; 63
    448e:	f8 94       	cli
    4490:	de bf       	out	0x3e, r29	; 62
    4492:	0f be       	out	0x3f, r0	; 63
    4494:	cd bf       	out	0x3d, r28	; 61
#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
   uint16_t mr = (uint16_t)getMR();
   setMR(mr | MR_IND);
#endif
//
   getSHAR(mac);
    4496:	26 e0       	ldi	r18, 0x06	; 6
    4498:	30 e0       	ldi	r19, 0x00	; 0
    449a:	ae 01       	movw	r20, r28
    449c:	4f 5f       	subi	r20, 0xFF	; 255
    449e:	5f 4f       	sbci	r21, 0xFF	; 255
    44a0:	60 e0       	ldi	r22, 0x00	; 0
    44a2:	79 e0       	ldi	r23, 0x09	; 9
    44a4:	80 e0       	ldi	r24, 0x00	; 0
    44a6:	90 e0       	ldi	r25, 0x00	; 0
    44a8:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   getGAR(gw);  getSUBR(sn);  getSIPR(sip);
    44ac:	24 e0       	ldi	r18, 0x04	; 4
    44ae:	30 e0       	ldi	r19, 0x00	; 0
    44b0:	ae 01       	movw	r20, r28
    44b2:	41 5f       	subi	r20, 0xF1	; 241
    44b4:	5f 4f       	sbci	r21, 0xFF	; 255
    44b6:	60 e0       	ldi	r22, 0x00	; 0
    44b8:	71 e0       	ldi	r23, 0x01	; 1
    44ba:	80 e0       	ldi	r24, 0x00	; 0
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
    44c2:	24 e0       	ldi	r18, 0x04	; 4
    44c4:	30 e0       	ldi	r19, 0x00	; 0
    44c6:	ae 01       	movw	r20, r28
    44c8:	45 5f       	subi	r20, 0xF5	; 245
    44ca:	5f 4f       	sbci	r21, 0xFF	; 255
    44cc:	60 e0       	ldi	r22, 0x00	; 0
    44ce:	75 e0       	ldi	r23, 0x05	; 5
    44d0:	80 e0       	ldi	r24, 0x00	; 0
    44d2:	90 e0       	ldi	r25, 0x00	; 0
    44d4:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
    44d8:	24 e0       	ldi	r18, 0x04	; 4
    44da:	30 e0       	ldi	r19, 0x00	; 0
    44dc:	ae 01       	movw	r20, r28
    44de:	49 5f       	subi	r20, 0xF9	; 249
    44e0:	5f 4f       	sbci	r21, 0xFF	; 255
    44e2:	60 e0       	ldi	r22, 0x00	; 0
    44e4:	7f e0       	ldi	r23, 0x0F	; 15
    44e6:	80 e0       	ldi	r24, 0x00	; 0
    44e8:	90 e0       	ldi	r25, 0x00	; 0
    44ea:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   setMR(MR_RST);
    44ee:	40 e8       	ldi	r20, 0x80	; 128
    44f0:	60 e0       	ldi	r22, 0x00	; 0
    44f2:	70 e0       	ldi	r23, 0x00	; 0
    44f4:	cb 01       	movw	r24, r22
    44f6:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   getMR(); // for delay
    44fa:	60 e0       	ldi	r22, 0x00	; 0
    44fc:	70 e0       	ldi	r23, 0x00	; 0
    44fe:	cb 01       	movw	r24, r22
    4500:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
//A2015051 : For indirect bus mode 
#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
   setMR(mr | MR_IND);
#endif
//
   setSHAR(mac);
    4504:	26 e0       	ldi	r18, 0x06	; 6
    4506:	30 e0       	ldi	r19, 0x00	; 0
    4508:	ae 01       	movw	r20, r28
    450a:	4f 5f       	subi	r20, 0xFF	; 255
    450c:	5f 4f       	sbci	r21, 0xFF	; 255
    450e:	60 e0       	ldi	r22, 0x00	; 0
    4510:	79 e0       	ldi	r23, 0x09	; 9
    4512:	80 e0       	ldi	r24, 0x00	; 0
    4514:	90 e0       	ldi	r25, 0x00	; 0
    4516:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setGAR(gw);
    451a:	24 e0       	ldi	r18, 0x04	; 4
    451c:	30 e0       	ldi	r19, 0x00	; 0
    451e:	ae 01       	movw	r20, r28
    4520:	41 5f       	subi	r20, 0xF1	; 241
    4522:	5f 4f       	sbci	r21, 0xFF	; 255
    4524:	60 e0       	ldi	r22, 0x00	; 0
    4526:	71 e0       	ldi	r23, 0x01	; 1
    4528:	80 e0       	ldi	r24, 0x00	; 0
    452a:	90 e0       	ldi	r25, 0x00	; 0
    452c:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setSUBR(sn);
    4530:	24 e0       	ldi	r18, 0x04	; 4
    4532:	30 e0       	ldi	r19, 0x00	; 0
    4534:	ae 01       	movw	r20, r28
    4536:	45 5f       	subi	r20, 0xF5	; 245
    4538:	5f 4f       	sbci	r21, 0xFF	; 255
    453a:	60 e0       	ldi	r22, 0x00	; 0
    453c:	75 e0       	ldi	r23, 0x05	; 5
    453e:	80 e0       	ldi	r24, 0x00	; 0
    4540:	90 e0       	ldi	r25, 0x00	; 0
    4542:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setSIPR(sip);
    4546:	24 e0       	ldi	r18, 0x04	; 4
    4548:	30 e0       	ldi	r19, 0x00	; 0
    454a:	ae 01       	movw	r20, r28
    454c:	49 5f       	subi	r20, 0xF9	; 249
    454e:	5f 4f       	sbci	r21, 0xFF	; 255
    4550:	60 e0       	ldi	r22, 0x00	; 0
    4552:	7f e0       	ldi	r23, 0x0F	; 15
    4554:	80 e0       	ldi	r24, 0x00	; 0
    4556:	90 e0       	ldi	r25, 0x00	; 0
    4558:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
}
    455c:	62 96       	adiw	r28, 0x12	; 18
    455e:	0f b6       	in	r0, 0x3f	; 63
    4560:	f8 94       	cli
    4562:	de bf       	out	0x3e, r29	; 62
    4564:	0f be       	out	0x3f, r0	; 63
    4566:	cd bf       	out	0x3d, r28	; 61
    4568:	df 91       	pop	r29
    456a:	cf 91       	pop	r28
    456c:	08 95       	ret

0000456e <wizchip_init>:

int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
{
    456e:	ef 92       	push	r14
    4570:	ff 92       	push	r15
    4572:	0f 93       	push	r16
    4574:	1f 93       	push	r17
    4576:	cf 93       	push	r28
    4578:	df 93       	push	r29
    457a:	ec 01       	movw	r28, r24
    457c:	7b 01       	movw	r14, r22
   int8_t i;
#if _WIZCHIP_ < W5200
   int8_t j;
#endif
   int8_t tmp = 0;
   wizchip_sw_reset();
    457e:	0e 94 41 22 	call	0x4482	; 0x4482 <wizchip_sw_reset>
   if(txsize)
    4582:	20 97       	sbiw	r28, 0x00	; 0
    4584:	21 f4       	brne	.+8      	; 0x458e <wizchip_init+0x20>
		}

	#endif
   }

   if(rxsize)
    4586:	e1 14       	cp	r14, r1
    4588:	f1 04       	cpc	r15, r1
    458a:	29 f5       	brne	.+74     	; 0x45d6 <wizchip_init+0x68>
    458c:	46 c0       	rjmp	.+140    	; 0x461a <wizchip_init+0xac>
    458e:	9e 01       	movw	r18, r28
    4590:	28 5f       	subi	r18, 0xF8	; 248
    4592:	3f 4f       	sbci	r19, 0xFF	; 255
#if _WIZCHIP_ < W5200
   int8_t j;
#endif
   int8_t tmp = 0;
   wizchip_sw_reset();
   if(txsize)
    4594:	fe 01       	movw	r30, r28
    4596:	80 e0       	ldi	r24, 0x00	; 0
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
		{
			tmp += txsize[i];
    4598:	91 91       	ld	r25, Z+
    459a:	89 0f       	add	r24, r25

		#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100 and w5100s
			if(tmp > 8) return -1;
		#else
			if(tmp > 16) return -1;
    459c:	81 31       	cpi	r24, 0x11	; 17
    459e:	14 f0       	brlt	.+4      	; 0x45a4 <wizchip_init+0x36>
    45a0:	8f ef       	ldi	r24, 0xFF	; 255
    45a2:	3c c0       	rjmp	.+120    	; 0x461c <wizchip_init+0xae>
			tmp += txsize[i];
			if(tmp > 128) return -1;
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    45a4:	e2 17       	cp	r30, r18
    45a6:	f3 07       	cpc	r31, r19
    45a8:	b9 f7       	brne	.-18     	; 0x4598 <wizchip_init+0x2a>
    45aa:	01 e0       	ldi	r16, 0x01	; 1
    45ac:	10 e0       	ldi	r17, 0x00	; 0
		#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100
			j = 0;
			while((txsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
			setSn_TXBUF_SIZE(i, j);
		#else
			setSn_TXBUF_SIZE(i, txsize[i]);
    45ae:	49 91       	ld	r20, Y+
    45b0:	b8 01       	movw	r22, r16
    45b2:	93 e0       	ldi	r25, 0x03	; 3
    45b4:	66 0f       	add	r22, r22
    45b6:	77 1f       	adc	r23, r23
    45b8:	9a 95       	dec	r25
    45ba:	e1 f7       	brne	.-8      	; 0x45b4 <wizchip_init+0x46>
    45bc:	71 5e       	subi	r23, 0xE1	; 225
    45be:	07 2e       	mov	r0, r23
    45c0:	00 0c       	add	r0, r0
    45c2:	88 0b       	sbc	r24, r24
    45c4:	99 0b       	sbc	r25, r25
    45c6:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    45ca:	0c 5f       	subi	r16, 0xFC	; 252
    45cc:	1f 4f       	sbci	r17, 0xFF	; 255
			if(tmp > 8) return -1;
		#else
			if(tmp > 16) return -1;
		#endif
		}
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    45ce:	01 32       	cpi	r16, 0x21	; 33
    45d0:	11 05       	cpc	r17, r1
    45d2:	69 f7       	brne	.-38     	; 0x45ae <wizchip_init+0x40>
    45d4:	d8 cf       	rjmp	.-80     	; 0x4586 <wizchip_init+0x18>
    45d6:	e7 01       	movw	r28, r14
    45d8:	97 01       	movw	r18, r14
    45da:	28 5f       	subi	r18, 0xF8	; 248
    45dc:	3f 4f       	sbci	r19, 0xFF	; 255
		}

	#endif
   }

   if(rxsize)
    45de:	f7 01       	movw	r30, r14
    45e0:	80 e0       	ldi	r24, 0x00	; 0
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
		{
			tmp += rxsize[i];
    45e2:	91 91       	ld	r25, Z+
    45e4:	89 0f       	add	r24, r25
		#if _WIZCHIP_ < W5200	//2016.10.28 peter add condition for w5100 and w5100s
			if(tmp > 8) return -1;
		#else
			if(tmp > 16) return -1;
    45e6:	81 31       	cpi	r24, 0x11	; 17
    45e8:	dc f6       	brge	.-74     	; 0x45a0 <wizchip_init+0x32>
			tmp += rxsize[i];
			if(tmp > 128) return -1;
		}
		if(tmp % 8) return -1;
   #else
		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    45ea:	e2 17       	cp	r30, r18
    45ec:	f3 07       	cpc	r31, r19
    45ee:	c9 f7       	brne	.-14     	; 0x45e2 <wizchip_init+0x74>
    45f0:	01 e0       	ldi	r16, 0x01	; 1
    45f2:	10 e0       	ldi	r17, 0x00	; 0
		#if _WIZCHIP_ < W5200	// add condition for w5100
			j = 0;
			while((rxsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
			setSn_RXBUF_SIZE(i, j);
		#else
			setSn_RXBUF_SIZE(i, rxsize[i]);
    45f4:	49 91       	ld	r20, Y+
    45f6:	b8 01       	movw	r22, r16
    45f8:	83 e0       	ldi	r24, 0x03	; 3
    45fa:	66 0f       	add	r22, r22
    45fc:	77 1f       	adc	r23, r23
    45fe:	8a 95       	dec	r24
    4600:	e1 f7       	brne	.-8      	; 0x45fa <wizchip_init+0x8c>
    4602:	72 5e       	subi	r23, 0xE2	; 226
    4604:	07 2e       	mov	r0, r23
    4606:	00 0c       	add	r0, r0
    4608:	88 0b       	sbc	r24, r24
    460a:	99 0b       	sbc	r25, r25
    460c:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    4610:	0c 5f       	subi	r16, 0xFC	; 252
    4612:	1f 4f       	sbci	r17, 0xFF	; 255
		#else
			if(tmp > 16) return -1;
		#endif
		}

		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
    4614:	01 32       	cpi	r16, 0x21	; 33
    4616:	11 05       	cpc	r17, r1
    4618:	69 f7       	brne	.-38     	; 0x45f4 <wizchip_init+0x86>
			setSn_RXBUF_SIZE(i, rxsize[i]);
		#endif
		}
	#endif
   }
   return 0;
    461a:	80 e0       	ldi	r24, 0x00	; 0
}
    461c:	df 91       	pop	r29
    461e:	cf 91       	pop	r28
    4620:	1f 91       	pop	r17
    4622:	0f 91       	pop	r16
    4624:	ff 90       	pop	r15
    4626:	ef 90       	pop	r14
    4628:	08 95       	ret

0000462a <wizchip_clrinterrupt>:

void wizchip_clrinterrupt(intr_kind intr)
{
    462a:	cf 93       	push	r28
    462c:	c9 2f       	mov	r28, r25
   setIR(ir);
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
#else
   setIR(ir);
    462e:	48 2f       	mov	r20, r24
    4630:	40 7f       	andi	r20, 0xF0	; 240
    4632:	60 e0       	ldi	r22, 0x00	; 0
    4634:	75 e1       	ldi	r23, 0x15	; 21
    4636:	80 e0       	ldi	r24, 0x00	; 0
    4638:	90 e0       	ldi	r25, 0x00	; 0
    463a:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   setSIR(sir);
    463e:	4c 2f       	mov	r20, r28
    4640:	60 e0       	ldi	r22, 0x00	; 0
    4642:	77 e1       	ldi	r23, 0x17	; 23
    4644:	80 e0       	ldi	r24, 0x00	; 0
    4646:	90 e0       	ldi	r25, 0x00	; 0
#endif   
}
    4648:	cf 91       	pop	r28
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
#else
   setIR(ir);
   setSIR(sir);
    464a:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>

0000464e <wizchip_getinterrupt>:
#endif   
}

intr_kind wizchip_getinterrupt(void)
{
    464e:	cf 93       	push	r28
#elif _WIZCHIP_  == W5300
   ret = getIR();
   ir = (uint8_t)(ret >> 8);
   sir = (uint8_t)ret;
#else
   ir  = getIR();
    4650:	60 e0       	ldi	r22, 0x00	; 0
    4652:	75 e1       	ldi	r23, 0x15	; 21
    4654:	80 e0       	ldi	r24, 0x00	; 0
    4656:	90 e0       	ldi	r25, 0x00	; 0
    4658:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    465c:	c8 2f       	mov	r28, r24
   sir = getSIR();
    465e:	60 e0       	ldi	r22, 0x00	; 0
    4660:	77 e1       	ldi	r23, 0x17	; 23
    4662:	80 e0       	ldi	r24, 0x00	; 0
    4664:	90 e0       	ldi	r25, 0x00	; 0
    4666:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
#endif
#if _WIZCHIP_ == W5200
   ir &= ~(1 << 6);
#endif
  ret = sir;
  ret = (ret << 8) + ir;
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	98 2f       	mov	r25, r24
    466e:	88 27       	eor	r24, r24
  return (intr_kind)ret;
    4670:	c0 7f       	andi	r28, 0xF0	; 240
}
    4672:	8c 0f       	add	r24, r28
    4674:	91 1d       	adc	r25, r1
    4676:	cf 91       	pop	r28
    4678:	08 95       	ret

0000467a <wizchip_setinterruptmask>:

void wizchip_setinterruptmask(intr_kind intr)
{
    467a:	cf 93       	push	r28
    467c:	c9 2f       	mov	r28, r25
   setIMR(imr);
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
#else
   setIMR(imr);
    467e:	48 2f       	mov	r20, r24
    4680:	60 e0       	ldi	r22, 0x00	; 0
    4682:	76 e1       	ldi	r23, 0x16	; 22
    4684:	80 e0       	ldi	r24, 0x00	; 0
    4686:	90 e0       	ldi	r25, 0x00	; 0
    4688:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   setSIMR(simr);
    468c:	4c 2f       	mov	r20, r28
    468e:	60 e0       	ldi	r22, 0x00	; 0
    4690:	78 e1       	ldi	r23, 0x18	; 24
    4692:	80 e0       	ldi	r24, 0x00	; 0
    4694:	90 e0       	ldi	r25, 0x00	; 0
#endif   
}
    4696:	cf 91       	pop	r28
//A20150601 : For integrating with W5300
#elif _WIZCHIP_ == W5300
   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
#else
   setIMR(imr);
   setSIMR(simr);
    4698:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>

0000469c <wizchip_getinterruptmask>:
#endif   
}

intr_kind wizchip_getinterruptmask(void)
{
    469c:	cf 93       	push	r28
#elif _WIZCHIP_ == W5300
   ret = getIMR();
   imr = (uint8_t)(ret >> 8);
   simr = (uint8_t)ret;
#else
   imr  = getIMR();
    469e:	60 e0       	ldi	r22, 0x00	; 0
    46a0:	76 e1       	ldi	r23, 0x16	; 22
    46a2:	80 e0       	ldi	r24, 0x00	; 0
    46a4:	90 e0       	ldi	r25, 0x00	; 0
    46a6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    46aa:	c8 2f       	mov	r28, r24
   simr = getSIMR();
    46ac:	60 e0       	ldi	r22, 0x00	; 0
    46ae:	78 e1       	ldi	r23, 0x18	; 24
    46b0:	80 e0       	ldi	r24, 0x00	; 0
    46b2:	90 e0       	ldi	r25, 0x00	; 0
    46b4:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
#endif
#if _WIZCHIP_ == W5200
   imr &= ~(1 << 6);  // IK_DEST_UNREACH
#endif
  ret = simr;
  ret = (ret << 8) + imr;
    46b8:	90 e0       	ldi	r25, 0x00	; 0
    46ba:	98 2f       	mov	r25, r24
    46bc:	88 27       	eor	r24, r24
  return (intr_kind)ret;
}
    46be:	8c 0f       	add	r24, r28
    46c0:	91 1d       	adc	r25, r1
    46c2:	cf 91       	pop	r28
    46c4:	08 95       	ret

000046c6 <wizphy_getphylink>:
	   tmp = PHY_LINK_ON;
#elif   _WIZCHIP_ == W5200
   if(getPHYSTATUS() & PHYSTATUS_LINK)
      tmp = PHY_LINK_ON;
#elif _WIZCHIP_ == W5500
   if(getPHYCFGR() & PHYCFGR_LNK_ON)
    46c6:	60 e0       	ldi	r22, 0x00	; 0
    46c8:	7e e2       	ldi	r23, 0x2E	; 46
    46ca:	80 e0       	ldi	r24, 0x00	; 0
    46cc:	90 e0       	ldi	r25, 0x00	; 0
    46ce:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>

#else
   tmp = -1;
#endif
   return tmp;
}
    46d2:	81 70       	andi	r24, 0x01	; 1
    46d4:	08 95       	ret

000046d6 <wizphy_getphypmode>:
      if(getPHYSTATUS() & PHYSTATUS_POWERDOWN)
         tmp = PHY_POWER_DOWN;
      else          
         tmp = PHY_POWER_NORM;
   #elif _WIZCHIP_ == 5500
      if((getPHYCFGR() & PHYCFGR_OPMDC_ALLA) == PHYCFGR_OPMDC_PDOWN)
    46d6:	60 e0       	ldi	r22, 0x00	; 0
    46d8:	7e e2       	ldi	r23, 0x2E	; 46
    46da:	80 e0       	ldi	r24, 0x00	; 0
    46dc:	90 e0       	ldi	r25, 0x00	; 0
    46de:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
      else 
         tmp = PHY_POWER_NORM;
   #else
      tmp = -1;
   #endif
   return tmp;
    46e2:	98 2f       	mov	r25, r24
    46e4:	98 73       	andi	r25, 0x38	; 56
    46e6:	81 e0       	ldi	r24, 0x01	; 1
    46e8:	90 33       	cpi	r25, 0x30	; 48
    46ea:	09 f0       	breq	.+2      	; 0x46ee <wizphy_getphypmode+0x18>
    46ec:	80 e0       	ldi	r24, 0x00	; 0
}
    46ee:	08 95       	ret

000046f0 <wizphy_reset>:

#endif
#if _WIZCHIP_ == W5500
void wizphy_reset(void)
{
   uint8_t tmp = getPHYCFGR();
    46f0:	60 e0       	ldi	r22, 0x00	; 0
    46f2:	7e e2       	ldi	r23, 0x2E	; 46
    46f4:	80 e0       	ldi	r24, 0x00	; 0
    46f6:	90 e0       	ldi	r25, 0x00	; 0
    46f8:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   tmp &= PHYCFGR_RST;
   setPHYCFGR(tmp);
    46fc:	48 2f       	mov	r20, r24
    46fe:	4f 77       	andi	r20, 0x7F	; 127
    4700:	60 e0       	ldi	r22, 0x00	; 0
    4702:	7e e2       	ldi	r23, 0x2E	; 46
    4704:	80 e0       	ldi	r24, 0x00	; 0
    4706:	90 e0       	ldi	r25, 0x00	; 0
    4708:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   tmp = getPHYCFGR();
    470c:	60 e0       	ldi	r22, 0x00	; 0
    470e:	7e e2       	ldi	r23, 0x2E	; 46
    4710:	80 e0       	ldi	r24, 0x00	; 0
    4712:	90 e0       	ldi	r25, 0x00	; 0
    4714:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   tmp |= ~PHYCFGR_RST;
   setPHYCFGR(tmp);
    4718:	48 2f       	mov	r20, r24
    471a:	40 68       	ori	r20, 0x80	; 128
    471c:	60 e0       	ldi	r22, 0x00	; 0
    471e:	7e e2       	ldi	r23, 0x2E	; 46
    4720:	80 e0       	ldi	r24, 0x00	; 0
    4722:	90 e0       	ldi	r25, 0x00	; 0
    4724:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>

00004728 <wizphy_setphyconf>:
}

void wizphy_setphyconf(wiz_PhyConf* phyconf)
{
    4728:	fc 01       	movw	r30, r24
   uint8_t tmp = 0;
   if(phyconf->by == PHY_CONFBY_SW)
    472a:	80 81       	ld	r24, Z
    472c:	81 30       	cpi	r24, 0x01	; 1
    472e:	11 f0       	breq	.+4      	; 0x4734 <wizphy_setphyconf+0xc>
      tmp |= PHYCFGR_OPMD;
   else
      tmp &= ~PHYCFGR_OPMD;
    4730:	40 e0       	ldi	r20, 0x00	; 0
    4732:	01 c0       	rjmp	.+2      	; 0x4736 <wizphy_setphyconf+0xe>

void wizphy_setphyconf(wiz_PhyConf* phyconf)
{
   uint8_t tmp = 0;
   if(phyconf->by == PHY_CONFBY_SW)
      tmp |= PHYCFGR_OPMD;
    4734:	40 e4       	ldi	r20, 0x40	; 64
   else
      tmp &= ~PHYCFGR_OPMD;
   if(phyconf->mode == PHY_MODE_AUTONEGO)
    4736:	81 81       	ldd	r24, Z+1	; 0x01
    4738:	81 30       	cpi	r24, 0x01	; 1
    473a:	11 f4       	brne	.+4      	; 0x4740 <wizphy_setphyconf+0x18>
      tmp |= PHYCFGR_OPMDC_ALLA;
    473c:	48 63       	ori	r20, 0x38	; 56
    473e:	0d c0       	rjmp	.+26     	; 0x475a <wizphy_setphyconf+0x32>
   else
   {
      if(phyconf->duplex == PHY_DUPLEX_FULL)
    4740:	93 81       	ldd	r25, Z+3	; 0x03
    4742:	82 81       	ldd	r24, Z+2	; 0x02
    4744:	91 30       	cpi	r25, 0x01	; 1
    4746:	31 f4       	brne	.+12     	; 0x4754 <wizphy_setphyconf+0x2c>
      {
         if(phyconf->speed == PHY_SPEED_100)
    4748:	81 30       	cpi	r24, 0x01	; 1
    474a:	11 f4       	brne	.+4      	; 0x4750 <wizphy_setphyconf+0x28>
            tmp |= PHYCFGR_OPMDC_100F;
    474c:	48 61       	ori	r20, 0x18	; 24
    474e:	05 c0       	rjmp	.+10     	; 0x475a <wizphy_setphyconf+0x32>
         else
            tmp |= PHYCFGR_OPMDC_10F;
    4750:	48 60       	ori	r20, 0x08	; 8
    4752:	03 c0       	rjmp	.+6      	; 0x475a <wizphy_setphyconf+0x32>
      }   
      else
      {
         if(phyconf->speed == PHY_SPEED_100)
    4754:	81 30       	cpi	r24, 0x01	; 1
    4756:	09 f4       	brne	.+2      	; 0x475a <wizphy_setphyconf+0x32>
            tmp |= PHYCFGR_OPMDC_100H;
    4758:	40 61       	ori	r20, 0x10	; 16
         else
            tmp |= PHYCFGR_OPMDC_10H;
      }
   }
   setPHYCFGR(tmp);
    475a:	60 e0       	ldi	r22, 0x00	; 0
    475c:	7e e2       	ldi	r23, 0x2E	; 46
    475e:	80 e0       	ldi	r24, 0x00	; 0
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   wizphy_reset();
    4766:	0c 94 78 23 	jmp	0x46f0	; 0x46f0 <wizphy_reset>

0000476a <wizphy_getphyconf>:
}

void wizphy_getphyconf(wiz_PhyConf* phyconf)
{
    476a:	cf 93       	push	r28
    476c:	df 93       	push	r29
    476e:	ec 01       	movw	r28, r24
   uint8_t tmp = 0;
   tmp = getPHYCFGR();
    4770:	60 e0       	ldi	r22, 0x00	; 0
    4772:	7e e2       	ldi	r23, 0x2E	; 46
    4774:	80 e0       	ldi	r24, 0x00	; 0
    4776:	90 e0       	ldi	r25, 0x00	; 0
    4778:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   phyconf->by   = (tmp & PHYCFGR_OPMD) ? PHY_CONFBY_SW : PHY_CONFBY_HW;
    477c:	86 fb       	bst	r24, 6
    477e:	99 27       	eor	r25, r25
    4780:	90 f9       	bld	r25, 0
    4782:	98 83       	st	Y, r25
    4784:	88 73       	andi	r24, 0x38	; 56
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    4786:	80 32       	cpi	r24, 0x20	; 32
    4788:	11 f0       	breq	.+4      	; 0x478e <wizphy_getphyconf+0x24>
    478a:	88 33       	cpi	r24, 0x38	; 56
    478c:	19 f4       	brne	.+6      	; 0x4794 <wizphy_getphyconf+0x2a>
   {
      case PHYCFGR_OPMDC_ALLA:
      case PHYCFGR_OPMDC_100FA: 
         phyconf->mode = PHY_MODE_AUTONEGO;
    478e:	91 e0       	ldi	r25, 0x01	; 1
    4790:	99 83       	std	Y+1, r25	; 0x01
         break;
    4792:	01 c0       	rjmp	.+2      	; 0x4796 <wizphy_getphyconf+0x2c>
      default:
         phyconf->mode = PHY_MODE_MANUAL;
    4794:	19 82       	std	Y+1, r1	; 0x01
         break;
   }
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    4796:	88 31       	cpi	r24, 0x18	; 24
    4798:	21 f0       	breq	.+8      	; 0x47a2 <wizphy_getphyconf+0x38>
    479a:	80 32       	cpi	r24, 0x20	; 32
    479c:	11 f0       	breq	.+4      	; 0x47a2 <wizphy_getphyconf+0x38>
    479e:	80 31       	cpi	r24, 0x10	; 16
    47a0:	19 f4       	brne	.+6      	; 0x47a8 <wizphy_getphyconf+0x3e>
   {
      case PHYCFGR_OPMDC_100FA:
      case PHYCFGR_OPMDC_100F:
      case PHYCFGR_OPMDC_100H:
         phyconf->speed = PHY_SPEED_100;
    47a2:	91 e0       	ldi	r25, 0x01	; 1
    47a4:	9a 83       	std	Y+2, r25	; 0x02
         break;
    47a6:	01 c0       	rjmp	.+2      	; 0x47aa <wizphy_getphyconf+0x40>
      default:
         phyconf->speed = PHY_SPEED_10;
    47a8:	1a 82       	std	Y+2, r1	; 0x02
         break;
   }
   switch(tmp & PHYCFGR_OPMDC_ALLA)
    47aa:	88 31       	cpi	r24, 0x18	; 24
    47ac:	21 f0       	breq	.+8      	; 0x47b6 <wizphy_getphyconf+0x4c>
    47ae:	80 32       	cpi	r24, 0x20	; 32
    47b0:	11 f0       	breq	.+4      	; 0x47b6 <wizphy_getphyconf+0x4c>
    47b2:	88 30       	cpi	r24, 0x08	; 8
    47b4:	19 f4       	brne	.+6      	; 0x47bc <wizphy_getphyconf+0x52>
   {
      case PHYCFGR_OPMDC_100FA:
      case PHYCFGR_OPMDC_100F:
      case PHYCFGR_OPMDC_10F:
         phyconf->duplex = PHY_DUPLEX_FULL;
    47b6:	81 e0       	ldi	r24, 0x01	; 1
    47b8:	8b 83       	std	Y+3, r24	; 0x03
         break;
    47ba:	01 c0       	rjmp	.+2      	; 0x47be <wizphy_getphyconf+0x54>
      default:
         phyconf->duplex = PHY_DUPLEX_HALF;
    47bc:	1b 82       	std	Y+3, r1	; 0x03
         break;
   }
}
    47be:	df 91       	pop	r29
    47c0:	cf 91       	pop	r28
    47c2:	08 95       	ret

000047c4 <wizphy_getphystat>:

void wizphy_getphystat(wiz_PhyConf* phyconf)
{
    47c4:	cf 93       	push	r28
    47c6:	df 93       	push	r29
    47c8:	ec 01       	movw	r28, r24
   uint8_t tmp = getPHYCFGR();
    47ca:	60 e0       	ldi	r22, 0x00	; 0
    47cc:	7e e2       	ldi	r23, 0x2E	; 46
    47ce:	80 e0       	ldi	r24, 0x00	; 0
    47d0:	90 e0       	ldi	r25, 0x00	; 0
    47d2:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   phyconf->duplex = (tmp & PHYCFGR_DPX_FULL) ? PHY_DUPLEX_FULL : PHY_DUPLEX_HALF;
    47d6:	82 fb       	bst	r24, 2
    47d8:	99 27       	eor	r25, r25
    47da:	90 f9       	bld	r25, 0
    47dc:	9b 83       	std	Y+3, r25	; 0x03
   phyconf->speed  = (tmp & PHYCFGR_SPD_100) ? PHY_SPEED_100 : PHY_SPEED_10;
    47de:	86 95       	lsr	r24
    47e0:	81 70       	andi	r24, 0x01	; 1
    47e2:	8a 83       	std	Y+2, r24	; 0x02
}
    47e4:	df 91       	pop	r29
    47e6:	cf 91       	pop	r28
    47e8:	08 95       	ret

000047ea <wizphy_setphypmode>:

int8_t wizphy_setphypmode(uint8_t pmode)
{
    47ea:	cf 93       	push	r28
    47ec:	c8 2f       	mov	r28, r24
   uint8_t tmp = 0;
   tmp = getPHYCFGR();
    47ee:	60 e0       	ldi	r22, 0x00	; 0
    47f0:	7e e2       	ldi	r23, 0x2E	; 46
    47f2:	80 e0       	ldi	r24, 0x00	; 0
    47f4:	90 e0       	ldi	r25, 0x00	; 0
    47f6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   if((tmp & PHYCFGR_OPMD)== 0) return -1;
    47fa:	86 ff       	sbrs	r24, 6
    47fc:	1c c0       	rjmp	.+56     	; 0x4836 <wizphy_setphypmode+0x4c>
   tmp &= ~PHYCFGR_OPMDC_ALLA;         
    47fe:	48 2f       	mov	r20, r24
    4800:	47 7c       	andi	r20, 0xC7	; 199
   if( pmode == PHY_POWER_DOWN)
    4802:	c1 30       	cpi	r28, 0x01	; 1
    4804:	11 f4       	brne	.+4      	; 0x480a <wizphy_setphypmode+0x20>
      tmp |= PHYCFGR_OPMDC_PDOWN;
    4806:	40 63       	ori	r20, 0x30	; 48
    4808:	01 c0       	rjmp	.+2      	; 0x480c <wizphy_setphypmode+0x22>
   else
      tmp |= PHYCFGR_OPMDC_ALLA;
    480a:	48 63       	ori	r20, 0x38	; 56
   setPHYCFGR(tmp);
    480c:	60 e0       	ldi	r22, 0x00	; 0
    480e:	7e e2       	ldi	r23, 0x2E	; 46
    4810:	80 e0       	ldi	r24, 0x00	; 0
    4812:	90 e0       	ldi	r25, 0x00	; 0
    4814:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   wizphy_reset();
    4818:	0e 94 78 23 	call	0x46f0	; 0x46f0 <wizphy_reset>
   tmp = getPHYCFGR();
    481c:	60 e0       	ldi	r22, 0x00	; 0
    481e:	7e e2       	ldi	r23, 0x2E	; 46
    4820:	80 e0       	ldi	r24, 0x00	; 0
    4822:	90 e0       	ldi	r25, 0x00	; 0
    4824:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   if( pmode == PHY_POWER_DOWN)
    4828:	c1 30       	cpi	r28, 0x01	; 1
    482a:	11 f4       	brne	.+4      	; 0x4830 <wizphy_setphypmode+0x46>
   {
      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
    482c:	80 73       	andi	r24, 0x30	; 48
    482e:	01 c0       	rjmp	.+2      	; 0x4832 <wizphy_setphypmode+0x48>
   }
   else
   {
      if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
    4830:	88 73       	andi	r24, 0x38	; 56
    4832:	81 11       	cpse	r24, r1
    4834:	02 c0       	rjmp	.+4      	; 0x483a <wizphy_setphypmode+0x50>
   }
   return -1;
    4836:	8f ef       	ldi	r24, 0xFF	; 255
    4838:	01 c0       	rjmp	.+2      	; 0x483c <wizphy_setphypmode+0x52>
   setPHYCFGR(tmp);
   wizphy_reset();
   tmp = getPHYCFGR();
   if( pmode == PHY_POWER_DOWN)
   {
      if(tmp & PHYCFGR_OPMDC_PDOWN) return 0;
    483a:	80 e0       	ldi	r24, 0x00	; 0
   else
   {
      if(tmp & PHYCFGR_OPMDC_ALLA) return 0;
   }
   return -1;
}
    483c:	cf 91       	pop	r28
    483e:	08 95       	ret

00004840 <ctlwizchip>:
      WIZCHIP.IF.SPI._write_burst  = spi_wb;
   }
}

int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
{
    4840:	1f 93       	push	r17
    4842:	cf 93       	push	r28
    4844:	df 93       	push	r29
#if	_WIZCHIP_ == W5100S || _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
   uint8_t tmp = 0;
#endif
   uint8_t* ptmp[2] = {0,0};
   switch(cwtype)
    4846:	90 e0       	ldi	r25, 0x00	; 0
    4848:	80 31       	cpi	r24, 0x10	; 16
    484a:	91 05       	cpc	r25, r1
    484c:	08 f0       	brcs	.+2      	; 0x4850 <ctlwizchip+0x10>
    484e:	79 c0       	rjmp	.+242    	; 0x4942 <ctlwizchip+0x102>
    4850:	eb 01       	movw	r28, r22
    4852:	fc 01       	movw	r30, r24
    4854:	e0 5b       	subi	r30, 0xB0	; 176
    4856:	ff 4f       	sbci	r31, 0xFF	; 255
    4858:	0c 94 24 2a 	jmp	0x5448	; 0x5448 <__tablejump2__>
   {
      case CW_RESET_WIZCHIP:
         wizchip_sw_reset();
    485c:	0e 94 41 22 	call	0x4482	; 0x4482 <wizchip_sw_reset>
    4860:	19 c0       	rjmp	.+50     	; 0x4894 <ctlwizchip+0x54>
         break;
      case CW_INIT_WIZCHIP:
         if(arg != 0) 
    4862:	20 97       	sbiw	r28, 0x00	; 0
    4864:	19 f0       	breq	.+6      	; 0x486c <ctlwizchip+0x2c>
         {
            ptmp[0] = (uint8_t*)arg;
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
    4866:	68 5f       	subi	r22, 0xF8	; 248
    4868:	7f 4f       	sbci	r23, 0xFF	; 255
    486a:	02 c0       	rjmp	.+4      	; 0x4870 <ctlwizchip+0x30>
int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
{
#if	_WIZCHIP_ == W5100S || _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
   uint8_t tmp = 0;
#endif
   uint8_t* ptmp[2] = {0,0};
    486c:	60 e0       	ldi	r22, 0x00	; 0
    486e:	70 e0       	ldi	r23, 0x00	; 0
         if(arg != 0) 
         {
            ptmp[0] = (uint8_t*)arg;
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
         }
         return wizchip_init(ptmp[0], ptmp[1]);
    4870:	ce 01       	movw	r24, r28
   #endif      
      default:
         return -1;
   }
   return 0;
}
    4872:	df 91       	pop	r29
    4874:	cf 91       	pop	r28
    4876:	1f 91       	pop	r17
         if(arg != 0) 
         {
            ptmp[0] = (uint8_t*)arg;
            ptmp[1] = ptmp[0] + _WIZCHIP_SOCK_NUM_;
         }
         return wizchip_init(ptmp[0], ptmp[1]);
    4878:	0c 94 b7 22 	jmp	0x456e	; 0x456e <wizchip_init>
      case CW_CLR_INTERRUPT:
         wizchip_clrinterrupt(*((intr_kind*)arg));
    487c:	88 81       	ld	r24, Y
    487e:	99 81       	ldd	r25, Y+1	; 0x01
    4880:	0e 94 15 23 	call	0x462a	; 0x462a <wizchip_clrinterrupt>
    4884:	07 c0       	rjmp	.+14     	; 0x4894 <ctlwizchip+0x54>
         break;
      case CW_GET_INTERRUPT:
        *((intr_kind*)arg) = wizchip_getinterrupt();
    4886:	0e 94 27 23 	call	0x464e	; 0x464e <wizchip_getinterrupt>
    488a:	08 c0       	rjmp	.+16     	; 0x489c <ctlwizchip+0x5c>
         break;
      case CW_SET_INTRMASK:
         wizchip_setinterruptmask(*((intr_kind*)arg));
    488c:	88 81       	ld	r24, Y
    488e:	99 81       	ldd	r25, Y+1	; 0x01
    4890:	0e 94 3d 23 	call	0x467a	; 0x467a <wizchip_setinterruptmask>
         break;
   #endif      
      default:
         return -1;
   }
   return 0;
    4894:	80 e0       	ldi	r24, 0x00	; 0
      case CW_GET_INTERRUPT:
        *((intr_kind*)arg) = wizchip_getinterrupt();
         break;
      case CW_SET_INTRMASK:
         wizchip_setinterruptmask(*((intr_kind*)arg));
         break;         
    4896:	56 c0       	rjmp	.+172    	; 0x4944 <ctlwizchip+0x104>
      case CW_GET_INTRMASK:
         *((intr_kind*)arg) = wizchip_getinterruptmask();
    4898:	0e 94 4e 23 	call	0x469c	; 0x469c <wizchip_getinterruptmask>
    489c:	99 83       	std	Y+1, r25	; 0x01
    489e:	88 83       	st	Y, r24
    48a0:	f9 cf       	rjmp	.-14     	; 0x4894 <ctlwizchip+0x54>
         break;
   //M20150601 : This can be supported by W5200, W5500
   //#if _WIZCHIP_ > W5100
   #if (_WIZCHIP_ == W5200 || _WIZCHIP_ == W5500)
      case CW_SET_INTRTIME:
         setINTLEVEL(*(uint16_t*)arg);
    48a2:	49 81       	ldd	r20, Y+1	; 0x01
    48a4:	60 e0       	ldi	r22, 0x00	; 0
    48a6:	73 e1       	ldi	r23, 0x13	; 19
    48a8:	80 e0       	ldi	r24, 0x00	; 0
    48aa:	90 e0       	ldi	r25, 0x00	; 0
    48ac:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    48b0:	48 81       	ld	r20, Y
    48b2:	60 e0       	ldi	r22, 0x00	; 0
    48b4:	74 e1       	ldi	r23, 0x14	; 20
    48b6:	80 e0       	ldi	r24, 0x00	; 0
    48b8:	90 e0       	ldi	r25, 0x00	; 0
    48ba:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    48be:	ea cf       	rjmp	.-44     	; 0x4894 <ctlwizchip+0x54>
         break;
      case CW_GET_INTRTIME:
         *(uint16_t*)arg = getINTLEVEL();
    48c0:	60 e0       	ldi	r22, 0x00	; 0
    48c2:	73 e1       	ldi	r23, 0x13	; 19
    48c4:	80 e0       	ldi	r24, 0x00	; 0
    48c6:	90 e0       	ldi	r25, 0x00	; 0
    48c8:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    48cc:	18 2f       	mov	r17, r24
    48ce:	60 e0       	ldi	r22, 0x00	; 0
    48d0:	74 e1       	ldi	r23, 0x14	; 20
    48d2:	80 e0       	ldi	r24, 0x00	; 0
    48d4:	90 e0       	ldi	r25, 0x00	; 0
    48d6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    48da:	21 2f       	mov	r18, r17
    48dc:	30 e0       	ldi	r19, 0x00	; 0
    48de:	32 2f       	mov	r19, r18
    48e0:	22 27       	eor	r18, r18
    48e2:	28 0f       	add	r18, r24
    48e4:	31 1d       	adc	r19, r1
    48e6:	39 83       	std	Y+1, r19	; 0x01
    48e8:	28 83       	st	Y, r18
    48ea:	d4 cf       	rjmp	.-88     	; 0x4894 <ctlwizchip+0x54>
         break;
   #endif
      case CW_GET_ID:
         ((uint8_t*)arg)[0] = WIZCHIP.id[0];
    48ec:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <WIZCHIP+0x2>
    48f0:	88 83       	st	Y, r24
         ((uint8_t*)arg)[1] = WIZCHIP.id[1];
    48f2:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <WIZCHIP+0x3>
    48f6:	89 83       	std	Y+1, r24	; 0x01
         ((uint8_t*)arg)[2] = WIZCHIP.id[2];
    48f8:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <WIZCHIP+0x4>
    48fc:	8a 83       	std	Y+2, r24	; 0x02
         ((uint8_t*)arg)[3] = WIZCHIP.id[3];
    48fe:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <WIZCHIP+0x5>
    4902:	8b 83       	std	Y+3, r24	; 0x03
         ((uint8_t*)arg)[4] = WIZCHIP.id[4];
    4904:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <WIZCHIP+0x6>
    4908:	8c 83       	std	Y+4, r24	; 0x04
         ((uint8_t*)arg)[5] = 0;
    490a:	1d 82       	std	Y+5, r1	; 0x05
    490c:	c3 cf       	rjmp	.-122    	; 0x4894 <ctlwizchip+0x54>
         break;
   #if _WIZCHIP_ == W5100S || _WIZCHIP_ == W5500
      case CW_RESET_PHY:
         wizphy_reset();
    490e:	0e 94 78 23 	call	0x46f0	; 0x46f0 <wizphy_reset>
    4912:	c0 cf       	rjmp	.-128    	; 0x4894 <ctlwizchip+0x54>
         break;
      case CW_SET_PHYCONF:
         wizphy_setphyconf((wiz_PhyConf*)arg);
    4914:	cb 01       	movw	r24, r22
    4916:	0e 94 94 23 	call	0x4728	; 0x4728 <wizphy_setphyconf>
    491a:	bc cf       	rjmp	.-136    	; 0x4894 <ctlwizchip+0x54>
         break;
      case CW_GET_PHYCONF:
         wizphy_getphyconf((wiz_PhyConf*)arg);
    491c:	cb 01       	movw	r24, r22
    491e:	0e 94 b5 23 	call	0x476a	; 0x476a <wizphy_getphyconf>
    4922:	b8 cf       	rjmp	.-144    	; 0x4894 <ctlwizchip+0x54>
         break;
      case CW_GET_PHYSTATUS:
         break;
      case CW_SET_PHYPOWMODE:
         return wizphy_setphypmode(*(uint8_t*)arg);
    4924:	88 81       	ld	r24, Y
   #endif      
      default:
         return -1;
   }
   return 0;
}
    4926:	df 91       	pop	r29
    4928:	cf 91       	pop	r28
    492a:	1f 91       	pop	r17
         wizphy_getphyconf((wiz_PhyConf*)arg);
         break;
      case CW_GET_PHYSTATUS:
         break;
      case CW_SET_PHYPOWMODE:
         return wizphy_setphypmode(*(uint8_t*)arg);
    492c:	0c 94 f5 23 	jmp	0x47ea	; 0x47ea <wizphy_setphypmode>
   #endif
   #if _WIZCHIP_ == W5100S || _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
      case CW_GET_PHYPOWMODE:
         tmp = wizphy_getphypmode();
    4930:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <wizphy_getphypmode>
    4934:	02 c0       	rjmp	.+4      	; 0x493a <ctlwizchip+0xfa>
         if((int8_t)tmp == -1) return -1;
         *(uint8_t*)arg = tmp;
         break;
      case CW_GET_PHYLINK:
         tmp = wizphy_getphylink();
    4936:	0e 94 63 23 	call	0x46c6	; 0x46c6 <wizphy_getphylink>
         if((int8_t)tmp == -1) return -1;
    493a:	8f 3f       	cpi	r24, 0xFF	; 255
    493c:	11 f0       	breq	.+4      	; 0x4942 <ctlwizchip+0x102>
         *(uint8_t*)arg = tmp;
    493e:	88 83       	st	Y, r24
    4940:	a9 cf       	rjmp	.-174    	; 0x4894 <ctlwizchip+0x54>
         break;
   #endif      
      default:
         return -1;
    4942:	8f ef       	ldi	r24, 0xFF	; 255
   }
   return 0;
}
    4944:	df 91       	pop	r29
    4946:	cf 91       	pop	r28
    4948:	1f 91       	pop	r17
    494a:	08 95       	ret

0000494c <wizchip_setnetinfo>:
}
#endif


void wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
{
    494c:	cf 93       	push	r28
    494e:	df 93       	push	r29
    4950:	ec 01       	movw	r28, r24
   setSHAR(pnetinfo->mac);
    4952:	26 e0       	ldi	r18, 0x06	; 6
    4954:	30 e0       	ldi	r19, 0x00	; 0
    4956:	ac 01       	movw	r20, r24
    4958:	60 e0       	ldi	r22, 0x00	; 0
    495a:	79 e0       	ldi	r23, 0x09	; 9
    495c:	80 e0       	ldi	r24, 0x00	; 0
    495e:	90 e0       	ldi	r25, 0x00	; 0
    4960:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setGAR(pnetinfo->gw);
    4964:	ae 01       	movw	r20, r28
    4966:	42 5f       	subi	r20, 0xF2	; 242
    4968:	5f 4f       	sbci	r21, 0xFF	; 255
    496a:	24 e0       	ldi	r18, 0x04	; 4
    496c:	30 e0       	ldi	r19, 0x00	; 0
    496e:	60 e0       	ldi	r22, 0x00	; 0
    4970:	71 e0       	ldi	r23, 0x01	; 1
    4972:	80 e0       	ldi	r24, 0x00	; 0
    4974:	90 e0       	ldi	r25, 0x00	; 0
    4976:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setSUBR(pnetinfo->sn);
    497a:	ae 01       	movw	r20, r28
    497c:	46 5f       	subi	r20, 0xF6	; 246
    497e:	5f 4f       	sbci	r21, 0xFF	; 255
    4980:	24 e0       	ldi	r18, 0x04	; 4
    4982:	30 e0       	ldi	r19, 0x00	; 0
    4984:	60 e0       	ldi	r22, 0x00	; 0
    4986:	75 e0       	ldi	r23, 0x05	; 5
    4988:	80 e0       	ldi	r24, 0x00	; 0
    498a:	90 e0       	ldi	r25, 0x00	; 0
    498c:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   setSIPR(pnetinfo->ip);
    4990:	ae 01       	movw	r20, r28
    4992:	4a 5f       	subi	r20, 0xFA	; 250
    4994:	5f 4f       	sbci	r21, 0xFF	; 255
    4996:	24 e0       	ldi	r18, 0x04	; 4
    4998:	30 e0       	ldi	r19, 0x00	; 0
    499a:	60 e0       	ldi	r22, 0x00	; 0
    499c:	7f e0       	ldi	r23, 0x0F	; 15
    499e:	80 e0       	ldi	r24, 0x00	; 0
    49a0:	90 e0       	ldi	r25, 0x00	; 0
    49a2:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   _DNS_[0] = pnetinfo->dns[0];
    49a6:	ea e2       	ldi	r30, 0x2A	; 42
    49a8:	f8 e0       	ldi	r31, 0x08	; 8
    49aa:	8a 89       	ldd	r24, Y+18	; 0x12
    49ac:	80 83       	st	Z, r24
   _DNS_[1] = pnetinfo->dns[1];
    49ae:	8b 89       	ldd	r24, Y+19	; 0x13
    49b0:	81 83       	std	Z+1, r24	; 0x01
   _DNS_[2] = pnetinfo->dns[2];
    49b2:	8c 89       	ldd	r24, Y+20	; 0x14
    49b4:	82 83       	std	Z+2, r24	; 0x02
   _DNS_[3] = pnetinfo->dns[3];
    49b6:	8d 89       	ldd	r24, Y+21	; 0x15
    49b8:	83 83       	std	Z+3, r24	; 0x03
   _DHCP_   = pnetinfo->dhcp;
    49ba:	8e 89       	ldd	r24, Y+22	; 0x16
    49bc:	80 93 29 08 	sts	0x0829, r24	; 0x800829 <_DHCP_>
}
    49c0:	df 91       	pop	r29
    49c2:	cf 91       	pop	r28
    49c4:	08 95       	ret

000049c6 <wizchip_getnetinfo>:

void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
{
    49c6:	cf 93       	push	r28
    49c8:	df 93       	push	r29
    49ca:	ec 01       	movw	r28, r24
   getSHAR(pnetinfo->mac);
    49cc:	26 e0       	ldi	r18, 0x06	; 6
    49ce:	30 e0       	ldi	r19, 0x00	; 0
    49d0:	ac 01       	movw	r20, r24
    49d2:	60 e0       	ldi	r22, 0x00	; 0
    49d4:	79 e0       	ldi	r23, 0x09	; 9
    49d6:	80 e0       	ldi	r24, 0x00	; 0
    49d8:	90 e0       	ldi	r25, 0x00	; 0
    49da:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   getGAR(pnetinfo->gw);
    49de:	ae 01       	movw	r20, r28
    49e0:	42 5f       	subi	r20, 0xF2	; 242
    49e2:	5f 4f       	sbci	r21, 0xFF	; 255
    49e4:	24 e0       	ldi	r18, 0x04	; 4
    49e6:	30 e0       	ldi	r19, 0x00	; 0
    49e8:	60 e0       	ldi	r22, 0x00	; 0
    49ea:	71 e0       	ldi	r23, 0x01	; 1
    49ec:	80 e0       	ldi	r24, 0x00	; 0
    49ee:	90 e0       	ldi	r25, 0x00	; 0
    49f0:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   getSUBR(pnetinfo->sn);
    49f4:	ae 01       	movw	r20, r28
    49f6:	46 5f       	subi	r20, 0xF6	; 246
    49f8:	5f 4f       	sbci	r21, 0xFF	; 255
    49fa:	24 e0       	ldi	r18, 0x04	; 4
    49fc:	30 e0       	ldi	r19, 0x00	; 0
    49fe:	60 e0       	ldi	r22, 0x00	; 0
    4a00:	75 e0       	ldi	r23, 0x05	; 5
    4a02:	80 e0       	ldi	r24, 0x00	; 0
    4a04:	90 e0       	ldi	r25, 0x00	; 0
    4a06:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   getSIPR(pnetinfo->ip);
    4a0a:	ae 01       	movw	r20, r28
    4a0c:	4a 5f       	subi	r20, 0xFA	; 250
    4a0e:	5f 4f       	sbci	r21, 0xFF	; 255
    4a10:	24 e0       	ldi	r18, 0x04	; 4
    4a12:	30 e0       	ldi	r19, 0x00	; 0
    4a14:	60 e0       	ldi	r22, 0x00	; 0
    4a16:	7f e0       	ldi	r23, 0x0F	; 15
    4a18:	80 e0       	ldi	r24, 0x00	; 0
    4a1a:	90 e0       	ldi	r25, 0x00	; 0
    4a1c:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   pnetinfo->dns[0]= _DNS_[0];
    4a20:	ea e2       	ldi	r30, 0x2A	; 42
    4a22:	f8 e0       	ldi	r31, 0x08	; 8
    4a24:	80 81       	ld	r24, Z
    4a26:	8a 8b       	std	Y+18, r24	; 0x12
   pnetinfo->dns[1]= _DNS_[1];
    4a28:	81 81       	ldd	r24, Z+1	; 0x01
    4a2a:	8b 8b       	std	Y+19, r24	; 0x13
   pnetinfo->dns[2]= _DNS_[2];
    4a2c:	82 81       	ldd	r24, Z+2	; 0x02
    4a2e:	8c 8b       	std	Y+20, r24	; 0x14
   pnetinfo->dns[3]= _DNS_[3];
    4a30:	83 81       	ldd	r24, Z+3	; 0x03
    4a32:	8d 8b       	std	Y+21, r24	; 0x15
   pnetinfo->dhcp  = _DHCP_;
    4a34:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <_DHCP_>
    4a38:	8e 8b       	std	Y+22, r24	; 0x16
}
    4a3a:	df 91       	pop	r29
    4a3c:	cf 91       	pop	r28
    4a3e:	08 95       	ret

00004a40 <wizchip_setnetmode>:

int8_t wizchip_setnetmode(netmode_type netmode)
{
    4a40:	cf 93       	push	r28
   uint8_t tmp = 0;
#if _WIZCHIP_ != W5500
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
#else
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
    4a42:	98 2f       	mov	r25, r24
    4a44:	95 7c       	andi	r25, 0xC5	; 197
    4a46:	79 f4       	brne	.+30     	; 0x4a66 <wizchip_setnetmode+0x26>
    4a48:	c8 2f       	mov	r28, r24
#endif      
   tmp = getMR();
    4a4a:	60 e0       	ldi	r22, 0x00	; 0
    4a4c:	70 e0       	ldi	r23, 0x00	; 0
    4a4e:	cb 01       	movw	r24, r22
    4a50:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
   tmp |= (uint8_t)netmode;
   setMR(tmp);
    4a54:	4c 2f       	mov	r20, r28
    4a56:	48 2b       	or	r20, r24
    4a58:	60 e0       	ldi	r22, 0x00	; 0
    4a5a:	70 e0       	ldi	r23, 0x00	; 0
    4a5c:	cb 01       	movw	r24, r22
    4a5e:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   return 0;
    4a62:	80 e0       	ldi	r24, 0x00	; 0
    4a64:	01 c0       	rjmp	.+2      	; 0x4a68 <wizchip_setnetmode+0x28>
{
   uint8_t tmp = 0;
#if _WIZCHIP_ != W5500
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
#else
   if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
    4a66:	8f ef       	ldi	r24, 0xFF	; 255
#endif      
   tmp = getMR();
   tmp |= (uint8_t)netmode;
   setMR(tmp);
   return 0;
}
    4a68:	cf 91       	pop	r28
    4a6a:	08 95       	ret

00004a6c <wizchip_getnetmode>:

netmode_type wizchip_getnetmode(void)
{
   return (netmode_type) getMR();
    4a6c:	60 e0       	ldi	r22, 0x00	; 0
    4a6e:	70 e0       	ldi	r23, 0x00	; 0
    4a70:	cb 01       	movw	r24, r22
    4a72:	0c 94 aa 25 	jmp	0x4b54	; 0x4b54 <WIZCHIP_READ>

00004a76 <wizchip_settimeout>:
}

void wizchip_settimeout(wiz_NetTimeout* nettime)
{
    4a76:	cf 93       	push	r28
    4a78:	df 93       	push	r29
    4a7a:	ec 01       	movw	r28, r24
   setRCR(nettime->retry_cnt);
    4a7c:	48 81       	ld	r20, Y
    4a7e:	60 e0       	ldi	r22, 0x00	; 0
    4a80:	7b e1       	ldi	r23, 0x1B	; 27
    4a82:	80 e0       	ldi	r24, 0x00	; 0
    4a84:	90 e0       	ldi	r25, 0x00	; 0
    4a86:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
   setRTR(nettime->time_100us);
    4a8a:	4a 81       	ldd	r20, Y+2	; 0x02
    4a8c:	60 e0       	ldi	r22, 0x00	; 0
    4a8e:	79 e1       	ldi	r23, 0x19	; 25
    4a90:	80 e0       	ldi	r24, 0x00	; 0
    4a92:	90 e0       	ldi	r25, 0x00	; 0
    4a94:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    4a98:	49 81       	ldd	r20, Y+1	; 0x01
    4a9a:	60 e0       	ldi	r22, 0x00	; 0
    4a9c:	7a e1       	ldi	r23, 0x1A	; 26
    4a9e:	80 e0       	ldi	r24, 0x00	; 0
    4aa0:	90 e0       	ldi	r25, 0x00	; 0
}
    4aa2:	df 91       	pop	r29
    4aa4:	cf 91       	pop	r28
}

void wizchip_settimeout(wiz_NetTimeout* nettime)
{
   setRCR(nettime->retry_cnt);
   setRTR(nettime->time_100us);
    4aa6:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>

00004aaa <wizchip_gettimeout>:
}

void wizchip_gettimeout(wiz_NetTimeout* nettime)
{
    4aaa:	0f 93       	push	r16
    4aac:	1f 93       	push	r17
    4aae:	cf 93       	push	r28
    4ab0:	8c 01       	movw	r16, r24
   nettime->retry_cnt = getRCR();
    4ab2:	60 e0       	ldi	r22, 0x00	; 0
    4ab4:	7b e1       	ldi	r23, 0x1B	; 27
    4ab6:	80 e0       	ldi	r24, 0x00	; 0
    4ab8:	90 e0       	ldi	r25, 0x00	; 0
    4aba:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4abe:	f8 01       	movw	r30, r16
    4ac0:	80 83       	st	Z, r24
   nettime->time_100us = getRTR();
    4ac2:	60 e0       	ldi	r22, 0x00	; 0
    4ac4:	79 e1       	ldi	r23, 0x19	; 25
    4ac6:	80 e0       	ldi	r24, 0x00	; 0
    4ac8:	90 e0       	ldi	r25, 0x00	; 0
    4aca:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4ace:	c8 2f       	mov	r28, r24
    4ad0:	60 e0       	ldi	r22, 0x00	; 0
    4ad2:	7a e1       	ldi	r23, 0x1A	; 26
    4ad4:	80 e0       	ldi	r24, 0x00	; 0
    4ad6:	90 e0       	ldi	r25, 0x00	; 0
    4ad8:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4adc:	2c 2f       	mov	r18, r28
    4ade:	30 e0       	ldi	r19, 0x00	; 0
    4ae0:	32 2f       	mov	r19, r18
    4ae2:	22 27       	eor	r18, r18
    4ae4:	28 0f       	add	r18, r24
    4ae6:	31 1d       	adc	r19, r1
    4ae8:	f8 01       	movw	r30, r16
    4aea:	32 83       	std	Z+2, r19	; 0x02
    4aec:	21 83       	std	Z+1, r18	; 0x01
}
    4aee:	cf 91       	pop	r28
    4af0:	1f 91       	pop	r17
    4af2:	0f 91       	pop	r16
    4af4:	08 95       	ret

00004af6 <ctlnetwork>:
   return 0;
}


int8_t ctlnetwork(ctlnetwork_type cntype, void* arg)
{
    4af6:	cf 93       	push	r28
    4af8:	df 93       	push	r29
   
   switch(cntype)
    4afa:	82 30       	cpi	r24, 0x02	; 2
    4afc:	c1 f0       	breq	.+48     	; 0x4b2e <ctlnetwork+0x38>
    4afe:	eb 01       	movw	r28, r22
    4b00:	83 30       	cpi	r24, 0x03	; 3
    4b02:	40 f4       	brcc	.+16     	; 0x4b14 <ctlnetwork+0x1e>
    4b04:	88 23       	and	r24, r24
    4b06:	79 f0       	breq	.+30     	; 0x4b26 <ctlnetwork+0x30>
    4b08:	81 30       	cpi	r24, 0x01	; 1
    4b0a:	01 f5       	brne	.+64     	; 0x4b4c <ctlnetwork+0x56>
   {
      case CN_SET_NETINFO:
         wizchip_setnetinfo((wiz_NetInfo*)arg);
         break;
      case CN_GET_NETINFO:
         wizchip_getnetinfo((wiz_NetInfo*)arg);
    4b0c:	cb 01       	movw	r24, r22
    4b0e:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <wizchip_getnetinfo>
    4b12:	1a c0       	rjmp	.+52     	; 0x4b48 <ctlnetwork+0x52>


int8_t ctlnetwork(ctlnetwork_type cntype, void* arg)
{
   
   switch(cntype)
    4b14:	84 30       	cpi	r24, 0x04	; 4
    4b16:	a9 f0       	breq	.+42     	; 0x4b42 <ctlnetwork+0x4c>
    4b18:	80 f0       	brcs	.+32     	; 0x4b3a <ctlnetwork+0x44>
    4b1a:	85 30       	cpi	r24, 0x05	; 5
    4b1c:	b9 f4       	brne	.+46     	; 0x4b4c <ctlnetwork+0x56>
         break;
      case CN_SET_TIMEOUT:
         wizchip_settimeout((wiz_NetTimeout*)arg);
         break;
      case CN_GET_TIMEOUT:
         wizchip_gettimeout((wiz_NetTimeout*)arg);
    4b1e:	cb 01       	movw	r24, r22
    4b20:	0e 94 55 25 	call	0x4aaa	; 0x4aaa <wizchip_gettimeout>
    4b24:	11 c0       	rjmp	.+34     	; 0x4b48 <ctlnetwork+0x52>
{
   
   switch(cntype)
   {
      case CN_SET_NETINFO:
         wizchip_setnetinfo((wiz_NetInfo*)arg);
    4b26:	cb 01       	movw	r24, r22
    4b28:	0e 94 a6 24 	call	0x494c	; 0x494c <wizchip_setnetinfo>
    4b2c:	0d c0       	rjmp	.+26     	; 0x4b48 <ctlnetwork+0x52>
         break;
      case CN_GET_NETINFO:
         wizchip_getnetinfo((wiz_NetInfo*)arg);
         break;
      case CN_SET_NETMODE:
         return wizchip_setnetmode(*(netmode_type*)arg);
    4b2e:	fb 01       	movw	r30, r22
    4b30:	80 81       	ld	r24, Z
         break;
      default:
         return -1;
   }
   return 0;
}
    4b32:	df 91       	pop	r29
    4b34:	cf 91       	pop	r28
         break;
      case CN_GET_NETINFO:
         wizchip_getnetinfo((wiz_NetInfo*)arg);
         break;
      case CN_SET_NETMODE:
         return wizchip_setnetmode(*(netmode_type*)arg);
    4b36:	0c 94 20 25 	jmp	0x4a40	; 0x4a40 <wizchip_setnetmode>
      case CN_GET_NETMODE:
         *(netmode_type*)arg = wizchip_getnetmode();
    4b3a:	0e 94 36 25 	call	0x4a6c	; 0x4a6c <wizchip_getnetmode>
    4b3e:	88 83       	st	Y, r24
    4b40:	03 c0       	rjmp	.+6      	; 0x4b48 <ctlnetwork+0x52>
         break;
      case CN_SET_TIMEOUT:
         wizchip_settimeout((wiz_NetTimeout*)arg);
    4b42:	cb 01       	movw	r24, r22
    4b44:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <wizchip_settimeout>
         wizchip_gettimeout((wiz_NetTimeout*)arg);
         break;
      default:
         return -1;
   }
   return 0;
    4b48:	80 e0       	ldi	r24, 0x00	; 0
      case CN_GET_NETMODE:
         *(netmode_type*)arg = wizchip_getnetmode();
         break;
      case CN_SET_TIMEOUT:
         wizchip_settimeout((wiz_NetTimeout*)arg);
         break;
    4b4a:	01 c0       	rjmp	.+2      	; 0x4b4e <ctlnetwork+0x58>
      case CN_GET_TIMEOUT:
         wizchip_gettimeout((wiz_NetTimeout*)arg);
         break;
      default:
         return -1;
    4b4c:	8f ef       	ldi	r24, 0xFF	; 255
   }
   return 0;
}
    4b4e:	df 91       	pop	r29
    4b50:	cf 91       	pop	r28
    4b52:	08 95       	ret

00004b54 <WIZCHIP_READ>:

#if   (_WIZCHIP_ == 5500)
////////////////////////////////////////////////////

uint8_t  WIZCHIP_READ(uint32_t AddrSel)
{
    4b54:	8f 92       	push	r8
    4b56:	9f 92       	push	r9
    4b58:	af 92       	push	r10
    4b5a:	bf 92       	push	r11
    4b5c:	cf 92       	push	r12
    4b5e:	df 92       	push	r13
    4b60:	ef 92       	push	r14
    4b62:	ff 92       	push	r15
    4b64:	cf 93       	push	r28
    4b66:	df 93       	push	r29
    4b68:	00 d0       	rcall	.+0      	; 0x4b6a <WIZCHIP_READ+0x16>
    4b6a:	1f 92       	push	r1
    4b6c:	cd b7       	in	r28, 0x3d	; 61
    4b6e:	de b7       	in	r29, 0x3e	; 62
    4b70:	6b 01       	movw	r12, r22
    4b72:	7c 01       	movw	r14, r24
   uint8_t ret;
   uint8_t spi_data[3];

   WIZCHIP_CRITICAL_ENTER();
    4b74:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    4b78:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    4b7c:	09 95       	icall
   WIZCHIP.CS._select();
    4b7e:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    4b82:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    4b86:	09 95       	icall

   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);

   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
    4b88:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <WIZCHIP+0x15>
    4b8c:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <WIZCHIP+0x16>
    4b90:	c7 01       	movw	r24, r14
    4b92:	b6 01       	movw	r22, r12
    4b94:	66 27       	eor	r22, r22
    4b96:	77 27       	eor	r23, r23
    4b98:	99 27       	eor	r25, r25
    4b9a:	46 01       	movw	r8, r12
    4b9c:	57 01       	movw	r10, r14
    4b9e:	88 24       	eor	r8, r8
    4ba0:	aa 24       	eor	r10, r10
    4ba2:	bb 24       	eor	r11, r11
    4ba4:	23 2b       	or	r18, r19
    4ba6:	31 f0       	breq	.+12     	; 0x4bb4 <WIZCHIP_READ+0x60>
    4ba8:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    4bac:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    4bb0:	30 97       	sbiw	r30, 0x00	; 0
    4bb2:	91 f4       	brne	.+36     	; 0x4bd8 <WIZCHIP_READ+0x84>
   {
	   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    4bb4:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4bb8:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4bbc:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    4bbe:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4bc2:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4bc6:	89 2d       	mov	r24, r9
    4bc8:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    4bca:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4bce:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4bd2:	8c 2d       	mov	r24, r12
    4bd4:	09 95       	icall
    4bd6:	08 c0       	rjmp	.+16     	; 0x4be8 <WIZCHIP_READ+0x94>
   }
   else																// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    4bd8:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    4bda:	9a 82       	std	Y+2, r9	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    4bdc:	cb 82       	std	Y+3, r12	; 0x03
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    4bde:	63 e0       	ldi	r22, 0x03	; 3
    4be0:	70 e0       	ldi	r23, 0x00	; 0
    4be2:	ce 01       	movw	r24, r28
    4be4:	01 96       	adiw	r24, 0x01	; 1
    4be6:	09 95       	icall
   }
   ret = WIZCHIP.IF.SPI._read_byte();
    4be8:	e0 91 15 01 	lds	r30, 0x0115	; 0x800115 <WIZCHIP+0x11>
    4bec:	f0 91 16 01 	lds	r31, 0x0116	; 0x800116 <WIZCHIP+0x12>
    4bf0:	09 95       	icall
    4bf2:	f8 2e       	mov	r15, r24

   WIZCHIP.CS._deselect();
    4bf4:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    4bf8:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    4bfc:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    4bfe:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    4c02:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    4c06:	09 95       	icall
   return ret;
}
    4c08:	8f 2d       	mov	r24, r15
    4c0a:	0f 90       	pop	r0
    4c0c:	0f 90       	pop	r0
    4c0e:	0f 90       	pop	r0
    4c10:	df 91       	pop	r29
    4c12:	cf 91       	pop	r28
    4c14:	ff 90       	pop	r15
    4c16:	ef 90       	pop	r14
    4c18:	df 90       	pop	r13
    4c1a:	cf 90       	pop	r12
    4c1c:	bf 90       	pop	r11
    4c1e:	af 90       	pop	r10
    4c20:	9f 90       	pop	r9
    4c22:	8f 90       	pop	r8
    4c24:	08 95       	ret

00004c26 <WIZCHIP_WRITE>:

void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
{
    4c26:	8f 92       	push	r8
    4c28:	9f 92       	push	r9
    4c2a:	af 92       	push	r10
    4c2c:	bf 92       	push	r11
    4c2e:	cf 92       	push	r12
    4c30:	df 92       	push	r13
    4c32:	ef 92       	push	r14
    4c34:	ff 92       	push	r15
    4c36:	1f 93       	push	r17
    4c38:	cf 93       	push	r28
    4c3a:	df 93       	push	r29
    4c3c:	00 d0       	rcall	.+0      	; 0x4c3e <WIZCHIP_WRITE+0x18>
    4c3e:	00 d0       	rcall	.+0      	; 0x4c40 <WIZCHIP_WRITE+0x1a>
    4c40:	cd b7       	in	r28, 0x3d	; 61
    4c42:	de b7       	in	r29, 0x3e	; 62
    4c44:	6b 01       	movw	r12, r22
    4c46:	7c 01       	movw	r14, r24
    4c48:	14 2f       	mov	r17, r20
   uint8_t spi_data[4];

   WIZCHIP_CRITICAL_ENTER();
    4c4a:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    4c4e:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    4c52:	09 95       	icall
   WIZCHIP.CS._select();
    4c54:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    4c58:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    4c5c:	09 95       	icall

   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
    4c5e:	46 01       	movw	r8, r12
    4c60:	57 01       	movw	r10, r14
    4c62:	68 94       	set
    4c64:	82 f8       	bld	r8, 2

   //if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
    4c66:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    4c6a:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    4c6e:	c7 01       	movw	r24, r14
    4c70:	b6 01       	movw	r22, r12
    4c72:	66 27       	eor	r22, r22
    4c74:	77 27       	eor	r23, r23
    4c76:	99 27       	eor	r25, r25
    4c78:	cc 24       	eor	r12, r12
    4c7a:	ee 24       	eor	r14, r14
    4c7c:	ff 24       	eor	r15, r15
    4c7e:	30 97       	sbiw	r30, 0x00	; 0
    4c80:	c1 f4       	brne	.+48     	; 0x4cb2 <WIZCHIP_WRITE+0x8c>
   {
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    4c82:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4c86:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4c8a:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    4c8c:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4c90:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4c94:	8d 2d       	mov	r24, r13
    4c96:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    4c98:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4c9c:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4ca0:	88 2d       	mov	r24, r8
    4ca2:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte(wb);
    4ca4:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4ca8:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4cac:	81 2f       	mov	r24, r17
    4cae:	09 95       	icall
    4cb0:	09 c0       	rjmp	.+18     	; 0x4cc4 <WIZCHIP_WRITE+0x9e>
   }
   else									// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    4cb2:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    4cb4:	da 82       	std	Y+2, r13	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    4cb6:	8b 82       	std	Y+3, r8	; 0x03
		spi_data[3] = wb;
    4cb8:	1c 83       	std	Y+4, r17	; 0x04
		WIZCHIP.IF.SPI._write_burst(spi_data, 4);
    4cba:	64 e0       	ldi	r22, 0x04	; 4
    4cbc:	70 e0       	ldi	r23, 0x00	; 0
    4cbe:	ce 01       	movw	r24, r28
    4cc0:	01 96       	adiw	r24, 0x01	; 1
    4cc2:	09 95       	icall
   }

   WIZCHIP.CS._deselect();
    4cc4:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    4cc8:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    4ccc:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    4cce:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    4cd2:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    4cd6:	09 95       	icall
}
    4cd8:	0f 90       	pop	r0
    4cda:	0f 90       	pop	r0
    4cdc:	0f 90       	pop	r0
    4cde:	0f 90       	pop	r0
    4ce0:	df 91       	pop	r29
    4ce2:	cf 91       	pop	r28
    4ce4:	1f 91       	pop	r17
    4ce6:	ff 90       	pop	r15
    4ce8:	ef 90       	pop	r14
    4cea:	df 90       	pop	r13
    4cec:	cf 90       	pop	r12
    4cee:	bf 90       	pop	r11
    4cf0:	af 90       	pop	r10
    4cf2:	9f 90       	pop	r9
    4cf4:	8f 90       	pop	r8
    4cf6:	08 95       	ret

00004cf8 <WIZCHIP_READ_BUF>:
         
void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
{
    4cf8:	4f 92       	push	r4
    4cfa:	5f 92       	push	r5
    4cfc:	6f 92       	push	r6
    4cfe:	7f 92       	push	r7
    4d00:	8f 92       	push	r8
    4d02:	9f 92       	push	r9
    4d04:	af 92       	push	r10
    4d06:	bf 92       	push	r11
    4d08:	cf 92       	push	r12
    4d0a:	df 92       	push	r13
    4d0c:	ef 92       	push	r14
    4d0e:	ff 92       	push	r15
    4d10:	0f 93       	push	r16
    4d12:	1f 93       	push	r17
    4d14:	cf 93       	push	r28
    4d16:	df 93       	push	r29
    4d18:	00 d0       	rcall	.+0      	; 0x4d1a <WIZCHIP_READ_BUF+0x22>
    4d1a:	1f 92       	push	r1
    4d1c:	cd b7       	in	r28, 0x3d	; 61
    4d1e:	de b7       	in	r29, 0x3e	; 62
    4d20:	4b 01       	movw	r8, r22
    4d22:	5c 01       	movw	r10, r24
    4d24:	6a 01       	movw	r12, r20
    4d26:	79 01       	movw	r14, r18
   uint8_t spi_data[3];
   uint16_t i;

   WIZCHIP_CRITICAL_ENTER();
    4d28:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    4d2c:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    4d30:	09 95       	icall
   WIZCHIP.CS._select();
    4d32:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    4d36:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    4d3a:	09 95       	icall

   AddrSel |= (_W5500_SPI_READ_ | _W5500_SPI_VDM_OP_);

   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
    4d3c:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <WIZCHIP+0x15>
    4d40:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <WIZCHIP+0x16>
    4d44:	c5 01       	movw	r24, r10
    4d46:	b4 01       	movw	r22, r8
    4d48:	66 27       	eor	r22, r22
    4d4a:	77 27       	eor	r23, r23
    4d4c:	99 27       	eor	r25, r25
    4d4e:	24 01       	movw	r4, r8
    4d50:	35 01       	movw	r6, r10
    4d52:	44 24       	eor	r4, r4
    4d54:	66 24       	eor	r6, r6
    4d56:	77 24       	eor	r7, r7
    4d58:	23 2b       	or	r18, r19
    4d5a:	31 f0       	breq	.+12     	; 0x4d68 <WIZCHIP_READ_BUF+0x70>
    4d5c:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    4d60:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    4d64:	30 97       	sbiw	r30, 0x00	; 0
    4d66:	01 f5       	brne	.+64     	; 0x4da8 <WIZCHIP_READ_BUF+0xb0>
   {
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    4d68:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4d6c:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4d70:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    4d72:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4d76:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4d7a:	85 2d       	mov	r24, r5
    4d7c:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    4d7e:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4d82:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4d86:	88 2d       	mov	r24, r8
    4d88:	09 95       	icall
    4d8a:	86 01       	movw	r16, r12
    4d8c:	ec 0c       	add	r14, r12
    4d8e:	fd 1c       	adc	r15, r13
		for(i = 0; i < len; i++)
    4d90:	0e 15       	cp	r16, r14
    4d92:	1f 05       	cpc	r17, r15
    4d94:	c1 f0       	breq	.+48     	; 0x4dc6 <WIZCHIP_READ_BUF+0xce>
		   pBuf[i] = WIZCHIP.IF.SPI._read_byte();
    4d96:	e0 91 15 01 	lds	r30, 0x0115	; 0x800115 <WIZCHIP+0x11>
    4d9a:	f0 91 16 01 	lds	r31, 0x0116	; 0x800116 <WIZCHIP+0x12>
    4d9e:	09 95       	icall
    4da0:	f8 01       	movw	r30, r16
    4da2:	81 93       	st	Z+, r24
    4da4:	8f 01       	movw	r16, r30
    4da6:	f4 cf       	rjmp	.-24     	; 0x4d90 <WIZCHIP_READ_BUF+0x98>
   }
   else																// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    4da8:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    4daa:	5a 82       	std	Y+2, r5	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    4dac:	8b 82       	std	Y+3, r8	; 0x03
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    4dae:	63 e0       	ldi	r22, 0x03	; 3
    4db0:	70 e0       	ldi	r23, 0x00	; 0
    4db2:	ce 01       	movw	r24, r28
    4db4:	01 96       	adiw	r24, 0x01	; 1
    4db6:	09 95       	icall
		WIZCHIP.IF.SPI._read_burst(pBuf, len);
    4db8:	e0 91 19 01 	lds	r30, 0x0119	; 0x800119 <WIZCHIP+0x15>
    4dbc:	f0 91 1a 01 	lds	r31, 0x011A	; 0x80011a <WIZCHIP+0x16>
    4dc0:	b7 01       	movw	r22, r14
    4dc2:	c6 01       	movw	r24, r12
    4dc4:	09 95       	icall
   }

   WIZCHIP.CS._deselect();
    4dc6:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    4dca:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    4dce:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    4dd0:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    4dd4:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    4dd8:	09 95       	icall
}
    4dda:	0f 90       	pop	r0
    4ddc:	0f 90       	pop	r0
    4dde:	0f 90       	pop	r0
    4de0:	df 91       	pop	r29
    4de2:	cf 91       	pop	r28
    4de4:	1f 91       	pop	r17
    4de6:	0f 91       	pop	r16
    4de8:	ff 90       	pop	r15
    4dea:	ef 90       	pop	r14
    4dec:	df 90       	pop	r13
    4dee:	cf 90       	pop	r12
    4df0:	bf 90       	pop	r11
    4df2:	af 90       	pop	r10
    4df4:	9f 90       	pop	r9
    4df6:	8f 90       	pop	r8
    4df8:	7f 90       	pop	r7
    4dfa:	6f 90       	pop	r6
    4dfc:	5f 90       	pop	r5
    4dfe:	4f 90       	pop	r4
    4e00:	08 95       	ret

00004e02 <WIZCHIP_WRITE_BUF>:

void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
{
    4e02:	4f 92       	push	r4
    4e04:	5f 92       	push	r5
    4e06:	6f 92       	push	r6
    4e08:	7f 92       	push	r7
    4e0a:	8f 92       	push	r8
    4e0c:	9f 92       	push	r9
    4e0e:	af 92       	push	r10
    4e10:	bf 92       	push	r11
    4e12:	cf 92       	push	r12
    4e14:	df 92       	push	r13
    4e16:	ef 92       	push	r14
    4e18:	ff 92       	push	r15
    4e1a:	0f 93       	push	r16
    4e1c:	1f 93       	push	r17
    4e1e:	cf 93       	push	r28
    4e20:	df 93       	push	r29
    4e22:	00 d0       	rcall	.+0      	; 0x4e24 <WIZCHIP_WRITE_BUF+0x22>
    4e24:	1f 92       	push	r1
    4e26:	cd b7       	in	r28, 0x3d	; 61
    4e28:	de b7       	in	r29, 0x3e	; 62
    4e2a:	6b 01       	movw	r12, r22
    4e2c:	7c 01       	movw	r14, r24
    4e2e:	4a 01       	movw	r8, r20
    4e30:	59 01       	movw	r10, r18
   uint8_t spi_data[3];
   uint16_t i;

   WIZCHIP_CRITICAL_ENTER();
    4e32:	e0 91 0d 01 	lds	r30, 0x010D	; 0x80010d <WIZCHIP+0x9>
    4e36:	f0 91 0e 01 	lds	r31, 0x010E	; 0x80010e <WIZCHIP+0xa>
    4e3a:	09 95       	icall
   WIZCHIP.CS._select();
    4e3c:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <WIZCHIP+0xd>
    4e40:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <WIZCHIP+0xe>
    4e44:	09 95       	icall

   AddrSel |= (_W5500_SPI_WRITE_ | _W5500_SPI_VDM_OP_);
    4e46:	26 01       	movw	r4, r12
    4e48:	37 01       	movw	r6, r14
    4e4a:	68 94       	set
    4e4c:	42 f8       	bld	r4, 2

   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
    4e4e:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    4e52:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    4e56:	c7 01       	movw	r24, r14
    4e58:	b6 01       	movw	r22, r12
    4e5a:	66 27       	eor	r22, r22
    4e5c:	77 27       	eor	r23, r23
    4e5e:	99 27       	eor	r25, r25
    4e60:	cc 24       	eor	r12, r12
    4e62:	ee 24       	eor	r14, r14
    4e64:	ff 24       	eor	r15, r15
    4e66:	30 97       	sbiw	r30, 0x00	; 0
    4e68:	01 f5       	brne	.+64     	; 0x4eaa <WIZCHIP_WRITE_BUF+0xa8>
   {
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF0000) >> 16);
    4e6a:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4e6e:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4e72:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x0000FF00) >>  8);
    4e74:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4e78:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4e7c:	8d 2d       	mov	r24, r13
    4e7e:	09 95       	icall
		WIZCHIP.IF.SPI._write_byte((AddrSel & 0x000000FF) >>  0);
    4e80:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4e84:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4e88:	84 2d       	mov	r24, r4
    4e8a:	09 95       	icall
    4e8c:	84 01       	movw	r16, r8
    4e8e:	a8 0c       	add	r10, r8
    4e90:	b9 1c       	adc	r11, r9
		for(i = 0; i < len; i++)
    4e92:	0a 15       	cp	r16, r10
    4e94:	1b 05       	cpc	r17, r11
    4e96:	c1 f0       	breq	.+48     	; 0x4ec8 <WIZCHIP_WRITE_BUF+0xc6>
			WIZCHIP.IF.SPI._write_byte(pBuf[i]);
    4e98:	e0 91 17 01 	lds	r30, 0x0117	; 0x800117 <WIZCHIP+0x13>
    4e9c:	f0 91 18 01 	lds	r31, 0x0118	; 0x800118 <WIZCHIP+0x14>
    4ea0:	d8 01       	movw	r26, r16
    4ea2:	8d 91       	ld	r24, X+
    4ea4:	8d 01       	movw	r16, r26
    4ea6:	09 95       	icall
    4ea8:	f4 cf       	rjmp	.-24     	; 0x4e92 <WIZCHIP_WRITE_BUF+0x90>
   }
   else									// burst operation
   {
		spi_data[0] = (AddrSel & 0x00FF0000) >> 16;
    4eaa:	89 83       	std	Y+1, r24	; 0x01
		spi_data[1] = (AddrSel & 0x0000FF00) >> 8;
    4eac:	da 82       	std	Y+2, r13	; 0x02
		spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    4eae:	4b 82       	std	Y+3, r4	; 0x03
		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
    4eb0:	63 e0       	ldi	r22, 0x03	; 3
    4eb2:	70 e0       	ldi	r23, 0x00	; 0
    4eb4:	ce 01       	movw	r24, r28
    4eb6:	01 96       	adiw	r24, 0x01	; 1
    4eb8:	09 95       	icall
		WIZCHIP.IF.SPI._write_burst(pBuf, len);
    4eba:	e0 91 1b 01 	lds	r30, 0x011B	; 0x80011b <WIZCHIP+0x17>
    4ebe:	f0 91 1c 01 	lds	r31, 0x011C	; 0x80011c <WIZCHIP+0x18>
    4ec2:	b5 01       	movw	r22, r10
    4ec4:	c4 01       	movw	r24, r8
    4ec6:	09 95       	icall
   }

   WIZCHIP.CS._deselect();
    4ec8:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <WIZCHIP+0xf>
    4ecc:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <WIZCHIP+0x10>
    4ed0:	09 95       	icall
   WIZCHIP_CRITICAL_EXIT();
    4ed2:	e0 91 0f 01 	lds	r30, 0x010F	; 0x80010f <WIZCHIP+0xb>
    4ed6:	f0 91 10 01 	lds	r31, 0x0110	; 0x800110 <WIZCHIP+0xc>
    4eda:	09 95       	icall
}
    4edc:	0f 90       	pop	r0
    4ede:	0f 90       	pop	r0
    4ee0:	0f 90       	pop	r0
    4ee2:	df 91       	pop	r29
    4ee4:	cf 91       	pop	r28
    4ee6:	1f 91       	pop	r17
    4ee8:	0f 91       	pop	r16
    4eea:	ff 90       	pop	r15
    4eec:	ef 90       	pop	r14
    4eee:	df 90       	pop	r13
    4ef0:	cf 90       	pop	r12
    4ef2:	bf 90       	pop	r11
    4ef4:	af 90       	pop	r10
    4ef6:	9f 90       	pop	r9
    4ef8:	8f 90       	pop	r8
    4efa:	7f 90       	pop	r7
    4efc:	6f 90       	pop	r6
    4efe:	5f 90       	pop	r5
    4f00:	4f 90       	pop	r4
    4f02:	08 95       	ret

00004f04 <getSn_TX_FSR>:


uint16_t getSn_TX_FSR(uint8_t sn)
{
    4f04:	8f 92       	push	r8
    4f06:	9f 92       	push	r9
    4f08:	af 92       	push	r10
    4f0a:	bf 92       	push	r11
    4f0c:	cf 92       	push	r12
    4f0e:	df 92       	push	r13
    4f10:	ef 92       	push	r14
    4f12:	ff 92       	push	r15
    4f14:	0f 93       	push	r16
    4f16:	1f 93       	push	r17
    4f18:	cf 93       	push	r28
    4f1a:	df 93       	push	r29
   uint16_t val=0,val1=0;

   do
   {
      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
    4f1c:	24 e0       	ldi	r18, 0x04	; 4
    4f1e:	82 9f       	mul	r24, r18
    4f20:	c0 01       	movw	r24, r0
    4f22:	11 24       	eor	r1, r1
    4f24:	6c 01       	movw	r12, r24
    4f26:	2f ef       	ldi	r18, 0xFF	; 255
    4f28:	c2 1a       	sub	r12, r18
    4f2a:	d2 0a       	sbc	r13, r18
    4f2c:	23 e0       	ldi	r18, 0x03	; 3
    4f2e:	cc 0c       	add	r12, r12
    4f30:	dd 1c       	adc	r13, r13
    4f32:	2a 95       	dec	r18
    4f34:	e1 f7       	brne	.-8      	; 0x4f2e <getSn_TX_FSR+0x2a>
    4f36:	46 01       	movw	r8, r12
    4f38:	80 ee       	ldi	r24, 0xE0	; 224
    4f3a:	98 1a       	sub	r9, r24
    4f3c:	09 2c       	mov	r0, r9
    4f3e:	00 0c       	add	r0, r0
    4f40:	aa 08       	sbc	r10, r10
    4f42:	bb 08       	sbc	r11, r11
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    4f44:	2f ed       	ldi	r18, 0xDF	; 223
    4f46:	d2 1a       	sub	r13, r18
    4f48:	0d 2c       	mov	r0, r13
    4f4a:	00 0c       	add	r0, r0
    4f4c:	ee 08       	sbc	r14, r14
    4f4e:	ff 08       	sbc	r15, r15
}


uint16_t getSn_TX_FSR(uint8_t sn)
{
   uint16_t val=0,val1=0;
    4f50:	c0 e0       	ldi	r28, 0x00	; 0
    4f52:	d0 e0       	ldi	r29, 0x00	; 0

   do
   {
      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
    4f54:	c5 01       	movw	r24, r10
    4f56:	b4 01       	movw	r22, r8
    4f58:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    4f5c:	08 2f       	mov	r16, r24
    4f5e:	10 e0       	ldi	r17, 0x00	; 0
    4f60:	10 2f       	mov	r17, r16
    4f62:	00 27       	eor	r16, r16
    4f64:	c7 01       	movw	r24, r14
    4f66:	b6 01       	movw	r22, r12
    4f68:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4f6c:	08 0f       	add	r16, r24
    4f6e:	11 1d       	adc	r17, r1
      if (val1 != 0)
    4f70:	01 15       	cp	r16, r1
    4f72:	11 05       	cpc	r17, r1
    4f74:	71 f0       	breq	.+28     	; 0x4f92 <getSn_TX_FSR+0x8e>
      {
        val = WIZCHIP_READ(Sn_TX_FSR(sn));
    4f76:	c5 01       	movw	r24, r10
    4f78:	b4 01       	movw	r22, r8
    4f7a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
    4f7e:	c8 2f       	mov	r28, r24
    4f80:	d0 e0       	ldi	r29, 0x00	; 0
    4f82:	dc 2f       	mov	r29, r28
    4f84:	cc 27       	eor	r28, r28
    4f86:	c7 01       	movw	r24, r14
    4f88:	b6 01       	movw	r22, r12
    4f8a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    4f8e:	c8 0f       	add	r28, r24
    4f90:	d1 1d       	adc	r29, r1
      }
   }while (val != val1);
    4f92:	c0 17       	cp	r28, r16
    4f94:	d1 07       	cpc	r29, r17
    4f96:	f1 f6       	brne	.-68     	; 0x4f54 <getSn_TX_FSR+0x50>
   return val;
}
    4f98:	ce 01       	movw	r24, r28
    4f9a:	df 91       	pop	r29
    4f9c:	cf 91       	pop	r28
    4f9e:	1f 91       	pop	r17
    4fa0:	0f 91       	pop	r16
    4fa2:	ff 90       	pop	r15
    4fa4:	ef 90       	pop	r14
    4fa6:	df 90       	pop	r13
    4fa8:	cf 90       	pop	r12
    4faa:	bf 90       	pop	r11
    4fac:	af 90       	pop	r10
    4fae:	9f 90       	pop	r9
    4fb0:	8f 90       	pop	r8
    4fb2:	08 95       	ret

00004fb4 <getSn_RX_RSR>:


uint16_t getSn_RX_RSR(uint8_t sn)
{
    4fb4:	8f 92       	push	r8
    4fb6:	9f 92       	push	r9
    4fb8:	af 92       	push	r10
    4fba:	bf 92       	push	r11
    4fbc:	cf 92       	push	r12
    4fbe:	df 92       	push	r13
    4fc0:	ef 92       	push	r14
    4fc2:	ff 92       	push	r15
    4fc4:	0f 93       	push	r16
    4fc6:	1f 93       	push	r17
    4fc8:	cf 93       	push	r28
    4fca:	df 93       	push	r29
   uint16_t val=0,val1=0;

   do
   {
      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
    4fcc:	24 e0       	ldi	r18, 0x04	; 4
    4fce:	82 9f       	mul	r24, r18
    4fd0:	c0 01       	movw	r24, r0
    4fd2:	11 24       	eor	r1, r1
    4fd4:	6c 01       	movw	r12, r24
    4fd6:	2f ef       	ldi	r18, 0xFF	; 255
    4fd8:	c2 1a       	sub	r12, r18
    4fda:	d2 0a       	sbc	r13, r18
    4fdc:	23 e0       	ldi	r18, 0x03	; 3
    4fde:	cc 0c       	add	r12, r12
    4fe0:	dd 1c       	adc	r13, r13
    4fe2:	2a 95       	dec	r18
    4fe4:	e1 f7       	brne	.-8      	; 0x4fde <getSn_RX_RSR+0x2a>
    4fe6:	46 01       	movw	r8, r12
    4fe8:	8a ed       	ldi	r24, 0xDA	; 218
    4fea:	98 1a       	sub	r9, r24
    4fec:	09 2c       	mov	r0, r9
    4fee:	00 0c       	add	r0, r0
    4ff0:	aa 08       	sbc	r10, r10
    4ff2:	bb 08       	sbc	r11, r11
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    4ff4:	29 ed       	ldi	r18, 0xD9	; 217
    4ff6:	d2 1a       	sub	r13, r18
    4ff8:	0d 2c       	mov	r0, r13
    4ffa:	00 0c       	add	r0, r0
    4ffc:	ee 08       	sbc	r14, r14
    4ffe:	ff 08       	sbc	r15, r15
}


uint16_t getSn_RX_RSR(uint8_t sn)
{
   uint16_t val=0,val1=0;
    5000:	c0 e0       	ldi	r28, 0x00	; 0
    5002:	d0 e0       	ldi	r29, 0x00	; 0

   do
   {
      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
    5004:	c5 01       	movw	r24, r10
    5006:	b4 01       	movw	r22, r8
    5008:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    500c:	08 2f       	mov	r16, r24
    500e:	10 e0       	ldi	r17, 0x00	; 0
    5010:	10 2f       	mov	r17, r16
    5012:	00 27       	eor	r16, r16
    5014:	c7 01       	movw	r24, r14
    5016:	b6 01       	movw	r22, r12
    5018:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    501c:	08 0f       	add	r16, r24
    501e:	11 1d       	adc	r17, r1
      if (val1 != 0)
    5020:	01 15       	cp	r16, r1
    5022:	11 05       	cpc	r17, r1
    5024:	71 f0       	breq	.+28     	; 0x5042 <getSn_RX_RSR+0x8e>
      {
        val = WIZCHIP_READ(Sn_RX_RSR(sn));
    5026:	c5 01       	movw	r24, r10
    5028:	b4 01       	movw	r22, r8
    502a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
    502e:	c8 2f       	mov	r28, r24
    5030:	d0 e0       	ldi	r29, 0x00	; 0
    5032:	dc 2f       	mov	r29, r28
    5034:	cc 27       	eor	r28, r28
    5036:	c7 01       	movw	r24, r14
    5038:	b6 01       	movw	r22, r12
    503a:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    503e:	c8 0f       	add	r28, r24
    5040:	d1 1d       	adc	r29, r1
      }
   }while (val != val1);
    5042:	c0 17       	cp	r28, r16
    5044:	d1 07       	cpc	r29, r17
    5046:	f1 f6       	brne	.-68     	; 0x5004 <getSn_RX_RSR+0x50>
   return val;
}
    5048:	ce 01       	movw	r24, r28
    504a:	df 91       	pop	r29
    504c:	cf 91       	pop	r28
    504e:	1f 91       	pop	r17
    5050:	0f 91       	pop	r16
    5052:	ff 90       	pop	r15
    5054:	ef 90       	pop	r14
    5056:	df 90       	pop	r13
    5058:	cf 90       	pop	r12
    505a:	bf 90       	pop	r11
    505c:	af 90       	pop	r10
    505e:	9f 90       	pop	r9
    5060:	8f 90       	pop	r8
    5062:	08 95       	ret

00005064 <wiz_send_data>:

void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
{
    5064:	2f 92       	push	r2
    5066:	3f 92       	push	r3
    5068:	4f 92       	push	r4
    506a:	5f 92       	push	r5
    506c:	6f 92       	push	r6
    506e:	7f 92       	push	r7
    5070:	8f 92       	push	r8
    5072:	9f 92       	push	r9
    5074:	af 92       	push	r10
    5076:	bf 92       	push	r11
    5078:	cf 92       	push	r12
    507a:	df 92       	push	r13
    507c:	ef 92       	push	r14
    507e:	ff 92       	push	r15
    5080:	0f 93       	push	r16
    5082:	1f 93       	push	r17
    5084:	cf 93       	push	r28
    5086:	df 93       	push	r29
   uint16_t ptr = 0;
   uint32_t addrsel = 0;

   if(len == 0)  return;
    5088:	41 15       	cp	r20, r1
    508a:	51 05       	cpc	r21, r1
    508c:	09 f4       	brne	.+2      	; 0x5090 <wiz_send_data+0x2c>
    508e:	67 c0       	rjmp	.+206    	; 0x515e <wiz_send_data+0xfa>
    5090:	5a 01       	movw	r10, r20
    5092:	4b 01       	movw	r8, r22
   ptr = getSn_TX_WR(sn);
    5094:	04 e0       	ldi	r16, 0x04	; 4
    5096:	80 9f       	mul	r24, r16
    5098:	e0 01       	movw	r28, r0
    509a:	11 24       	eor	r1, r1
    509c:	6e 01       	movw	r12, r28
    509e:	1f ef       	ldi	r17, 0xFF	; 255
    50a0:	c1 1a       	sub	r12, r17
    50a2:	d1 0a       	sbc	r13, r17
    50a4:	83 e0       	ldi	r24, 0x03	; 3
    50a6:	cc 0c       	add	r12, r12
    50a8:	dd 1c       	adc	r13, r13
    50aa:	8a 95       	dec	r24
    50ac:	e1 f7       	brne	.-8      	; 0x50a6 <wiz_send_data+0x42>
    50ae:	26 01       	movw	r4, r12
    50b0:	2c ed       	ldi	r18, 0xDC	; 220
    50b2:	52 1a       	sub	r5, r18
    50b4:	05 2c       	mov	r0, r5
    50b6:	00 0c       	add	r0, r0
    50b8:	66 08       	sbc	r6, r6
    50ba:	77 08       	sbc	r7, r7
    50bc:	c3 01       	movw	r24, r6
    50be:	b2 01       	movw	r22, r4
    50c0:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    50c4:	08 2f       	mov	r16, r24
    50c6:	3b ed       	ldi	r19, 0xDB	; 219
    50c8:	d3 1a       	sub	r13, r19
    50ca:	0d 2c       	mov	r0, r13
    50cc:	00 0c       	add	r0, r0
    50ce:	ee 08       	sbc	r14, r14
    50d0:	ff 08       	sbc	r15, r15
    50d2:	c7 01       	movw	r24, r14
    50d4:	b6 01       	movw	r22, r12
    50d6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    50da:	10 e0       	ldi	r17, 0x00	; 0
    50dc:	10 2f       	mov	r17, r16
    50de:	00 27       	eor	r16, r16
    50e0:	18 01       	movw	r2, r16
    50e2:	28 0e       	add	r2, r24
    50e4:	31 1c       	adc	r3, r1
   //M20140501 : implict type casting -> explict type casting
   //addrsel = (ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
    50e6:	22 96       	adiw	r28, 0x02	; 2
    50e8:	23 e0       	ldi	r18, 0x03	; 3
    50ea:	cc 0f       	add	r28, r28
    50ec:	dd 1f       	adc	r29, r29
    50ee:	2a 95       	dec	r18
    50f0:	e1 f7       	brne	.-8      	; 0x50ea <wiz_send_data+0x86>
    50f2:	ce 01       	movw	r24, r28
    50f4:	dd 0f       	add	r29, r29
    50f6:	aa 0b       	sbc	r26, r26
    50f8:	bb 0b       	sbc	r27, r27
    50fa:	a1 01       	movw	r20, r2
    50fc:	60 e0       	ldi	r22, 0x00	; 0
    50fe:	70 e0       	ldi	r23, 0x00	; 0
    5100:	76 2f       	mov	r23, r22
    5102:	65 2f       	mov	r22, r21
    5104:	54 2f       	mov	r21, r20
    5106:	44 27       	eor	r20, r20
    5108:	8c 01       	movw	r16, r24
    510a:	9d 01       	movw	r18, r26
    510c:	04 0f       	add	r16, r20
    510e:	15 1f       	adc	r17, r21
    5110:	26 1f       	adc	r18, r22
    5112:	37 1f       	adc	r19, r23
    5114:	c9 01       	movw	r24, r18
    5116:	b8 01       	movw	r22, r16
    5118:	95 01       	movw	r18, r10
    511a:	a4 01       	movw	r20, r8
    511c:	0e 94 01 27 	call	0x4e02	; 0x4e02 <WIZCHIP_WRITE_BUF>
   
   ptr += len;
    5120:	81 01       	movw	r16, r2
    5122:	0a 0d       	add	r16, r10
    5124:	1b 1d       	adc	r17, r11
   setSn_TX_WR(sn,ptr);
    5126:	41 2f       	mov	r20, r17
    5128:	c3 01       	movw	r24, r6
    512a:	b2 01       	movw	r22, r4
    512c:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    5130:	40 2f       	mov	r20, r16
    5132:	c7 01       	movw	r24, r14
    5134:	b6 01       	movw	r22, r12
}
    5136:	df 91       	pop	r29
    5138:	cf 91       	pop	r28
    513a:	1f 91       	pop	r17
    513c:	0f 91       	pop	r16
    513e:	ff 90       	pop	r15
    5140:	ef 90       	pop	r14
    5142:	df 90       	pop	r13
    5144:	cf 90       	pop	r12
    5146:	bf 90       	pop	r11
    5148:	af 90       	pop	r10
    514a:	9f 90       	pop	r9
    514c:	8f 90       	pop	r8
    514e:	7f 90       	pop	r7
    5150:	6f 90       	pop	r6
    5152:	5f 90       	pop	r5
    5154:	4f 90       	pop	r4
    5156:	3f 90       	pop	r3
    5158:	2f 90       	pop	r2
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_TXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
   
   ptr += len;
   setSn_TX_WR(sn,ptr);
    515a:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
}
    515e:	df 91       	pop	r29
    5160:	cf 91       	pop	r28
    5162:	1f 91       	pop	r17
    5164:	0f 91       	pop	r16
    5166:	ff 90       	pop	r15
    5168:	ef 90       	pop	r14
    516a:	df 90       	pop	r13
    516c:	cf 90       	pop	r12
    516e:	bf 90       	pop	r11
    5170:	af 90       	pop	r10
    5172:	9f 90       	pop	r9
    5174:	8f 90       	pop	r8
    5176:	7f 90       	pop	r7
    5178:	6f 90       	pop	r6
    517a:	5f 90       	pop	r5
    517c:	4f 90       	pop	r4
    517e:	3f 90       	pop	r3
    5180:	2f 90       	pop	r2
    5182:	08 95       	ret

00005184 <wiz_recv_data>:

void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
{
    5184:	2f 92       	push	r2
    5186:	3f 92       	push	r3
    5188:	4f 92       	push	r4
    518a:	5f 92       	push	r5
    518c:	6f 92       	push	r6
    518e:	7f 92       	push	r7
    5190:	8f 92       	push	r8
    5192:	9f 92       	push	r9
    5194:	af 92       	push	r10
    5196:	bf 92       	push	r11
    5198:	cf 92       	push	r12
    519a:	df 92       	push	r13
    519c:	ef 92       	push	r14
    519e:	ff 92       	push	r15
    51a0:	0f 93       	push	r16
    51a2:	1f 93       	push	r17
    51a4:	cf 93       	push	r28
    51a6:	df 93       	push	r29
   uint16_t ptr = 0;
   uint32_t addrsel = 0;
   
   if(len == 0) return;
    51a8:	41 15       	cp	r20, r1
    51aa:	51 05       	cpc	r21, r1
    51ac:	09 f4       	brne	.+2      	; 0x51b0 <wiz_recv_data+0x2c>
    51ae:	67 c0       	rjmp	.+206    	; 0x527e <wiz_recv_data+0xfa>
    51b0:	5a 01       	movw	r10, r20
    51b2:	4b 01       	movw	r8, r22
   ptr = getSn_RX_RD(sn);
    51b4:	04 e0       	ldi	r16, 0x04	; 4
    51b6:	80 9f       	mul	r24, r16
    51b8:	e0 01       	movw	r28, r0
    51ba:	11 24       	eor	r1, r1
    51bc:	6e 01       	movw	r12, r28
    51be:	1f ef       	ldi	r17, 0xFF	; 255
    51c0:	c1 1a       	sub	r12, r17
    51c2:	d1 0a       	sbc	r13, r17
    51c4:	83 e0       	ldi	r24, 0x03	; 3
    51c6:	cc 0c       	add	r12, r12
    51c8:	dd 1c       	adc	r13, r13
    51ca:	8a 95       	dec	r24
    51cc:	e1 f7       	brne	.-8      	; 0x51c6 <wiz_recv_data+0x42>
    51ce:	26 01       	movw	r4, r12
    51d0:	28 ed       	ldi	r18, 0xD8	; 216
    51d2:	52 1a       	sub	r5, r18
    51d4:	05 2c       	mov	r0, r5
    51d6:	00 0c       	add	r0, r0
    51d8:	66 08       	sbc	r6, r6
    51da:	77 08       	sbc	r7, r7
    51dc:	c3 01       	movw	r24, r6
    51de:	b2 01       	movw	r22, r4
    51e0:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    51e4:	08 2f       	mov	r16, r24
    51e6:	37 ed       	ldi	r19, 0xD7	; 215
    51e8:	d3 1a       	sub	r13, r19
    51ea:	0d 2c       	mov	r0, r13
    51ec:	00 0c       	add	r0, r0
    51ee:	ee 08       	sbc	r14, r14
    51f0:	ff 08       	sbc	r15, r15
    51f2:	c7 01       	movw	r24, r14
    51f4:	b6 01       	movw	r22, r12
    51f6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    51fa:	10 e0       	ldi	r17, 0x00	; 0
    51fc:	10 2f       	mov	r17, r16
    51fe:	00 27       	eor	r16, r16
    5200:	18 01       	movw	r2, r16
    5202:	28 0e       	add	r2, r24
    5204:	31 1c       	adc	r3, r1
   //M20140501 : implict type casting -> explict type casting
   //addrsel = ((ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_READ_BUF(addrsel, wizdata, len);
    5206:	23 96       	adiw	r28, 0x03	; 3
    5208:	23 e0       	ldi	r18, 0x03	; 3
    520a:	cc 0f       	add	r28, r28
    520c:	dd 1f       	adc	r29, r29
    520e:	2a 95       	dec	r18
    5210:	e1 f7       	brne	.-8      	; 0x520a <wiz_recv_data+0x86>
    5212:	ce 01       	movw	r24, r28
    5214:	dd 0f       	add	r29, r29
    5216:	aa 0b       	sbc	r26, r26
    5218:	bb 0b       	sbc	r27, r27
    521a:	a1 01       	movw	r20, r2
    521c:	60 e0       	ldi	r22, 0x00	; 0
    521e:	70 e0       	ldi	r23, 0x00	; 0
    5220:	76 2f       	mov	r23, r22
    5222:	65 2f       	mov	r22, r21
    5224:	54 2f       	mov	r21, r20
    5226:	44 27       	eor	r20, r20
    5228:	8c 01       	movw	r16, r24
    522a:	9d 01       	movw	r18, r26
    522c:	04 0f       	add	r16, r20
    522e:	15 1f       	adc	r17, r21
    5230:	26 1f       	adc	r18, r22
    5232:	37 1f       	adc	r19, r23
    5234:	c9 01       	movw	r24, r18
    5236:	b8 01       	movw	r22, r16
    5238:	95 01       	movw	r18, r10
    523a:	a4 01       	movw	r20, r8
    523c:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <WIZCHIP_READ_BUF>
   ptr += len;
    5240:	81 01       	movw	r16, r2
    5242:	0a 0d       	add	r16, r10
    5244:	1b 1d       	adc	r17, r11
   
   setSn_RX_RD(sn,ptr);
    5246:	41 2f       	mov	r20, r17
    5248:	c3 01       	movw	r24, r6
    524a:	b2 01       	movw	r22, r4
    524c:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    5250:	40 2f       	mov	r20, r16
    5252:	c7 01       	movw	r24, r14
    5254:	b6 01       	movw	r22, r12
}
    5256:	df 91       	pop	r29
    5258:	cf 91       	pop	r28
    525a:	1f 91       	pop	r17
    525c:	0f 91       	pop	r16
    525e:	ff 90       	pop	r15
    5260:	ef 90       	pop	r14
    5262:	df 90       	pop	r13
    5264:	cf 90       	pop	r12
    5266:	bf 90       	pop	r11
    5268:	af 90       	pop	r10
    526a:	9f 90       	pop	r9
    526c:	8f 90       	pop	r8
    526e:	7f 90       	pop	r7
    5270:	6f 90       	pop	r6
    5272:	5f 90       	pop	r5
    5274:	4f 90       	pop	r4
    5276:	3f 90       	pop	r3
    5278:	2f 90       	pop	r2
   addrsel = ((uint32_t)ptr << 8) + (WIZCHIP_RXBUF_BLOCK(sn) << 3);
   //
   WIZCHIP_READ_BUF(addrsel, wizdata, len);
   ptr += len;
   
   setSn_RX_RD(sn,ptr);
    527a:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
}
    527e:	df 91       	pop	r29
    5280:	cf 91       	pop	r28
    5282:	1f 91       	pop	r17
    5284:	0f 91       	pop	r16
    5286:	ff 90       	pop	r15
    5288:	ef 90       	pop	r14
    528a:	df 90       	pop	r13
    528c:	cf 90       	pop	r12
    528e:	bf 90       	pop	r11
    5290:	af 90       	pop	r10
    5292:	9f 90       	pop	r9
    5294:	8f 90       	pop	r8
    5296:	7f 90       	pop	r7
    5298:	6f 90       	pop	r6
    529a:	5f 90       	pop	r5
    529c:	4f 90       	pop	r4
    529e:	3f 90       	pop	r3
    52a0:	2f 90       	pop	r2
    52a2:	08 95       	ret

000052a4 <wiz_recv_ignore>:
    52a4:	8f 92       	push	r8
    52a6:	9f 92       	push	r9
    52a8:	af 92       	push	r10
    52aa:	bf 92       	push	r11
    52ac:	cf 92       	push	r12
    52ae:	df 92       	push	r13
    52b0:	ef 92       	push	r14
    52b2:	ff 92       	push	r15
    52b4:	1f 93       	push	r17
    52b6:	cf 93       	push	r28
    52b8:	df 93       	push	r29
    52ba:	eb 01       	movw	r28, r22
    52bc:	24 e0       	ldi	r18, 0x04	; 4
    52be:	82 9f       	mul	r24, r18
    52c0:	c0 01       	movw	r24, r0
    52c2:	11 24       	eor	r1, r1
    52c4:	6c 01       	movw	r12, r24
    52c6:	2f ef       	ldi	r18, 0xFF	; 255
    52c8:	c2 1a       	sub	r12, r18
    52ca:	d2 0a       	sbc	r13, r18
    52cc:	83 e0       	ldi	r24, 0x03	; 3
    52ce:	cc 0c       	add	r12, r12
    52d0:	dd 1c       	adc	r13, r13
    52d2:	8a 95       	dec	r24
    52d4:	e1 f7       	brne	.-8      	; 0x52ce <wiz_recv_ignore+0x2a>
    52d6:	46 01       	movw	r8, r12
    52d8:	88 ed       	ldi	r24, 0xD8	; 216
    52da:	98 1a       	sub	r9, r24
    52dc:	09 2c       	mov	r0, r9
    52de:	00 0c       	add	r0, r0
    52e0:	aa 08       	sbc	r10, r10
    52e2:	bb 08       	sbc	r11, r11
    52e4:	c5 01       	movw	r24, r10
    52e6:	b4 01       	movw	r22, r8
    52e8:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    52ec:	18 2f       	mov	r17, r24
    52ee:	27 ed       	ldi	r18, 0xD7	; 215
    52f0:	d2 1a       	sub	r13, r18
    52f2:	0d 2c       	mov	r0, r13
    52f4:	00 0c       	add	r0, r0
    52f6:	ee 08       	sbc	r14, r14
    52f8:	ff 08       	sbc	r15, r15
    52fa:	c7 01       	movw	r24, r14
    52fc:	b6 01       	movw	r22, r12
    52fe:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <WIZCHIP_READ>
    5302:	21 2f       	mov	r18, r17
    5304:	30 e0       	ldi	r19, 0x00	; 0
    5306:	32 2f       	mov	r19, r18
    5308:	22 27       	eor	r18, r18
    530a:	c8 0f       	add	r28, r24
    530c:	d1 1d       	adc	r29, r1
    530e:	c2 0f       	add	r28, r18
    5310:	d3 1f       	adc	r29, r19
    5312:	4d 2f       	mov	r20, r29
    5314:	c5 01       	movw	r24, r10
    5316:	b4 01       	movw	r22, r8
    5318:	0e 94 13 26 	call	0x4c26	; 0x4c26 <WIZCHIP_WRITE>
    531c:	4c 2f       	mov	r20, r28
    531e:	c7 01       	movw	r24, r14
    5320:	b6 01       	movw	r22, r12
    5322:	df 91       	pop	r29
    5324:	cf 91       	pop	r28
    5326:	1f 91       	pop	r17
    5328:	ff 90       	pop	r15
    532a:	ef 90       	pop	r14
    532c:	df 90       	pop	r13
    532e:	cf 90       	pop	r12
    5330:	bf 90       	pop	r11
    5332:	af 90       	pop	r10
    5334:	9f 90       	pop	r9
    5336:	8f 90       	pop	r8
    5338:	0c 94 13 26 	jmp	0x4c26	; 0x4c26 <WIZCHIP_WRITE>

0000533c <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

short main( void )
{
    533c:	ef 92       	push	r14
    533e:	ff 92       	push	r15
    5340:	0f 93       	push	r16
    5342:	cf 93       	push	r28
    5344:	df 93       	push	r29
    5346:	1f 92       	push	r1
    5348:	cd b7       	in	r28, 0x3d	; 61
    534a:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
    534c:	41 e0       	ldi	r20, 0x01	; 1
    534e:	50 e0       	ldi	r21, 0x00	; 0
    5350:	60 e5       	ldi	r22, 0x50	; 80
    5352:	70 e0       	ldi	r23, 0x00	; 0
    5354:	ce 01       	movw	r24, r28
    5356:	01 96       	adiw	r24, 0x01	; 1
    5358:	0e 94 95 2a 	call	0x552a	; 0x552a <eeprom_read_block>
	ucCount++;
    535c:	69 81       	ldd	r22, Y+1	; 0x01
    535e:	6f 5f       	subi	r22, 0xFF	; 255
    5360:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
    5362:	80 e5       	ldi	r24, 0x50	; 80
    5364:	90 e0       	ldi	r25, 0x00	; 0
    5366:	0e 94 a5 2a 	call	0x554a	; 0x554a <eeprom_write_byte>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
    536a:	0e 94 bd 00 	call	0x17a	; 0x17a <vParTestInitialise>
	//vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
	//vStartRegTestTasks();

	/* Create the tasks defined within this file. */
	//xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
	xTaskCreate( vBlinkyFunction, "Blink", 128, NULL, 3, NULL );
    536e:	e1 2c       	mov	r14, r1
    5370:	f1 2c       	mov	r15, r1
    5372:	03 e0       	ldi	r16, 0x03	; 3
    5374:	20 e0       	ldi	r18, 0x00	; 0
    5376:	30 e0       	ldi	r19, 0x00	; 0
    5378:	40 e8       	ldi	r20, 0x80	; 128
    537a:	50 e0       	ldi	r21, 0x00	; 0
    537c:	6d e2       	ldi	r22, 0x2D	; 45
    537e:	71 e0       	ldi	r23, 0x01	; 1
    5380:	8f e7       	ldi	r24, 0x7F	; 127
    5382:	90 e0       	ldi	r25, 0x00	; 0
    5384:	0e 94 73 05 	call	0xae6	; 0xae6 <xTaskCreate>
    */

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    5388:	0e 94 c3 06 	call	0xd86	; 0xd86 <vTaskStartScheduler>

	return 0;
}
    538c:	80 e0       	ldi	r24, 0x00	; 0
    538e:	90 e0       	ldi	r25, 0x00	; 0
    5390:	0f 90       	pop	r0
    5392:	df 91       	pop	r29
    5394:	cf 91       	pop	r28
    5396:	0f 91       	pop	r16
    5398:	ff 90       	pop	r15
    539a:	ef 90       	pop	r14
    539c:	08 95       	ret

0000539e <__udivmodhi4>:
    539e:	aa 1b       	sub	r26, r26
    53a0:	bb 1b       	sub	r27, r27
    53a2:	51 e1       	ldi	r21, 0x11	; 17
    53a4:	07 c0       	rjmp	.+14     	; 0x53b4 <__udivmodhi4_ep>

000053a6 <__udivmodhi4_loop>:
    53a6:	aa 1f       	adc	r26, r26
    53a8:	bb 1f       	adc	r27, r27
    53aa:	a6 17       	cp	r26, r22
    53ac:	b7 07       	cpc	r27, r23
    53ae:	10 f0       	brcs	.+4      	; 0x53b4 <__udivmodhi4_ep>
    53b0:	a6 1b       	sub	r26, r22
    53b2:	b7 0b       	sbc	r27, r23

000053b4 <__udivmodhi4_ep>:
    53b4:	88 1f       	adc	r24, r24
    53b6:	99 1f       	adc	r25, r25
    53b8:	5a 95       	dec	r21
    53ba:	a9 f7       	brne	.-22     	; 0x53a6 <__udivmodhi4_loop>
    53bc:	80 95       	com	r24
    53be:	90 95       	com	r25
    53c0:	bc 01       	movw	r22, r24
    53c2:	cd 01       	movw	r24, r26
    53c4:	08 95       	ret

000053c6 <__udivmodsi4>:
    53c6:	a1 e2       	ldi	r26, 0x21	; 33
    53c8:	1a 2e       	mov	r1, r26
    53ca:	aa 1b       	sub	r26, r26
    53cc:	bb 1b       	sub	r27, r27
    53ce:	fd 01       	movw	r30, r26
    53d0:	0d c0       	rjmp	.+26     	; 0x53ec <__udivmodsi4_ep>

000053d2 <__udivmodsi4_loop>:
    53d2:	aa 1f       	adc	r26, r26
    53d4:	bb 1f       	adc	r27, r27
    53d6:	ee 1f       	adc	r30, r30
    53d8:	ff 1f       	adc	r31, r31
    53da:	a2 17       	cp	r26, r18
    53dc:	b3 07       	cpc	r27, r19
    53de:	e4 07       	cpc	r30, r20
    53e0:	f5 07       	cpc	r31, r21
    53e2:	20 f0       	brcs	.+8      	; 0x53ec <__udivmodsi4_ep>
    53e4:	a2 1b       	sub	r26, r18
    53e6:	b3 0b       	sbc	r27, r19
    53e8:	e4 0b       	sbc	r30, r20
    53ea:	f5 0b       	sbc	r31, r21

000053ec <__udivmodsi4_ep>:
    53ec:	66 1f       	adc	r22, r22
    53ee:	77 1f       	adc	r23, r23
    53f0:	88 1f       	adc	r24, r24
    53f2:	99 1f       	adc	r25, r25
    53f4:	1a 94       	dec	r1
    53f6:	69 f7       	brne	.-38     	; 0x53d2 <__udivmodsi4_loop>
    53f8:	60 95       	com	r22
    53fa:	70 95       	com	r23
    53fc:	80 95       	com	r24
    53fe:	90 95       	com	r25
    5400:	9b 01       	movw	r18, r22
    5402:	ac 01       	movw	r20, r24
    5404:	bd 01       	movw	r22, r26
    5406:	cf 01       	movw	r24, r30
    5408:	08 95       	ret

0000540a <__divmodsi4>:
    540a:	05 2e       	mov	r0, r21
    540c:	97 fb       	bst	r25, 7
    540e:	1e f4       	brtc	.+6      	; 0x5416 <__divmodsi4+0xc>
    5410:	00 94       	com	r0
    5412:	0e 94 1c 2a 	call	0x5438	; 0x5438 <__negsi2>
    5416:	57 fd       	sbrc	r21, 7
    5418:	07 d0       	rcall	.+14     	; 0x5428 <__divmodsi4_neg2>
    541a:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <__udivmodsi4>
    541e:	07 fc       	sbrc	r0, 7
    5420:	03 d0       	rcall	.+6      	; 0x5428 <__divmodsi4_neg2>
    5422:	4e f4       	brtc	.+18     	; 0x5436 <__divmodsi4_exit>
    5424:	0c 94 1c 2a 	jmp	0x5438	; 0x5438 <__negsi2>

00005428 <__divmodsi4_neg2>:
    5428:	50 95       	com	r21
    542a:	40 95       	com	r20
    542c:	30 95       	com	r19
    542e:	21 95       	neg	r18
    5430:	3f 4f       	sbci	r19, 0xFF	; 255
    5432:	4f 4f       	sbci	r20, 0xFF	; 255
    5434:	5f 4f       	sbci	r21, 0xFF	; 255

00005436 <__divmodsi4_exit>:
    5436:	08 95       	ret

00005438 <__negsi2>:
    5438:	90 95       	com	r25
    543a:	80 95       	com	r24
    543c:	70 95       	com	r23
    543e:	61 95       	neg	r22
    5440:	7f 4f       	sbci	r23, 0xFF	; 255
    5442:	8f 4f       	sbci	r24, 0xFF	; 255
    5444:	9f 4f       	sbci	r25, 0xFF	; 255
    5446:	08 95       	ret

00005448 <__tablejump2__>:
    5448:	ee 0f       	add	r30, r30
    544a:	ff 1f       	adc	r31, r31
    544c:	05 90       	lpm	r0, Z+
    544e:	f4 91       	lpm	r31, Z
    5450:	e0 2d       	mov	r30, r0
    5452:	09 94       	ijmp

00005454 <__mulshisi3>:
    5454:	b7 ff       	sbrs	r27, 7
    5456:	0c 94 32 2a 	jmp	0x5464	; 0x5464 <__muluhisi3>

0000545a <__mulohisi3>:
    545a:	0e 94 32 2a 	call	0x5464	; 0x5464 <__muluhisi3>
    545e:	82 1b       	sub	r24, r18
    5460:	93 0b       	sbc	r25, r19
    5462:	08 95       	ret

00005464 <__muluhisi3>:
    5464:	0e 94 3d 2a 	call	0x547a	; 0x547a <__umulhisi3>
    5468:	a5 9f       	mul	r26, r21
    546a:	90 0d       	add	r25, r0
    546c:	b4 9f       	mul	r27, r20
    546e:	90 0d       	add	r25, r0
    5470:	a4 9f       	mul	r26, r20
    5472:	80 0d       	add	r24, r0
    5474:	91 1d       	adc	r25, r1
    5476:	11 24       	eor	r1, r1
    5478:	08 95       	ret

0000547a <__umulhisi3>:
    547a:	a2 9f       	mul	r26, r18
    547c:	b0 01       	movw	r22, r0
    547e:	b3 9f       	mul	r27, r19
    5480:	c0 01       	movw	r24, r0
    5482:	a3 9f       	mul	r26, r19
    5484:	70 0d       	add	r23, r0
    5486:	81 1d       	adc	r24, r1
    5488:	11 24       	eor	r1, r1
    548a:	91 1d       	adc	r25, r1
    548c:	b2 9f       	mul	r27, r18
    548e:	70 0d       	add	r23, r0
    5490:	81 1d       	adc	r24, r1
    5492:	11 24       	eor	r1, r1
    5494:	91 1d       	adc	r25, r1
    5496:	08 95       	ret

00005498 <memcpy>:
    5498:	fb 01       	movw	r30, r22
    549a:	dc 01       	movw	r26, r24
    549c:	02 c0       	rjmp	.+4      	; 0x54a2 <memcpy+0xa>
    549e:	01 90       	ld	r0, Z+
    54a0:	0d 92       	st	X+, r0
    54a2:	41 50       	subi	r20, 0x01	; 1
    54a4:	50 40       	sbci	r21, 0x00	; 0
    54a6:	d8 f7       	brcc	.-10     	; 0x549e <memcpy+0x6>
    54a8:	08 95       	ret

000054aa <itoa>:
    54aa:	45 32       	cpi	r20, 0x25	; 37
    54ac:	51 05       	cpc	r21, r1
    54ae:	20 f4       	brcc	.+8      	; 0x54b8 <itoa+0xe>
    54b0:	42 30       	cpi	r20, 0x02	; 2
    54b2:	10 f0       	brcs	.+4      	; 0x54b8 <itoa+0xe>
    54b4:	0c 94 60 2a 	jmp	0x54c0	; 0x54c0 <__itoa_ncheck>
    54b8:	fb 01       	movw	r30, r22
    54ba:	10 82       	st	Z, r1
    54bc:	cb 01       	movw	r24, r22
    54be:	08 95       	ret

000054c0 <__itoa_ncheck>:
    54c0:	bb 27       	eor	r27, r27
    54c2:	4a 30       	cpi	r20, 0x0A	; 10
    54c4:	31 f4       	brne	.+12     	; 0x54d2 <__itoa_ncheck+0x12>
    54c6:	99 23       	and	r25, r25
    54c8:	22 f4       	brpl	.+8      	; 0x54d2 <__itoa_ncheck+0x12>
    54ca:	bd e2       	ldi	r27, 0x2D	; 45
    54cc:	90 95       	com	r25
    54ce:	81 95       	neg	r24
    54d0:	9f 4f       	sbci	r25, 0xFF	; 255
    54d2:	0c 94 6c 2a 	jmp	0x54d8	; 0x54d8 <__utoa_common>

000054d6 <__utoa_ncheck>:
    54d6:	bb 27       	eor	r27, r27

000054d8 <__utoa_common>:
    54d8:	fb 01       	movw	r30, r22
    54da:	55 27       	eor	r21, r21
    54dc:	aa 27       	eor	r26, r26
    54de:	88 0f       	add	r24, r24
    54e0:	99 1f       	adc	r25, r25
    54e2:	aa 1f       	adc	r26, r26
    54e4:	a4 17       	cp	r26, r20
    54e6:	10 f0       	brcs	.+4      	; 0x54ec <__utoa_common+0x14>
    54e8:	a4 1b       	sub	r26, r20
    54ea:	83 95       	inc	r24
    54ec:	50 51       	subi	r21, 0x10	; 16
    54ee:	b9 f7       	brne	.-18     	; 0x54de <__utoa_common+0x6>
    54f0:	a0 5d       	subi	r26, 0xD0	; 208
    54f2:	aa 33       	cpi	r26, 0x3A	; 58
    54f4:	08 f0       	brcs	.+2      	; 0x54f8 <__utoa_common+0x20>
    54f6:	a9 5d       	subi	r26, 0xD9	; 217
    54f8:	a1 93       	st	Z+, r26
    54fa:	00 97       	sbiw	r24, 0x00	; 0
    54fc:	79 f7       	brne	.-34     	; 0x54dc <__utoa_common+0x4>
    54fe:	b1 11       	cpse	r27, r1
    5500:	b1 93       	st	Z+, r27
    5502:	11 92       	st	Z+, r1
    5504:	cb 01       	movw	r24, r22
    5506:	0c 94 85 2a 	jmp	0x550a	; 0x550a <strrev>

0000550a <strrev>:
    550a:	dc 01       	movw	r26, r24
    550c:	fc 01       	movw	r30, r24
    550e:	67 2f       	mov	r22, r23
    5510:	71 91       	ld	r23, Z+
    5512:	77 23       	and	r23, r23
    5514:	e1 f7       	brne	.-8      	; 0x550e <strrev+0x4>
    5516:	32 97       	sbiw	r30, 0x02	; 2
    5518:	04 c0       	rjmp	.+8      	; 0x5522 <strrev+0x18>
    551a:	7c 91       	ld	r23, X
    551c:	6d 93       	st	X+, r22
    551e:	70 83       	st	Z, r23
    5520:	62 91       	ld	r22, -Z
    5522:	ae 17       	cp	r26, r30
    5524:	bf 07       	cpc	r27, r31
    5526:	c8 f3       	brcs	.-14     	; 0x551a <strrev+0x10>
    5528:	08 95       	ret

0000552a <eeprom_read_block>:
    552a:	dc 01       	movw	r26, r24
    552c:	cb 01       	movw	r24, r22

0000552e <eeprom_read_blraw>:
    552e:	fc 01       	movw	r30, r24
    5530:	f9 99       	sbic	0x1f, 1	; 31
    5532:	fe cf       	rjmp	.-4      	; 0x5530 <eeprom_read_blraw+0x2>
    5534:	06 c0       	rjmp	.+12     	; 0x5542 <eeprom_read_blraw+0x14>
    5536:	f2 bd       	out	0x22, r31	; 34
    5538:	e1 bd       	out	0x21, r30	; 33
    553a:	f8 9a       	sbi	0x1f, 0	; 31
    553c:	31 96       	adiw	r30, 0x01	; 1
    553e:	00 b4       	in	r0, 0x20	; 32
    5540:	0d 92       	st	X+, r0
    5542:	41 50       	subi	r20, 0x01	; 1
    5544:	50 40       	sbci	r21, 0x00	; 0
    5546:	b8 f7       	brcc	.-18     	; 0x5536 <eeprom_read_blraw+0x8>
    5548:	08 95       	ret

0000554a <eeprom_write_byte>:
    554a:	26 2f       	mov	r18, r22

0000554c <eeprom_write_r18>:
    554c:	f9 99       	sbic	0x1f, 1	; 31
    554e:	fe cf       	rjmp	.-4      	; 0x554c <eeprom_write_r18>
    5550:	1f ba       	out	0x1f, r1	; 31
    5552:	92 bd       	out	0x22, r25	; 34
    5554:	81 bd       	out	0x21, r24	; 33
    5556:	20 bd       	out	0x20, r18	; 32
    5558:	0f b6       	in	r0, 0x3f	; 63
    555a:	f8 94       	cli
    555c:	fa 9a       	sbi	0x1f, 2	; 31
    555e:	f9 9a       	sbi	0x1f, 1	; 31
    5560:	0f be       	out	0x3f, r0	; 63
    5562:	01 96       	adiw	r24, 0x01	; 1
    5564:	08 95       	ret

00005566 <_exit>:
    5566:	f8 94       	cli

00005568 <__stop_program>:
    5568:	ff cf       	rjmp	.-2      	; 0x5568 <__stop_program>
